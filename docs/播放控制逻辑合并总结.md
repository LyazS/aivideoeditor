# 播放控制逻辑合并总结

## 📋 概述

成功合并了分散在多个文件中的重复播放控制逻辑，创建了统一的 `usePlaybackControls` 工具函数，提高了代码的可维护性和一致性。

## 🔄 重构前的问题

### 1. 重复的暂停播放逻辑
**模式：** `if (isWebAVReady() && videoStore.isPlaying) { webAVControls.pause() }`

**重复出现在：**
- `TimeScale.vue` - 时间刻度点击和播放头拖拽
- `VideoClip.vue` - 片段大小调整
- `useDragUtils.ts` - 拖拽操作
- `useWebAVControls.ts` - 画布销毁

### 2. 重复的WebAV就绪检查
**模式：** `if (!isWebAVReady()) { console.warn('WebAV canvas not ready'); return }`

**重复出现在：**
- `PlaybackControls.vue` - 播放/暂停和停止函数
- 其他需要WebAV操作的地方

### 3. 重复的播放重启逻辑
**模式：** `webAVControls.pause() + setTimeout(() => webAVControls.play(), 50)`

**重复出现在：**
- `PlaybackControls.vue` - 播放速度变更

## ✅ 重构后的解决方案

### 1. 创建专门的播放控制工具函数文件

创建了新文件 `frontend/src/composables/usePlaybackControls.ts`，专门管理播放控制逻辑：

```typescript
export function usePlaybackControls() {
  const videoStore = useVideoStore()
  const webAVControls = useWebAVControls()

  /**
   * 安全地暂停播放
   * 在需要暂停播放进行编辑操作时调用
   */
  function pauseForEditing(reason: string = '编辑操作') {
    if (isWebAVReady() && videoStore.isPlaying) {
      console.log(`⏸️ 因${reason}暂停播放`)
      webAVControls.pause()
      return true // 返回是否实际执行了暂停
    }
    return false
  }

  /**
   * 检查WebAV是否就绪，如果未就绪则显示警告
   */
  function ensureWebAVReady(operation: string = '操作'): boolean {
    if (!isWebAVReady()) {
      console.warn(`⚠️ WebAV canvas not ready for ${operation}`)
      return false
    }
    return true
  }

  /**
   * 安全地执行播放控制操作
   */
  function safePlaybackOperation(operation: () => void, operationName: string): boolean {
    if (!ensureWebAVReady(operationName)) {
      return false
    }
    
    try {
      operation()
      return true
    } catch (error) {
      console.error(`❌ ${operationName}执行失败:`, error)
      return false
    }
  }

  /**
   * 重启播放（用于播放速度变更等场景）
   */
  function restartPlayback(delay: number = 50) {
    if (!ensureWebAVReady('重启播放')) return

    const wasPlaying = videoStore.isPlaying
    if (wasPlaying) {
      console.log('🔄 重启播放以应用新设置')
      webAVControls.pause()
      setTimeout(() => {
        if (isWebAVReady()) {
          webAVControls.play()
        }
      }, delay)
    }
  }

  return {
    pauseForEditing,
    ensureWebAVReady,
    safePlaybackOperation,
    restartPlayback,
  }
}
```

### 2. 更新各个组件使用统一逻辑

#### PlaybackControls.vue
```typescript
// 之前
function togglePlayPause() {
  if (!isWebAVReady()) {
    console.warn('WebAV canvas not ready')
    return
  }
  // 播放/暂停逻辑...
}

// 之后
function togglePlayPause() {
  safePlaybackOperation(() => {
    if (isPlaying.value) {
      webAVControls.pause()
    } else {
      webAVControls.play()
    }
  }, '播放/暂停切换')
}
```

#### TimeScale.vue
```typescript
// 之前
if (isWebAVReady() && videoStore.isPlaying) {
  webAVControls.pause()
}

// 之后
pauseForEditing('时间刻度点击')
```

#### VideoClip.vue
```typescript
// 之前
if (isWebAVReady() && videoStore.isPlaying) {
  webAVControls.pause()
}

// 之后
pauseForEditing('片段大小调整')
```

## 📊 改进效果

### 1. 代码重复减少
- **重复的暂停逻辑：** 从 4 处减少到 1 处
- **重复的就绪检查：** 从多处减少到 1 处
- **重复的错误处理：** 统一到工具函数中

### 2. 维护性提升
- **统一的日志格式：** 所有播放控制操作都有一致的日志输出
- **统一的错误处理：** 所有操作都有相同的错误处理逻辑
- **统一的操作模式：** 所有播放控制都遵循相同的模式

### 3. 功能增强
- **更好的调试信息：** 每个暂停操作都会记录具体原因
- **更安全的操作：** 所有操作都有就绪状态检查和错误处理
- **更灵活的控制：** 提供了多种不同场景的播放控制方法

## 🎯 使用指南

### 在新组件中使用播放控制

```typescript
import { usePlaybackControls } from '../composables/usePlaybackControls'

export default {
  setup() {
    const { pauseForEditing, safePlaybackOperation, restartPlayback } = usePlaybackControls()
    
    // 需要暂停播放进行编辑时
    function startEditing() {
      pauseForEditing('开始编辑')
      // 编辑逻辑...
    }
    
    // 需要安全执行播放操作时
    function handlePlayback() {
      safePlaybackOperation(() => {
        // 播放控制逻辑...
      }, '自定义播放操作')
    }
    
    // 需要重启播放时（如设置变更）
    function applySettings() {
      // 应用设置...
      restartPlayback()
    }
  }
}
```

## 📁 最终文件架构

### 单一职责原则得到完美遵守：

1. **`frontend/src/composables/usePlaybackControls.ts`**
   - 🎯 **专门负责播放控制逻辑**
   - 提供 `pauseForEditing`, `ensureWebAVReady`, `safePlaybackOperation`, `restartPlayback`

2. **`frontend/src/composables/useDragUtils.ts`**
   - 🎯 **专门负责拖拽相关逻辑**
   - 提供拖拽数据管理、位置计算、类型检查等功能
   - 不再包含播放控制逻辑

3. **各个组件按需导入：**
   ```typescript
   // 需要播放控制的组件
   import { usePlaybackControls } from '../composables/usePlaybackControls'

   // 需要拖拽功能的组件
   import { useDragUtils } from '../composables/useDragUtils'
   ```

## 🔮 后续优化建议

1. **✅ 已完成：将 `usePlaybackControls` 独立为单独文件**
   - 已创建专门的 `usePlaybackControls.ts` 文件
   - 遵循单一职责原则，播放控制逻辑与拖拽逻辑完全分离

2. **扩展更多播放控制场景**
   - 可以添加更多常用的播放控制模式
   - 如：循环播放、区间播放等

3. **添加播放状态监听工具**
   - 提供统一的播放状态变化监听机制
   - 简化组件中的播放状态处理逻辑

## ✅ 总结

通过这次重构，我们成功地：
- 消除了播放控制逻辑的重复代码
- 提供了统一、安全、可维护的播放控制接口
- 改善了调试体验和错误处理
- 为未来的功能扩展奠定了良好基础

所有原有功能保持不变，但代码质量和维护性得到了显著提升。
