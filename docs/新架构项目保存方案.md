# æ–°æ¶æ„é¡¹ç›®ä¿å­˜æ–¹æ¡ˆ

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†æ–°æ¶æ„çš„é¡¹ç›®ä¿å­˜æ–¹æ¡ˆï¼Œæ—¨åœ¨è§£å†³å½“å‰æ–°æ¶æ„åœ¨æºæ–‡ä»¶ä¿å­˜æ–¹é¢çš„ä¸è¶³ï¼Œç¡®ä¿é¡¹ç›®ç´ æçš„å®Œæ•´æ€§å’Œå¯ç§»æ¤æ€§ã€‚æœ¬æ–¹æ¡ˆå‚è€ƒäº†æ—§æ¶æ„çš„æˆç†Ÿå®ç°ï¼Œå¹¶ç»“åˆæ–°æ¶æ„çš„ç‰¹ç‚¹è¿›è¡Œäº†ä¼˜åŒ–å’Œæ”¹è¿›ã€‚

## å½“å‰é—®é¢˜åˆ†æ

### 1. æºæ–‡ä»¶ä¿å­˜ç¼ºå¤±

æ–°æ¶æ„ç›®å‰åªä¿å­˜é¡¹ç›®é…ç½®ä¿¡æ¯ï¼Œæ²¡æœ‰å®é™…ä¿å­˜æºæ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•ï¼š

```typescript
// åœ¨ UnifiedProjectModule.ts çš„ saveCurrentProject æ–¹æ³•ä¸­
const updatedProject: UnifiedProjectConfig = {
  // ... å…¶ä»–é…ç½®
  
  // åª’ä½“æ•°æ® - ä¸ºç©ºå¯¹è±¡
  media: {},
}
```

### 2. åª’ä½“æ•°æ®å¤„ç†ä¸å½“

è™½ç„¶å¤„ç†äº†æ—¶é—´è½´é¡¹ç›®ä¸­çš„åª’ä½“æ•°æ®ï¼Œä½†åªæ˜¯ç®€å•åœ°å»é™¤äº†è¿è¡Œæ—¶å¯¹è±¡ï¼Œæ²¡æœ‰å»ºç«‹å®Œæ•´çš„ä¿å­˜æœºåˆ¶ï¼š

```typescript
// mediaItems åŒ…å« webav è¿è¡Œæ—¶å¯¹è±¡ï¼Œéœ€è¦æ¸…ç†
mediaItems: (mediaModule?.mediaItems.value || []).map(item => {
  // åˆ›å»ºåª’ä½“é¡¹ç›®çš„å¯æŒä¹…åŒ–å‰¯æœ¬ï¼Œå»æ‰è¿è¡Œæ—¶çš„ webav å¯¹è±¡
  const { webav, ...persistableItem } = item
  return persistableItem
}),
```

### 3. ç¼ºå°‘åª’ä½“å¼•ç”¨ç®¡ç†

æ–°æ¶æ„æ²¡æœ‰å»ºç«‹åª’ä½“å¼•ç”¨æœºåˆ¶ï¼Œæ— æ³•è¿½è¸ªåª’ä½“æ–‡ä»¶çš„å­˜å‚¨ä½ç½®å’ŒçŠ¶æ€ï¼š
- ç¼ºå°‘åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•çš„ä¿å­˜é€»è¾‘
- ç¼ºå°‘æ–‡ä»¶å®Œæ•´æ€§éªŒè¯æœºåˆ¶
- ç¼ºå°‘åª’ä½“å…ƒæ•°æ®ç®¡ç†

## è§£å†³æ–¹æ¡ˆè®¾è®¡

### 1. æ•´ä½“æ¶æ„è®¾è®¡

æ–°æ¶æ„çš„é¡¹ç›®ä¿å­˜æ–¹æ¡ˆé‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼Œä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªå±‚æ¬¡ï¼š

1. **åª’ä½“ç®¡ç†å±‚**ï¼šè´Ÿè´£åª’ä½“æ–‡ä»¶çš„ä¿å­˜ã€åŠ è½½å’ŒéªŒè¯
2. **é¡¹ç›®é…ç½®å±‚**ï¼šè´Ÿè´£é¡¹ç›®é…ç½®çš„ä¿å­˜å’ŒåŠ è½½
3. **å¼•ç”¨ç®¡ç†å±‚**ï¼šè´Ÿè´£åª’ä½“å¼•ç”¨çš„å»ºç«‹å’Œç»´æŠ¤
4. **å…ƒæ•°æ®ç®¡ç†å±‚**ï¼šè´Ÿè´£åª’ä½“å…ƒæ•°æ®çš„ä¿å­˜å’ŒåŠ è½½

### 2. æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 2.1 UnifiedMediaManager ç±»

åˆ›å»ºç»Ÿä¸€çš„åª’ä½“ç®¡ç†å™¨ï¼Œè´Ÿè´£åª’ä½“æ–‡ä»¶çš„ä¿å­˜ã€åŠ è½½å’ŒéªŒè¯ï¼š

```typescript
// frontend/src/unified/utils/UnifiedMediaManager.ts
export class UnifiedMediaManager {
  private static instance: UnifiedMediaManager
  
  // åª’ä½“æ–‡ä»¶å¤¹å¸¸é‡
  private readonly MEDIA_FOLDER = 'media'
  private readonly VIDEOS_FOLDER = 'videos'
  private readonly IMAGES_FOLDER = 'images'
  private readonly AUDIO_FOLDER = 'audio'
  
  // å•ä¾‹æ¨¡å¼
  static getInstance(): UnifiedMediaManager {
    if (!UnifiedMediaManager.instance) {
      UnifiedMediaManager.instance = new UnifiedMediaManager()
    }
    return UnifiedMediaManager.instance
  }
  
  /**
   * ä¿å­˜åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•
   * @param file åª’ä½“æ–‡ä»¶
   * @param projectId é¡¹ç›®ID
   * @param mediaType åª’ä½“ç±»å‹
   * @returns å­˜å‚¨è·¯å¾„
   */
  async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string> {
    try {
      // è·å–é¡¹ç›®ç›®å½•
      const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      
      // ç¡®ä¿mediaç›®å½•å­˜åœ¨
      const mediaHandle = await this.ensureDirectoryExists(projectHandle, this.MEDIA_FOLDER)
      
      // æ ¹æ®åª’ä½“ç±»å‹ç¡®å®šå­ç›®å½•
      let subFolder: string
      switch (mediaType) {
        case 'video': subFolder = this.VIDEOS_FOLDER; break
        case 'image': subFolder = this.IMAGES_FOLDER; break
        case 'audio': subFolder = this.AUDIO_FOLDER; break
        default: throw new Error(`ä¸æ”¯æŒçš„åª’ä½“ç±»å‹: ${mediaType}`)
      }
      
      // ç¡®ä¿å­ç›®å½•å­˜åœ¨
      const subHandle = await this.ensureDirectoryExists(mediaHandle, subFolder)
      
      // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼ˆé¿å…å†²çªï¼‰
      const timestamp = Date.now()
      const randomSuffix = Math.random().toString(36).substring(2, 8)
      const fileExtension = this.getFileExtension(file.name)
      const uniqueFileName = `${timestamp}_${randomSuffix}${fileExtension}`
      
      // ä¿å­˜æ–‡ä»¶
      const fileHandle = await subHandle.getFileHandle(uniqueFileName, { create: true })
      const writable = await fileHandle.createWritable()
      await writable.write(file)
      await writable.close()
      
      // è¿”å›ç›¸å¯¹è·¯å¾„
      return `${this.MEDIA_FOLDER}/${subFolder}/${uniqueFileName}`
    } catch (error) {
      console.error('ä¿å­˜åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®å¤±è´¥:', error)
      throw new Error(`ä¿å­˜åª’ä½“æ–‡ä»¶å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * ç”Ÿæˆåª’ä½“å…ƒæ•°æ®
   * @param file åª’ä½“æ–‡ä»¶
   * @param clip WebAV Clipå¯¹è±¡
   * @param mediaType åª’ä½“ç±»å‹
   * @returns åª’ä½“å…ƒæ•°æ®
   */
  async generateMediaMetadata(
    file: File,
    clip: any,
    mediaType: MediaType,
  ): Promise<UnifiedMediaMetadata> {
    try {
      // è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œ
      const checksum = await this.calculateChecksum(file)
      
      // ç­‰å¾…clipå‡†å¤‡å®Œæˆ
      const meta = await clip.ready
      
      // æ„å»ºå…ƒæ•°æ®
      const metadata: UnifiedMediaMetadata = {
        id: Date.now().toString() + Math.random().toString(36).substring(2, 11),
        originalFileName: file.name,
        fileSize: file.size,
        mimeType: file.type,
        checksum,
        importedAt: new Date().toISOString(),
      }
      
      // æ ¹æ®åª’ä½“ç±»å‹æ·»åŠ ç‰¹å®šå…ƒæ•°æ®
      if (mediaType === 'video' || mediaType === 'audio') {
        metadata.duration = meta.duration
      }
      
      if (mediaType === 'video' || mediaType === 'image') {
        metadata.width = meta.width
        metadata.height = meta.height
      }
      
      return metadata
    } catch (error) {
      console.error('ç”Ÿæˆåª’ä½“å…ƒæ•°æ®å¤±è´¥:', error)
      throw new Error(`ç”Ÿæˆåª’ä½“å…ƒæ•°æ®å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * ä¿å­˜åª’ä½“å…ƒæ•°æ®æ–‡ä»¶
   * @param projectId é¡¹ç›®ID
   * @param storedPath å­˜å‚¨è·¯å¾„
   * @param metadata åª’ä½“å…ƒæ•°æ®
   */
  async saveMediaMetadata(
    projectId: string,
    storedPath: string,
    metadata: UnifiedMediaMetadata,
  ): Promise<void> {
    try {
      // è·å–é¡¹ç›®ç›®å½•
      const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      
      // æ„å»ºå…ƒæ•°æ®æ–‡ä»¶è·¯å¾„
      const metaFilePath = `${storedPath}.meta`
      const pathParts = metaFilePath.split('/')
      const fileName = pathParts.pop()!
      const dirPath = pathParts.join('/')
      
      // ç¡®ä¿ç›®å½•å­˜åœ¨
      let currentHandle = projectHandle
      for (const part of dirPath.split('/')) {
        if (part) {
          currentHandle = await this.ensureDirectoryExists(currentHandle, part)
        }
      }
      
      // ä¿å­˜å…ƒæ•°æ®æ–‡ä»¶
      const fileHandle = await currentHandle.getFileHandle(fileName, { create: true })
      const writable = await fileHandle.createWritable()
      await writable.write(JSON.stringify(metadata, null, 2))
      await writable.close()
    } catch (error) {
      console.error('ä¿å­˜åª’ä½“å…ƒæ•°æ®å¤±è´¥:', error)
      throw new Error(`ä¿å­˜åª’ä½“å…ƒæ•°æ®å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œ
   * @param file åª’ä½“æ–‡ä»¶
   * @returns æ ¡éªŒå’Œå­—ç¬¦ä¸²
   */
  async calculateChecksum(file: File): Promise<string> {
    try {
      const buffer = await file.arrayBuffer()
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)
      const hashArray = Array.from(new Uint8Array(hashBuffer))
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
    } catch (error) {
      console.error('è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œå¤±è´¥:', error)
      throw new Error(`è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œå¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
   * @param projectId é¡¹ç›®ID
   * @param storedPath å­˜å‚¨è·¯å¾„
   * @param expectedChecksum é¢„æœŸæ ¡éªŒå’Œ
   * @returns æ˜¯å¦éªŒè¯é€šè¿‡
   */
  async verifyMediaIntegrity(
    projectId: string,
    storedPath: string,
    expectedChecksum: string,
  ): Promise<boolean> {
    try {
      const file = await this.loadMediaFromProject(projectId, storedPath)
      const actualChecksum = await this.calculateChecksum(file)
      return actualChecksum === expectedChecksum
    } catch (error) {
      console.error('éªŒè¯åª’ä½“æ–‡ä»¶å®Œæ•´æ€§å¤±è´¥:', error)
      return false
    }
  }
  
  /**
   * ä»é¡¹ç›®ç›®å½•åŠ è½½åª’ä½“æ–‡ä»¶
   * @param projectId é¡¹ç›®ID
   * @param storedPath å­˜å‚¨è·¯å¾„
   * @returns åª’ä½“æ–‡ä»¶
   */
  async loadMediaFromProject(projectId: string, storedPath: string): Promise<File> {
    try {
      // è·å–é¡¹ç›®ç›®å½•
      const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      
      // è·å–æ–‡ä»¶å¥æŸ„
      const pathParts = storedPath.split('/')
      let currentHandle = projectHandle
      
      for (const part of pathParts) {
        if (part) {
          currentHandle = await currentHandle.getDirectoryHandle(part)
        }
      }
      
      // è·å–æ–‡ä»¶
      const fileName = pathParts.pop()!
      const fileHandle = await currentHandle.getFileHandle(fileName)
      const file = await fileHandle.getFile()
      
      return file
    } catch (error) {
      console.error('ä»é¡¹ç›®åŠ è½½åª’ä½“æ–‡ä»¶å¤±è´¥:', error)
      throw new Error(`åŠ è½½åª’ä½“æ–‡ä»¶å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * ç¡®ä¿ç›®å½•å­˜åœ¨
   * @param parentHandle çˆ¶ç›®å½•å¥æŸ„
   * @param dirName ç›®å½•å
   * @returns ç›®å½•å¥æŸ„
   */
  private async ensureDirectoryExists(parentHandle: FileSystemDirectoryHandle, dirName: string): Promise<FileSystemDirectoryHandle> {
    try {
      return await parentHandle.getDirectoryHandle(dirName)
    } catch (error) {
      if ((error as DOMException).name === 'NotFoundError') {
        return await parentHandle.getDirectoryHandle(dirName, { create: true })
      }
      throw error
    }
  }
  
  /**
   * è·å–æ–‡ä»¶æ‰©å±•å
   * @param fileName æ–‡ä»¶å
   * @returns æ–‡ä»¶æ‰©å±•å
   */
  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.')
    return lastDotIndex !== -1 ? fileName.substring(lastDotIndex) : ''
  }
}
```

#### 2.2 æ‰©å±•é¡¹ç›®é…ç½®ç»“æ„

åœ¨ `UnifiedProjectConfig` ä¸­æ·»åŠ åª’ä½“å¼•ç”¨å­—æ®µï¼š

```typescript
// frontend/src/unified/project/types.ts
export interface UnifiedProjectConfig {
  // åŸºæœ¬ä¿¡æ¯å­—æ®µ
  id: string
  name: string
  description?: string
  createdAt: string
  updatedAt: string
  
  // é¡¹ç›®è®¾ç½®å­—æ®µ
  settings: {
    videoWidth: number
    videoHeight: number
    frameRate: number
    duration: number
    [key: string]: any
  }
  
  // æ—¶é—´è½´æ•°æ®
  timeline: {
    tracks: UnifiedTrackData[]
    duration: number
  }
  
  // åª’ä½“å¼•ç”¨æ˜ å°„
  mediaReferences: {
    [mediaId: string]: UnifiedMediaReference
  }
  
  // å…¶ä»–é…ç½®å­—æ®µ
  [key: string]: any
}

export interface UnifiedMediaReference {
  id: string                    // åª’ä½“ID
  originalFileName: string      // åŸå§‹æ–‡ä»¶å
  storedPath: string           // å­˜å‚¨è·¯å¾„
  mediaType: MediaType         // åª’ä½“ç±»å‹
  fileSize: number             // æ–‡ä»¶å¤§å°
  mimeType: string             // MIMEç±»å‹
  checksum: string             // æ–‡ä»¶æ ¡éªŒå’Œ
  metadata?: UnifiedMediaMetadata // åª’ä½“å…ƒæ•°æ®
  status?: 'ready' | 'error'   // çŠ¶æ€
  errorType?: string           // é”™è¯¯ç±»å‹
  errorMessage?: string        // é”™è¯¯ä¿¡æ¯
  errorTimestamp?: string      // é”™è¯¯æ—¶é—´æˆ³
}

export interface UnifiedMediaMetadata {
  id: string                    // å…ƒæ•°æ®ID
  originalFileName: string      // åŸå§‹æ–‡ä»¶å
  fileSize: number             // æ–‡ä»¶å¤§å°
  mimeType: string             // MIMEç±»å‹
  checksum: string             // æ–‡ä»¶æ ¡éªŒå’Œ
  importedAt: string           // å¯¼å…¥æ—¶é—´
  duration?: number            // æŒç»­æ—¶é—´ï¼ˆè§†é¢‘/éŸ³é¢‘ï¼‰
  width?: number               // å®½åº¦ï¼ˆè§†é¢‘/å›¾ç‰‡ï¼‰
  height?: number              // é«˜åº¦ï¼ˆè§†é¢‘/å›¾ç‰‡ï¼‰
  [key: string]: any           // å…¶ä»–å…ƒæ•°æ®
}

export type MediaType = 'video' | 'image' | 'audio' | 'text'
```

### 3. é¡¹ç›®ä¿å­˜æµç¨‹è®¾è®¡

#### 3.1 ä¿®æ”¹é¡¹ç›®ä¿å­˜æ–¹æ³•

ä¿®æ”¹ `UnifiedProjectModule.ts` ä¸­çš„ `saveCurrentProject` æ–¹æ³•ï¼š

```typescript
// frontend/src/unified/modules/UnifiedProjectModule.ts
import { unifiedMediaManager } from '../utils/UnifiedMediaManager'

// åœ¨æ¨¡å—ä¸­æ·»åŠ åª’ä½“ç®¡ç†å™¨å®ä¾‹
const unifiedMediaManager = UnifiedMediaManager.getInstance()

// ä¿®æ”¹ä¿å­˜é¡¹ç›®æ–¹æ³•
async function saveCurrentProject(): Promise<void> {
  try {
    isSaving.value = true
    console.log(`ğŸ’¾ ä¿å­˜é¡¹ç›®: ${configModule.projectName.value}`)
    configModule.projectUpdatedAt.value = new Date().toISOString()
    
    // 1. ä¿å­˜æ‰€æœ‰åª’ä½“æ–‡ä»¶
    const mediaReferences: Record<string, UnifiedMediaReference> = {}
    for (const mediaItem of mediaModule?.mediaItems.value || []) {
      if (mediaItem.file) {
        try {
          // ä¿å­˜åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•
          const storedPath = await unifiedMediaManager.saveMediaToProject(
            mediaItem.file,
            configModule.projectId.value,
            mediaItem.mediaType
          )
          
          // ç”Ÿæˆå…ƒæ•°æ®
          const metadata = await unifiedMediaManager.generateMediaMetadata(
            mediaItem.file,
            mediaItem.webav,
            mediaItem.mediaType
          )
          
          // ä¿å­˜å…ƒæ•°æ®æ–‡ä»¶
          await unifiedMediaManager.saveMediaMetadata(
            configModule.projectId.value,
            storedPath,
            metadata
          )
          
          // åˆ›å»ºåª’ä½“å¼•ç”¨
          mediaReferences[mediaItem.id] = {
            id: mediaItem.id,
            originalFileName: mediaItem.name,
            storedPath,
            mediaType: mediaItem.mediaType,
            fileSize: mediaItem.file.size,
            mimeType: mediaItem.file.type,
            checksum: metadata.checksum,
            metadata,
            status: 'ready'
          }
          
          console.log(`âœ… åª’ä½“æ–‡ä»¶ä¿å­˜æˆåŠŸ: ${mediaItem.name}`)
        } catch (error) {
          console.error(`ä¿å­˜åª’ä½“æ–‡ä»¶å¤±è´¥: ${mediaItem.name}`, error)
          
          // åˆ›å»ºé”™è¯¯çŠ¶æ€çš„åª’ä½“å¼•ç”¨
          mediaReferences[mediaItem.id] = {
            id: mediaItem.id,
            originalFileName: mediaItem.name,
            storedPath: '',
            mediaType: mediaItem.mediaType,
            fileSize: mediaItem.file.size,
            mimeType: mediaItem.file.type,
            checksum: '',
            status: 'error',
            errorType: 'save_error',
            errorMessage: error instanceof Error ? error.message : String(error),
            errorTimestamp: new Date().toISOString()
          }
        }
      }
    }
    
    // 2. å¤„ç†æ—¶é—´è½´æ•°æ®
    const timelineData = {
      tracks: timelineModule?.tracks.value || [],
      duration: timelineModule?.duration.value || 0
    }
    
    // 3. æ„å»ºæ›´æ–°çš„é¡¹ç›®é…ç½®
    const updatedProject: UnifiedProjectConfig = {
      id: configModule.projectId.value,
      name: configModule.projectName.value,
      description: configModule.projectDescription.value,
      createdAt: configModule.projectCreatedAt.value,
      updatedAt: configModule.projectUpdatedAt.value,
      settings: configModule.projectSettings.value,
      timeline: timelineData,
      mediaReferences,
    }
    
    // 4. è°ƒç”¨å®é™…çš„ä¿å­˜é€»è¾‘
    await unifiedProjectManager.saveProject(updatedProject)
    
    console.log(`âœ… é¡¹ç›®ä¿å­˜æˆåŠŸ: ${configModule.projectName.value}`)
  } catch (error) {
    console.error('ä¿å­˜é¡¹ç›®å¤±è´¥:', error)
    throw error
  } finally {
    isSaving.value = false
  }
}
```

#### 3.2 ä¿®æ”¹é¡¹ç›®åŠ è½½æ–¹æ³•

ä¿®æ”¹ `UnifiedProjectManager.ts` ä¸­çš„ `loadProjectContent` æ–¹æ³•ï¼š

```typescript
// frontend/src/unified/managers/UnifiedProjectManager.ts
import { unifiedMediaManager } from '../utils/UnifiedMediaManager'

// åœ¨ç®¡ç†å™¨ä¸­æ·»åŠ åª’ä½“ç®¡ç†å™¨å®ä¾‹
const unifiedMediaManager = UnifiedMediaManager.getInstance()

// ä¿®æ”¹åŠ è½½é¡¹ç›®å†…å®¹æ–¹æ³•
async loadProjectContent(
  projectId: string,
  options: UnifiedLoadProjectOptions = {},
): Promise<UnifiedProjectLoadResult | null> {
  const { loadMedia = true, loadTimeline = true, onProgress } = options
  
  try {
    // 1. åŠ è½½é¡¹ç›®é…ç½®
    onProgress?.('åŠ è½½é¡¹ç›®é…ç½®...', 10)
    const projectConfig = await this.loadProjectJson(projectId)
    
    // 2. åŠ è½½åª’ä½“æ–‡ä»¶
    let mediaItems: UnifiedMediaItemData[] = []
    if (loadMedia && projectConfig.mediaReferences) {
      onProgress?.('åŠ è½½åª’ä½“æ–‡ä»¶...', 30)
      
      const mediaEntries = Object.entries(projectConfig.mediaReferences)
      for (const [mediaId, reference] of mediaEntries) {
        try {
          onProgress?.(`åŠ è½½åª’ä½“: ${reference.originalFileName}`, 30 + (mediaEntries.indexOf([mediaId, reference]) / mediaEntries.length) * 30)
          
          // å¦‚æœåª’ä½“æ–‡ä»¶çŠ¶æ€ä¸ºé”™è¯¯ï¼Œç›´æ¥åˆ›å»ºé”™è¯¯çŠ¶æ€çš„åª’ä½“é¡¹ç›®
          if (reference.status === 'error') {
            const errorItem: UnifiedMediaItemData = {
              id: mediaId,
              name: reference.originalFileName,
              mediaType: reference.mediaType,
              status: 'error',
              errorMessage: reference.errorMessage || 'æœªçŸ¥é”™è¯¯',
            }
            mediaItems.push(errorItem)
            continue
          }
          
          // åŠ è½½åª’ä½“æ–‡ä»¶
          const file = await unifiedMediaManager.loadMediaFromProject(
            projectId,
            reference.storedPath
          )
          
          // éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
          const isValid = await unifiedMediaManager.verifyMediaIntegrity(
            projectId,
            reference.storedPath,
            reference.checksum
          )
          
          if (!isValid) {
            throw new Error(`æ–‡ä»¶å®Œæ•´æ€§éªŒè¯å¤±è´¥: ${reference.originalFileName}`)
          }
          
          // é‡å»ºWebAV Clipå¯¹è±¡
          const clip = await this.rebuildWebAVClip(file, reference.mediaType)
          
          // åˆ›å»ºåª’ä½“é¡¹ç›®
          const mediaItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            file,
            url: URL.createObjectURL(file),
            mediaType: reference.mediaType,
            webav: clip,
            status: 'ready',
            metadata: reference.metadata,
          }
          
          mediaItems.push(mediaItem)
          console.log(`âœ… åª’ä½“æ–‡ä»¶åŠ è½½æˆåŠŸ: ${reference.originalFileName}`)
        } catch (error) {
          console.error(`åŠ è½½åª’ä½“å¤±è´¥: ${reference.originalFileName}`, error)
          
          // åˆ›å»ºé”™è¯¯çŠ¶æ€çš„åª’ä½“é¡¹ç›®
          const errorItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            mediaType: reference.mediaType,
            status: 'error',
            errorMessage: error instanceof Error ? error.message : String(error),
          }
          mediaItems.push(errorItem)
        }
      }
    }
    
    // 3. åŠ è½½æ—¶é—´è½´æ•°æ®
    let timelineData: UnifiedTimelineData | null = null
    if (loadTimeline && projectConfig.timeline) {
      onProgress?.('åŠ è½½æ—¶é—´è½´æ•°æ®...', 70)
      timelineData = {
        tracks: projectConfig.timeline.tracks,
        duration: projectConfig.timeline.duration,
      }
    }
    
    // 4. è¿”å›åŠ è½½ç»“æœ
    onProgress?.('å®ŒæˆåŠ è½½', 100)
    return {
      projectConfig,
      mediaItems,
      timelineData,
    }
  } catch (error) {
    console.error(`åŠ è½½é¡¹ç›®å†…å®¹å¤±è´¥: ${projectId}`, error)
    throw error
  }
}

/**
 * é‡å»ºWebAV Clipå¯¹è±¡
 * @param file åª’ä½“æ–‡ä»¶
 * @param mediaType åª’ä½“ç±»å‹
 * @returns WebAV Clipå¯¹è±¡
 */
private async rebuildWebAVClip(file: File, mediaType: MediaType): Promise<any> {
  try {
    switch (mediaType) {
      case 'video':
        return await MP4Clip.fromFile(file)
      case 'image':
        return await ImgClip.fromFile(file)
      case 'audio':
        return await AudioClip.fromFile(file)
      default:
        throw new Error(`ä¸æ”¯æŒçš„åª’ä½“ç±»å‹: ${mediaType}`)
    }
  } catch (error) {
    console.error('é‡å»ºWebAV Clipå¯¹è±¡å¤±è´¥:', error)
    throw new Error(`é‡å»ºWebAV Clipå¯¹è±¡å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`)
  }
}
```

### 4. å®ç°æ­¥éª¤

#### 4.1 ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„æ­å»º

1. **åˆ›å»º UnifiedMediaManager ç±»**
   - å®ç°åŸºæœ¬çš„æ–‡ä»¶ä¿å­˜å’ŒåŠ è½½åŠŸèƒ½
   - å®ç°å…ƒæ•°æ®ç®¡ç†åŠŸèƒ½
   - å®ç°æ–‡ä»¶å®Œæ•´æ€§éªŒè¯åŠŸèƒ½

2. **æ‰©å±•é¡¹ç›®é…ç½®ç»“æ„**
   - åœ¨ `UnifiedProjectConfig` ä¸­æ·»åŠ åª’ä½“å¼•ç”¨å­—æ®µ
   - å®šä¹‰ `UnifiedMediaReference` å’Œ `UnifiedMediaMetadata` æ¥å£

3. **ä¿®æ”¹é¡¹ç›®ä¿å­˜æµç¨‹**
   - åœ¨ä¿å­˜é¡¹ç›®æ—¶ä¿å­˜åª’ä½“æ–‡ä»¶
   - å»ºç«‹åª’ä½“å¼•ç”¨å…³ç³»
   - ä¿å­˜åª’ä½“å…ƒæ•°æ®

#### 4.2 ç¬¬äºŒé˜¶æ®µï¼šå®Œå–„åŠŸèƒ½

1. **ä¿®æ”¹é¡¹ç›®åŠ è½½æµç¨‹**
   - æ ¹æ®åª’ä½“å¼•ç”¨åŠ è½½åª’ä½“æ–‡ä»¶
   - éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
   - é‡å»ºWebAV Clipå¯¹è±¡

2. **é”™è¯¯å¤„ç†æœºåˆ¶**
   - å®Œå–„åª’ä½“ä¿å­˜å’ŒåŠ è½½çš„é”™è¯¯å¤„ç†
   - æä¾›é”™è¯¯çŠ¶æ€ç®¡ç†
   - å®ç°é”™è¯¯æ¢å¤æœºåˆ¶

3. **æ€§èƒ½ä¼˜åŒ–**
   - å®ç°åª’ä½“æ–‡ä»¶çš„æ‰¹é‡ä¿å­˜å’ŒåŠ è½½
   - ä¼˜åŒ–å¤§æ–‡ä»¶çš„å¤„ç†æ€§èƒ½
   - å®ç°è¿›åº¦åé¦ˆæœºåˆ¶

#### 4.3 ç¬¬ä¸‰é˜¶æ®µï¼šæµ‹è¯•å’Œä¼˜åŒ–

1. **å•å…ƒæµ‹è¯•**
   - æµ‹è¯•åª’ä½“ä¿å­˜å’ŒåŠ è½½åŠŸèƒ½
   - æµ‹è¯•æ–‡ä»¶å®Œæ•´æ€§éªŒè¯
   - æµ‹è¯•é”™è¯¯å¤„ç†æœºåˆ¶

2. **é›†æˆæµ‹è¯•**
   - æµ‹è¯•å®Œæ•´çš„é¡¹ç›®ä¿å­˜å’ŒåŠ è½½æµç¨‹
   - æµ‹è¯•ä¸åŒç±»å‹åª’ä½“æ–‡ä»¶çš„å¤„ç†
   - æµ‹è¯•å¤§æ–‡ä»¶çš„å¤„ç†æ€§èƒ½

3. **æ€§èƒ½ä¼˜åŒ–**
   - æ ¹æ®æµ‹è¯•ç»“æœè¿›è¡Œæ€§èƒ½ä¼˜åŒ–
   - ä¼˜åŒ–å†…å­˜ä½¿ç”¨
   - ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ

### 5. é¢„æœŸæ•ˆæœ

é€šè¿‡å®æ–½æœ¬æ–¹æ¡ˆï¼Œæ–°æ¶æ„å°†å…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š

1. **å®Œæ•´çš„æºæ–‡ä»¶ä¿å­˜**ï¼šç¡®ä¿é¡¹ç›®ç´ æçš„æºæ–‡ä»¶è¢«å®Œæ•´ä¿å­˜åˆ°é¡¹ç›®ç›®å½•ä¸­
2. **åª’ä½“å¼•ç”¨æœºåˆ¶**ï¼šå»ºç«‹åª’ä½“æ–‡ä»¶ä¸é¡¹ç›®ä¹‹é—´çš„å¼•ç”¨å…³ç³»ï¼Œç¡®ä¿é¡¹ç›®å¯ç§»æ¤æ€§
3. **æ–‡ä»¶å®Œæ•´æ€§éªŒè¯**ï¼šé€šè¿‡æ ¡éªŒå’ŒéªŒè¯ç¡®ä¿æ–‡ä»¶å®Œæ•´æ€§ï¼Œé˜²æ­¢æ•°æ®æŸå
4. **å®Œå–„çš„å…ƒæ•°æ®ç®¡ç†**ï¼šä¿å­˜åª’ä½“æ–‡ä»¶çš„è¯¦ç»†å…ƒæ•°æ®ï¼Œä¾¿äºåç»­å¤„ç†å’Œç®¡ç†
5. **é”™è¯¯å¤„ç†æœºåˆ¶**ï¼šæä¾›å®Œå–„çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€ç®¡ç†ï¼Œæé«˜ç³»ç»Ÿç¨³å®šæ€§
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡æ‰¹é‡å¤„ç†å’Œè¿›åº¦åé¦ˆï¼Œæé«˜ç”¨æˆ·ä½“éªŒ

### 6. é£é™©è¯„ä¼°ä¸åº”å¯¹

#### 6.1 æŠ€æœ¯é£é™©

1. **æ–‡ä»¶ç³»ç»ŸAPIå…¼å®¹æ€§**
   - é£é™©ï¼šä¸åŒæµè§ˆå™¨çš„æ–‡ä»¶ç³»ç»ŸAPIå®ç°å¯èƒ½å­˜åœ¨å·®å¼‚
   - åº”å¯¹ï¼šè¿›è¡Œå……åˆ†çš„æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•ï¼Œæä¾›é™çº§æ–¹æ¡ˆ

2. **å¤§æ–‡ä»¶å¤„ç†æ€§èƒ½**
   - é£é™©ï¼šå¤§åª’ä½“æ–‡ä»¶çš„ä¿å­˜å’ŒåŠ è½½å¯èƒ½å½±å“æ€§èƒ½
   - åº”å¯¹ï¼šå®ç°åˆ†å—å¤„ç†å’Œè¿›åº¦åé¦ˆï¼Œä¼˜åŒ–å†…å­˜ä½¿ç”¨

#### 6.2 ç”¨æˆ·ä½“éªŒé£é™©

1. **ä¿å­˜æ—¶é—´è¿‡é•¿**
   - é£é™©ï¼šå¤§é‡åª’ä½“æ–‡ä»¶å¯èƒ½å¯¼è‡´ä¿å­˜æ—¶é—´è¿‡é•¿
   - åº”å¯¹ï¼šå®ç°åå°ä¿å­˜ã€è¿›åº¦åé¦ˆå’Œå–æ¶ˆåŠŸèƒ½

2. **å­˜å‚¨ç©ºé—´ä¸è¶³**
   - é£é™©ï¼šç”¨æˆ·è®¾å¤‡å­˜å‚¨ç©ºé—´ä¸è¶³å¯èƒ½å¯¼è‡´ä¿å­˜å¤±è´¥
   - åº”å¯¹ï¼šå®ç°å­˜å‚¨ç©ºé—´æ£€æŸ¥å’Œæ¸…ç†å»ºè®®

### 7. æ€»ç»“

æ–°æ¶æ„çš„é¡¹ç›®ä¿å­˜æ–¹æ¡ˆé€šè¿‡å‚è€ƒæ—§æ¶æ„çš„æˆç†Ÿå®ç°ï¼Œç»“åˆæ–°æ¶æ„çš„ç‰¹ç‚¹è¿›è¡Œäº†ä¼˜åŒ–å’Œæ”¹è¿›ã€‚æœ¬æ–¹æ¡ˆå°†ç¡®ä¿é¡¹ç›®ç´ æçš„å®Œæ•´æ€§å’Œå¯ç§»æ¤æ€§ï¼Œæä¾›å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œå¹¶é€šè¿‡æ€§èƒ½ä¼˜åŒ–æé«˜ç”¨æˆ·ä½“éªŒã€‚

å®æ–½æœ¬æ–¹æ¡ˆå°†ä½¿æ–°æ¶æ„å…·å¤‡ä¸æ—§æ¶æ„ç›¸å½“çš„æºæ–‡ä»¶ä¿å­˜èƒ½åŠ›ï¼ŒåŒæ—¶å…·å¤‡æ›´å¥½çš„å¯ç»´æŠ¤æ€§å’Œæ‰©å±•æ€§ï¼Œä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•å¥ å®šåŸºç¡€ã€‚