# 新架构项目保存方案

## 概述

本文档详细描述了新架构的项目保存方案，旨在解决当前新架构在源文件保存方面的不足，确保项目素材的完整性和可移植性。本方案参考了旧架构的成熟实现，并结合新架构的特点进行了优化和改进。

## 当前问题分析

### 1. 源文件保存缺失

新架构目前只保存项目配置信息，没有实际保存源文件到项目目录：

```typescript
// 在 UnifiedProjectModule.ts 的 saveCurrentProject 方法中
const updatedProject: UnifiedProjectConfig = {
  // ... 其他配置
  
  // 媒体数据 - 为空对象
  media: {},
}
```

### 2. 媒体数据处理不当

虽然处理了时间轴项目中的媒体数据，但只是简单地去除了运行时对象，没有建立完整的保存机制：

```typescript
// mediaItems 包含 webav 运行时对象，需要清理
mediaItems: (mediaModule?.mediaItems.value || []).map(item => {
  // 创建媒体项目的可持久化副本，去掉运行时的 webav 对象
  const { webav, ...persistableItem } = item
  return persistableItem
}),
```

### 3. 缺少媒体引用管理

新架构没有建立媒体引用机制，无法追踪媒体文件的存储位置和状态：
- 缺少媒体文件到项目目录的保存逻辑
- 缺少文件完整性验证机制
- 缺少媒体元数据管理

## 解决方案设计

### 1. 整体架构设计

新架构的项目保存方案采用分层设计，主要包括以下几个层次：

1. **媒体管理层**：负责媒体文件的保存、加载和验证
2. **项目配置层**：负责项目配置的保存和加载
3. **引用管理层**：负责媒体引用的建立和维护
4. **元数据管理层**：负责媒体元数据的保存和加载

### 2. 核心组件设计

#### 2.1 UnifiedMediaManager 类

创建统一的媒体管理器，负责媒体文件的保存、加载和验证：

```typescript
// frontend/src/unified/utils/UnifiedMediaManager.ts
export class UnifiedMediaManager {
  private static instance: UnifiedMediaManager
  
  // 媒体文件夹常量
  private readonly MEDIA_FOLDER = 'media'
  private readonly VIDEOS_FOLDER = 'videos'
  private readonly IMAGES_FOLDER = 'images'
  private readonly AUDIO_FOLDER = 'audio'
  
  // 单例模式
  static getInstance(): UnifiedMediaManager {
    if (!UnifiedMediaManager.instance) {
      UnifiedMediaManager.instance = new UnifiedMediaManager()
    }
    return UnifiedMediaManager.instance
  }
  
  /**
   * 保存媒体文件到项目目录
   * @param file 媒体文件
   * @param projectId 项目ID
   * @param mediaType 媒体类型
   * @returns 存储路径
   */
  async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string> {
    try {
      // 获取项目目录
      const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      
      // 确保media目录存在
      const mediaHandle = await this.ensureDirectoryExists(projectHandle, this.MEDIA_FOLDER)
      
      // 根据媒体类型确定子目录
      let subFolder: string
      switch (mediaType) {
        case 'video': subFolder = this.VIDEOS_FOLDER; break
        case 'image': subFolder = this.IMAGES_FOLDER; break
        case 'audio': subFolder = this.AUDIO_FOLDER; break
        default: throw new Error(`不支持的媒体类型: ${mediaType}`)
      }
      
      // 确保子目录存在
      const subHandle = await this.ensureDirectoryExists(mediaHandle, subFolder)
      
      // 生成唯一文件名（避免冲突）
      const timestamp = Date.now()
      const randomSuffix = Math.random().toString(36).substring(2, 8)
      const fileExtension = this.getFileExtension(file.name)
      const uniqueFileName = `${timestamp}_${randomSuffix}${fileExtension}`
      
      // 保存文件
      const fileHandle = await subHandle.getFileHandle(uniqueFileName, { create: true })
      const writable = await fileHandle.createWritable()
      await writable.write(file)
      await writable.close()
      
      // 返回相对路径
      return `${this.MEDIA_FOLDER}/${subFolder}/${uniqueFileName}`
    } catch (error) {
      console.error('保存媒体文件到项目失败:', error)
      throw new Error(`保存媒体文件失败: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * 生成媒体元数据
   * @param file 媒体文件
   * @param clip WebAV Clip对象
   * @param mediaType 媒体类型
   * @returns 媒体元数据
   */
  async generateMediaMetadata(
    file: File,
    clip: any,
    mediaType: MediaType,
  ): Promise<UnifiedMediaMetadata> {
    try {
      // 计算文件校验和
      const checksum = await this.calculateChecksum(file)
      
      // 等待clip准备完成
      const meta = await clip.ready
      
      // 构建元数据
      const metadata: UnifiedMediaMetadata = {
        id: Date.now().toString() + Math.random().toString(36).substring(2, 11),
        originalFileName: file.name,
        fileSize: file.size,
        mimeType: file.type,
        checksum,
        importedAt: new Date().toISOString(),
      }
      
      // 根据媒体类型添加特定元数据
      if (mediaType === 'video' || mediaType === 'audio') {
        metadata.duration = meta.duration
      }
      
      if (mediaType === 'video' || mediaType === 'image') {
        metadata.width = meta.width
        metadata.height = meta.height
      }
      
      return metadata
    } catch (error) {
      console.error('生成媒体元数据失败:', error)
      throw new Error(`生成媒体元数据失败: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * 保存媒体元数据文件
   * @param projectId 项目ID
   * @param storedPath 存储路径
   * @param metadata 媒体元数据
   */
  async saveMediaMetadata(
    projectId: string,
    storedPath: string,
    metadata: UnifiedMediaMetadata,
  ): Promise<void> {
    try {
      // 获取项目目录
      const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      
      // 构建元数据文件路径
      const metaFilePath = `${storedPath}.meta`
      const pathParts = metaFilePath.split('/')
      const fileName = pathParts.pop()!
      const dirPath = pathParts.join('/')
      
      // 确保目录存在
      let currentHandle = projectHandle
      for (const part of dirPath.split('/')) {
        if (part) {
          currentHandle = await this.ensureDirectoryExists(currentHandle, part)
        }
      }
      
      // 保存元数据文件
      const fileHandle = await currentHandle.getFileHandle(fileName, { create: true })
      const writable = await fileHandle.createWritable()
      await writable.write(JSON.stringify(metadata, null, 2))
      await writable.close()
    } catch (error) {
      console.error('保存媒体元数据失败:', error)
      throw new Error(`保存媒体元数据失败: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * 计算文件校验和
   * @param file 媒体文件
   * @returns 校验和字符串
   */
  async calculateChecksum(file: File): Promise<string> {
    try {
      const buffer = await file.arrayBuffer()
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)
      const hashArray = Array.from(new Uint8Array(hashBuffer))
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
    } catch (error) {
      console.error('计算文件校验和失败:', error)
      throw new Error(`计算文件校验和失败: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * 验证文件完整性
   * @param projectId 项目ID
   * @param storedPath 存储路径
   * @param expectedChecksum 预期校验和
   * @returns 是否验证通过
   */
  async verifyMediaIntegrity(
    projectId: string,
    storedPath: string,
    expectedChecksum: string,
  ): Promise<boolean> {
    try {
      const file = await this.loadMediaFromProject(projectId, storedPath)
      const actualChecksum = await this.calculateChecksum(file)
      return actualChecksum === expectedChecksum
    } catch (error) {
      console.error('验证媒体文件完整性失败:', error)
      return false
    }
  }
  
  /**
   * 从项目目录加载媒体文件
   * @param projectId 项目ID
   * @param storedPath 存储路径
   * @returns 媒体文件
   */
  async loadMediaFromProject(projectId: string, storedPath: string): Promise<File> {
    try {
      // 获取项目目录
      const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      
      // 获取文件句柄
      const pathParts = storedPath.split('/')
      let currentHandle = projectHandle
      
      for (const part of pathParts) {
        if (part) {
          currentHandle = await currentHandle.getDirectoryHandle(part)
        }
      }
      
      // 获取文件
      const fileName = pathParts.pop()!
      const fileHandle = await currentHandle.getFileHandle(fileName)
      const file = await fileHandle.getFile()
      
      return file
    } catch (error) {
      console.error('从项目加载媒体文件失败:', error)
      throw new Error(`加载媒体文件失败: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * 确保目录存在
   * @param parentHandle 父目录句柄
   * @param dirName 目录名
   * @returns 目录句柄
   */
  private async ensureDirectoryExists(parentHandle: FileSystemDirectoryHandle, dirName: string): Promise<FileSystemDirectoryHandle> {
    try {
      return await parentHandle.getDirectoryHandle(dirName)
    } catch (error) {
      if ((error as DOMException).name === 'NotFoundError') {
        return await parentHandle.getDirectoryHandle(dirName, { create: true })
      }
      throw error
    }
  }
  
  /**
   * 获取文件扩展名
   * @param fileName 文件名
   * @returns 文件扩展名
   */
  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.')
    return lastDotIndex !== -1 ? fileName.substring(lastDotIndex) : ''
  }
}
```

#### 2.2 扩展项目配置结构

在 `UnifiedProjectConfig` 中添加媒体引用字段：

```typescript
// frontend/src/unified/project/types.ts
export interface UnifiedProjectConfig {
  // 基本信息字段
  id: string
  name: string
  description?: string
  createdAt: string
  updatedAt: string
  
  // 项目设置字段
  settings: {
    videoWidth: number
    videoHeight: number
    frameRate: number
    duration: number
    [key: string]: any
  }
  
  // 时间轴数据
  timeline: {
    tracks: UnifiedTrackData[]
    duration: number
  }
  
  // 媒体引用映射
  mediaReferences: {
    [mediaId: string]: UnifiedMediaReference
  }
  
  // 其他配置字段
  [key: string]: any
}

export interface UnifiedMediaReference {
  id: string                    // 媒体ID
  originalFileName: string      // 原始文件名
  storedPath: string           // 存储路径
  mediaType: MediaType         // 媒体类型
  fileSize: number             // 文件大小
  mimeType: string             // MIME类型
  checksum: string             // 文件校验和
  metadata?: UnifiedMediaMetadata // 媒体元数据
  status?: 'ready' | 'error'   // 状态
  errorType?: string           // 错误类型
  errorMessage?: string        // 错误信息
  errorTimestamp?: string      // 错误时间戳
}

export interface UnifiedMediaMetadata {
  id: string                    // 元数据ID
  originalFileName: string      // 原始文件名
  fileSize: number             // 文件大小
  mimeType: string             // MIME类型
  checksum: string             // 文件校验和
  importedAt: string           // 导入时间
  duration?: number            // 持续时间（视频/音频）
  width?: number               // 宽度（视频/图片）
  height?: number              // 高度（视频/图片）
  [key: string]: any           // 其他元数据
}

export type MediaType = 'video' | 'image' | 'audio' | 'text'
```

### 3. 项目保存流程设计

#### 3.1 修改项目保存方法

修改 `UnifiedProjectModule.ts` 中的 `saveCurrentProject` 方法：

```typescript
// frontend/src/unified/modules/UnifiedProjectModule.ts
import { unifiedMediaManager } from '../utils/UnifiedMediaManager'

// 在模块中添加媒体管理器实例
const unifiedMediaManager = UnifiedMediaManager.getInstance()

// 修改保存项目方法
async function saveCurrentProject(): Promise<void> {
  try {
    isSaving.value = true
    console.log(`💾 保存项目: ${configModule.projectName.value}`)
    configModule.projectUpdatedAt.value = new Date().toISOString()
    
    // 1. 保存所有媒体文件
    const mediaReferences: Record<string, UnifiedMediaReference> = {}
    for (const mediaItem of mediaModule?.mediaItems.value || []) {
      if (mediaItem.file) {
        try {
          // 保存媒体文件到项目目录
          const storedPath = await unifiedMediaManager.saveMediaToProject(
            mediaItem.file,
            configModule.projectId.value,
            mediaItem.mediaType
          )
          
          // 生成元数据
          const metadata = await unifiedMediaManager.generateMediaMetadata(
            mediaItem.file,
            mediaItem.webav,
            mediaItem.mediaType
          )
          
          // 保存元数据文件
          await unifiedMediaManager.saveMediaMetadata(
            configModule.projectId.value,
            storedPath,
            metadata
          )
          
          // 创建媒体引用
          mediaReferences[mediaItem.id] = {
            id: mediaItem.id,
            originalFileName: mediaItem.name,
            storedPath,
            mediaType: mediaItem.mediaType,
            fileSize: mediaItem.file.size,
            mimeType: mediaItem.file.type,
            checksum: metadata.checksum,
            metadata,
            status: 'ready'
          }
          
          console.log(`✅ 媒体文件保存成功: ${mediaItem.name}`)
        } catch (error) {
          console.error(`保存媒体文件失败: ${mediaItem.name}`, error)
          
          // 创建错误状态的媒体引用
          mediaReferences[mediaItem.id] = {
            id: mediaItem.id,
            originalFileName: mediaItem.name,
            storedPath: '',
            mediaType: mediaItem.mediaType,
            fileSize: mediaItem.file.size,
            mimeType: mediaItem.file.type,
            checksum: '',
            status: 'error',
            errorType: 'save_error',
            errorMessage: error instanceof Error ? error.message : String(error),
            errorTimestamp: new Date().toISOString()
          }
        }
      }
    }
    
    // 2. 处理时间轴数据
    const timelineData = {
      tracks: timelineModule?.tracks.value || [],
      duration: timelineModule?.duration.value || 0
    }
    
    // 3. 构建更新的项目配置
    const updatedProject: UnifiedProjectConfig = {
      id: configModule.projectId.value,
      name: configModule.projectName.value,
      description: configModule.projectDescription.value,
      createdAt: configModule.projectCreatedAt.value,
      updatedAt: configModule.projectUpdatedAt.value,
      settings: configModule.projectSettings.value,
      timeline: timelineData,
      mediaReferences,
    }
    
    // 4. 调用实际的保存逻辑
    await unifiedProjectManager.saveProject(updatedProject)
    
    console.log(`✅ 项目保存成功: ${configModule.projectName.value}`)
  } catch (error) {
    console.error('保存项目失败:', error)
    throw error
  } finally {
    isSaving.value = false
  }
}
```

#### 3.2 修改项目加载方法

修改 `UnifiedProjectManager.ts` 中的 `loadProjectContent` 方法：

```typescript
// frontend/src/unified/managers/UnifiedProjectManager.ts
import { unifiedMediaManager } from '../utils/UnifiedMediaManager'

// 在管理器中添加媒体管理器实例
const unifiedMediaManager = UnifiedMediaManager.getInstance()

// 修改加载项目内容方法
async loadProjectContent(
  projectId: string,
  options: UnifiedLoadProjectOptions = {},
): Promise<UnifiedProjectLoadResult | null> {
  const { loadMedia = true, loadTimeline = true, onProgress } = options
  
  try {
    // 1. 加载项目配置
    onProgress?.('加载项目配置...', 10)
    const projectConfig = await this.loadProjectJson(projectId)
    
    // 2. 加载媒体文件
    let mediaItems: UnifiedMediaItemData[] = []
    if (loadMedia && projectConfig.mediaReferences) {
      onProgress?.('加载媒体文件...', 30)
      
      const mediaEntries = Object.entries(projectConfig.mediaReferences)
      for (const [mediaId, reference] of mediaEntries) {
        try {
          onProgress?.(`加载媒体: ${reference.originalFileName}`, 30 + (mediaEntries.indexOf([mediaId, reference]) / mediaEntries.length) * 30)
          
          // 如果媒体文件状态为错误，直接创建错误状态的媒体项目
          if (reference.status === 'error') {
            const errorItem: UnifiedMediaItemData = {
              id: mediaId,
              name: reference.originalFileName,
              mediaType: reference.mediaType,
              status: 'error',
              errorMessage: reference.errorMessage || '未知错误',
            }
            mediaItems.push(errorItem)
            continue
          }
          
          // 加载媒体文件
          const file = await unifiedMediaManager.loadMediaFromProject(
            projectId,
            reference.storedPath
          )
          
          // 验证文件完整性
          const isValid = await unifiedMediaManager.verifyMediaIntegrity(
            projectId,
            reference.storedPath,
            reference.checksum
          )
          
          if (!isValid) {
            throw new Error(`文件完整性验证失败: ${reference.originalFileName}`)
          }
          
          // 重建WebAV Clip对象
          const clip = await this.rebuildWebAVClip(file, reference.mediaType)
          
          // 创建媒体项目
          const mediaItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            file,
            url: URL.createObjectURL(file),
            mediaType: reference.mediaType,
            webav: clip,
            status: 'ready',
            metadata: reference.metadata,
          }
          
          mediaItems.push(mediaItem)
          console.log(`✅ 媒体文件加载成功: ${reference.originalFileName}`)
        } catch (error) {
          console.error(`加载媒体失败: ${reference.originalFileName}`, error)
          
          // 创建错误状态的媒体项目
          const errorItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            mediaType: reference.mediaType,
            status: 'error',
            errorMessage: error instanceof Error ? error.message : String(error),
          }
          mediaItems.push(errorItem)
        }
      }
    }
    
    // 3. 加载时间轴数据
    let timelineData: UnifiedTimelineData | null = null
    if (loadTimeline && projectConfig.timeline) {
      onProgress?.('加载时间轴数据...', 70)
      timelineData = {
        tracks: projectConfig.timeline.tracks,
        duration: projectConfig.timeline.duration,
      }
    }
    
    // 4. 返回加载结果
    onProgress?.('完成加载', 100)
    return {
      projectConfig,
      mediaItems,
      timelineData,
    }
  } catch (error) {
    console.error(`加载项目内容失败: ${projectId}`, error)
    throw error
  }
}

/**
 * 重建WebAV Clip对象
 * @param file 媒体文件
 * @param mediaType 媒体类型
 * @returns WebAV Clip对象
 */
private async rebuildWebAVClip(file: File, mediaType: MediaType): Promise<any> {
  try {
    switch (mediaType) {
      case 'video':
        return await MP4Clip.fromFile(file)
      case 'image':
        return await ImgClip.fromFile(file)
      case 'audio':
        return await AudioClip.fromFile(file)
      default:
        throw new Error(`不支持的媒体类型: ${mediaType}`)
    }
  } catch (error) {
    console.error('重建WebAV Clip对象失败:', error)
    throw new Error(`重建WebAV Clip对象失败: ${error instanceof Error ? error.message : String(error)}`)
  }
}
```

### 4. 实现步骤

#### 4.1 第一阶段：基础架构搭建

1. **创建 UnifiedMediaManager 类**
   - 实现基本的文件保存和加载功能
   - 实现元数据管理功能
   - 实现文件完整性验证功能

2. **扩展项目配置结构**
   - 在 `UnifiedProjectConfig` 中添加媒体引用字段
   - 定义 `UnifiedMediaReference` 和 `UnifiedMediaMetadata` 接口

3. **修改项目保存流程**
   - 在保存项目时保存媒体文件
   - 建立媒体引用关系
   - 保存媒体元数据

#### 4.2 第二阶段：完善功能

1. **修改项目加载流程**
   - 根据媒体引用加载媒体文件
   - 验证文件完整性
   - 重建WebAV Clip对象

2. **错误处理机制**
   - 完善媒体保存和加载的错误处理
   - 提供错误状态管理
   - 实现错误恢复机制

3. **性能优化**
   - 实现媒体文件的批量保存和加载
   - 优化大文件的处理性能
   - 实现进度反馈机制

#### 4.3 第三阶段：测试和优化

1. **单元测试**
   - 测试媒体保存和加载功能
   - 测试文件完整性验证
   - 测试错误处理机制

2. **集成测试**
   - 测试完整的项目保存和加载流程
   - 测试不同类型媒体文件的处理
   - 测试大文件的处理性能

3. **性能优化**
   - 根据测试结果进行性能优化
   - 优化内存使用
   - 优化用户体验

### 5. 预期效果

通过实施本方案，新架构将具备以下能力：

1. **完整的源文件保存**：确保项目素材的源文件被完整保存到项目目录中
2. **媒体引用机制**：建立媒体文件与项目之间的引用关系，确保项目可移植性
3. **文件完整性验证**：通过校验和验证确保文件完整性，防止数据损坏
4. **完善的元数据管理**：保存媒体文件的详细元数据，便于后续处理和管理
5. **错误处理机制**：提供完善的错误处理和状态管理，提高系统稳定性
6. **性能优化**：通过批量处理和进度反馈，提高用户体验

### 6. 风险评估与应对

#### 6.1 技术风险

1. **文件系统API兼容性**
   - 风险：不同浏览器的文件系统API实现可能存在差异
   - 应对：进行充分的浏览器兼容性测试，提供降级方案

2. **大文件处理性能**
   - 风险：大媒体文件的保存和加载可能影响性能
   - 应对：实现分块处理和进度反馈，优化内存使用

#### 6.2 用户体验风险

1. **保存时间过长**
   - 风险：大量媒体文件可能导致保存时间过长
   - 应对：实现后台保存、进度反馈和取消功能

2. **存储空间不足**
   - 风险：用户设备存储空间不足可能导致保存失败
   - 应对：实现存储空间检查和清理建议

### 7. 总结

新架构的项目保存方案通过参考旧架构的成熟实现，结合新架构的特点进行了优化和改进。本方案将确保项目素材的完整性和可移植性，提供完善的错误处理机制，并通过性能优化提高用户体验。

实施本方案将使新架构具备与旧架构相当的源文件保存能力，同时具备更好的可维护性和扩展性，为未来的功能扩展奠定基础。