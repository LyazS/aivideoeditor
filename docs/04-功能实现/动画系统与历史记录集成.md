# 动画系统与操作历史系统集成

## 📋 概述

本文档描述了如何将关键帧动画系统与操作历史系统完美集成，实现统一的撤销/重做功能，同时保持动画和非动画clip的操作一致性。

## 🎯 核心目标

### 主要目标
- **统一操作体验**：动画和非动画clip的属性修改体验一致
- **完整历史记录**：所有关键帧操作都支持撤销/重做
- **智能操作路由**：根据clip状态自动选择正确的操作方式
- **状态管理清晰**：明确的动画/非动画状态判断和转换

### 设计原则
1. **智能路由原则**：根据`animationConfig`状态自动选择操作方式
2. **统一接口原则**：属性面板使用统一的更新方法
3. **完整记录原则**：所有操作都通过Command模式记录
4. **状态一致原则**：确保UI显示与实际状态同步

## 🏗️ 架构设计

### 核心判断逻辑
```typescript
// 判断是否为有动画的clip
const hasAnimation = computed(() => {
  return selectedTimelineItem.value?.animationConfig !== null && 
         selectedTimelineItem.value?.animationConfig !== undefined
})
```

### 操作分类体系

#### 无动画clip操作
```typescript
UpdateTransformCommand // 已存在，直接修改TimelineItem属性
```

#### 有动画clip操作（新增）
```typescript
CreateKeyFrameCommand    // 创建关键帧
RemoveKeyFrameCommand    // 删除关键帧  
UpdateKeyFrameCommand    // 更新关键帧值
ClearAnimationCommand    // 清除所有动画
ToggleAnimationCommand   // 启用/禁用动画
```

### 智能路由系统

#### 核心路由方法
```typescript
const updatePropertySmart = async (property: AnimatableProperty, newValue: number) => {
  if (!selectedTimelineItem.value) return
  
  const oldValue = getCurrentPropertyValue(selectedTimelineItem.value, property)
  if (oldValue === newValue) return

  if (hasAnimation.value) {
    // 有动画：通过关键帧命令更新
    await videoStore.createKeyFrameWithHistory(
      selectedTimelineItem.value.id,
      property,
      newValue
    )
  } else {
    // 无动画：通过变换命令更新
    await updatePropertyWithHistory(property, newValue)
  }
}
```

#### 属性值显示逻辑
```typescript
const transformX = computed({
  get: () => {
    if (!selectedTimelineItem.value) return 0
    
    if (hasAnimation.value) {
      // 有动画：显示当前时间点的插值
      return getPropertyValueAtTime(
        selectedTimelineItem.value,
        'x',
        videoStore.currentTime
      )
    } else {
      // 无动画：显示TimelineItem属性
      return selectedTimelineItem.value.x
    }
  },
  set: (value: number) => {
    updatePropertySmart('x', value)
  }
})
```

## 🔧 实现细节

### VideoStore扩展方法

#### 关键帧操作方法
```typescript
/**
 * 带历史记录的创建关键帧方法
 */
async function createKeyFrameWithHistory(
  timelineItemId: string,
  property: AnimatableProperty,
  value?: number,
  time?: number
): Promise<void> {
  const timelineItem = timelineModule.getTimelineItem(timelineItemId)
  if (!timelineItem) return

  const targetTime = time ?? currentTime.value
  const targetValue = value ?? getCurrentPropertyValue(timelineItem, property)

  const command = new CreateKeyFrameCommand(
    timelineItemId,
    property,
    targetTime,
    targetValue,
    { getTimelineItem: timelineModule.getTimelineItem },
    videoResolution.value
  )
  
  await historyModule.executeCommand(command)
}

/**
 * 带历史记录的删除关键帧方法
 */
async function removeKeyFrameWithHistory(
  timelineItemId: string,
  property: AnimatableProperty,
  time?: number
): Promise<void> {
  const targetTime = time ?? currentTime.value

  const command = new RemoveKeyFrameCommand(
    timelineItemId,
    property,
    targetTime,
    { getTimelineItem: timelineModule.getTimelineItem },
    videoResolution.value
  )
  
  await historyModule.executeCommand(command)
}
```

### 属性面板重构

#### 统一的属性输入绑定
```typescript
// 替换所有现有的属性绑定
// 从：@change="(value) => updatePropertyWithHistory('x', value)"
// 到：@change="(value) => updatePropertySmart('x', value)"

<NumberInput
  :model-value="transformX"
  @change="(value) => updatePropertySmart('x', value)"
  :min="-videoStore.videoResolution.width"
  :max="videoStore.videoResolution.width"
  :step="1"
  :precision="0"
  placeholder="中心为0"
  :input-style="positionInputStyle"
/>
```

#### 关键帧按钮行为
```typescript
const handleToggleKeyFrame = async (property: AnimatableProperty) => {
  if (!selectedTimelineItem.value) return

  if (hasKeyFrameAtTime(property)) {
    // 删除关键帧
    await videoStore.removeKeyFrameWithHistory(
      selectedTimelineItem.value.id,
      property
    )
  } else {
    // 创建关键帧
    await videoStore.createKeyFrameWithHistory(
      selectedTimelineItem.value.id,
      property
    )
  }
}
```

## 🔄 状态转换处理

### 首次创建动画
```typescript
const initializeAnimation = async (property: AnimatableProperty) => {
  if (!selectedTimelineItem.value || hasAnimation.value) return
  
  const currentValue = getCurrentPropertyValue(selectedTimelineItem.value, property)
  
  // 批量操作：创建初始关键帧 + 当前关键帧
  const batch = videoStore.startBatch('初始化动画')
  
  // 在时间0创建初始关键帧
  batch.addCommand(new CreateKeyFrameCommand(
    selectedTimelineItem.value.id,
    property,
    0,
    currentValue,
    timelineModule,
    videoStore.videoResolution
  ))
  
  // 在当前时间创建关键帧
  batch.addCommand(new CreateKeyFrameCommand(
    selectedTimelineItem.value.id,
    property,
    videoStore.currentTime,
    currentValue,
    timelineModule,
    videoStore.videoResolution
  ))
  
  await videoStore.executeBatchCommand(batch.build())
}
```

### 清除动画转为静态
```typescript
const finalizeToStaticValue = async () => {
  if (!selectedTimelineItem.value || !hasAnimation.value) return
  
  // 获取当前时间点的插值作为最终静态值
  const finalValues: Record<string, number> = {}
  const animatableProperties: AnimatableProperty[] = ['x', 'y', 'width', 'height', 'rotation', 'opacity']
  
  animatableProperties.forEach(property => {
    finalValues[property] = getPropertyValueAtTime(
      selectedTimelineItem.value!,
      property,
      videoStore.currentTime
    )
  })
  
  // 批量操作：清除动画 + 设置最终值
  const batch = videoStore.startBatch('转换为静态属性')
  
  batch.addCommand(new ClearAnimationCommand(
    selectedTimelineItem.value.id,
    timelineModule
  ))
  
  batch.addCommand(new UpdateTransformCommand(
    selectedTimelineItem.value.id,
    'transform',
    {},
    finalValues,
    timelineModule,
    mediaModule,
    clipOperationsModule
  ))
  
  await videoStore.executeBatchCommand(batch.build())
}
```

## 📊 实现计划

### 阶段1：基础架构（第1-2周）
1. 创建关键帧Command类
2. 扩展VideoStore方法
3. 基础测试验证

### 阶段2：属性面板重构（第3周）
1. 实现智能路由逻辑
2. 修改属性输入组件绑定
3. 优化属性值显示

### 阶段3：边界情况处理（第4周）
1. 动画状态转换
2. 批量操作支持
3. 多选状态处理

### 阶段4：测试和优化（第5周）
1. 全面功能测试
2. 性能优化
3. 用户体验完善

## 🎯 预期效果

### 用户体验
- **一致的操作感受**：无论是否有动画，属性修改体验相同
- **完整的撤销支持**：所有操作都可以撤销/重做
- **智能的状态管理**：系统自动处理动画/非动画状态

### 技术优势
- **清晰的架构分离**：动画逻辑与历史记录逻辑解耦
- **可扩展的设计**：易于添加新的动画功能
- **稳定的状态管理**：避免状态不一致问题

这个集成方案确保了动画系统与操作历史系统的完美结合，为用户提供了统一、可靠的编辑体验。
