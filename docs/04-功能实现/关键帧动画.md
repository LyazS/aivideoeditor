# 关键帧动画系统

## 📋 概述

关键帧动画系统是视频编辑器的高级功能，基于WebAV原生的setAnimation API实现专业级的属性动画编辑。系统完全依赖WebAV的30FPS渲染循环和线性插值算法，提供高性能的实时动画效果。

## 🎯 设计目标

### 核心功能
- **WebAV原生驱动**：直接使用WebAV的setAnimation API，无需自建插值系统
- **关键帧编辑**：在时间轴上设置和编辑关键帧
- **属性动画**：支持位置、大小、旋转、透明度等属性的动画
- **时间轴独立**：动画duration与clip时长完全独立
- **实时预览**：基于WebAV 30FPS渲染循环的实时动画效果

### 用户体验
- **直观操作**：类似专业视频编辑软件的操作体验
- **可视化编辑**：图形化的关键帧时间轴
- **精确控制**：精确到帧的时间控制
- **批量操作**：支持多个关键帧的批量编辑

## 🏗️ 技术架构

### WebAV动画系统分析

#### WebAV核心类型
```typescript
// WebAV动画配置接口
interface IAnimationOpts {
  duration: number;  // 动画持续时间（微秒）
  delay?: number;    // 延迟时间（微秒）
  iterCount?: number; // 迭代次数
}

// WebAV可动画属性
type TAnimateProps = IRectBaseProps & { opacity: number };
// IRectBaseProps 包含: x, y, w, h, angle

// WebAV关键帧格式
type TKeyFrameOpts = Partial<
  Record<`${number}%` | 'from' | 'to', Partial<TAnimateProps>>
>;
```

#### WebAV动画执行原理
```typescript
// 1. 设置动画
sprite.setAnimation({
  '0%': { x: 0, y: 0 },
  '50%': { x: 500, y: 300 },
  '100%': { x: 1000, y: 0 }
}, {
  duration: 4e6,    // 4秒
  iterCount: 1      // 执行一次
});

// 2. WebAV自动执行（30FPS渲染循环）
// - 每帧调用 sprite.animate(time)
// - 线性插值计算当前属性值
// - 自动更新sprite的rect和opacity
// - Canvas重新绘制
```

#### 关键帧数据结构
```typescript
interface Keyframe {
  id: string
  time: number        // 时间（秒）
  value: any         // 属性值
  easing: EasingType // 缓动函数
  property: string   // 属性名称
  spriteId: string   // 所属精灵ID
}

interface AnimationTrack {
  id: string
  property: string   // 动画属性（x, y, scaleX, scaleY, rotation, opacity）
  keyframes: Keyframe[]
  isVisible: boolean
  isLocked: boolean
}

interface AnimationClip {
  id: string
  spriteId: string
  tracks: AnimationTrack[]
  duration: number
  isEnabled: boolean
}
```

## 🏗️ 系统架构设计

### 数据层设计

#### 项目关键帧数据结构
```typescript
// 项目内部关键帧格式（对标WebAV格式）
interface ProjectKeyFrame {
  id: string
  time: number  // 相对时间（0-1之间，对应WebAV的0%-100%）
  properties: {
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    opacity?: number
  }
}

// 项目动画配置（对标WebAV IAnimationOpts）
interface ProjectAnimationConfig {
  keyFrames: ProjectKeyFrame[]
  duration: number      // 动画周期时长（微秒）
  delay?: number        // 延迟时间（微秒）
  iterCount?: number    // 迭代次数，默认1
  isEnabled: boolean
}
```

#### TimelineItem集成
```typescript
// 扩展现有的TimelineItem
interface TimelineItem {
  // ... 现有属性
  animationConfig?: ProjectAnimationConfig // 动画配置
}
```

### WebAV格式转换器

#### 核心转换逻辑
```typescript
class WebAVAnimationConverter {
  // 项目关键帧 → WebAV TKeyFrameOpts格式
  static convertToWebAVKeyFrames(keyFrames: ProjectKeyFrame[]): TKeyFrameOpts {
    const webavKeyFrames: TKeyFrameOpts = {}

    keyFrames.forEach(kf => {
      const timeKey = kf.time === 0 ? 'from' :
                     kf.time === 1 ? 'to' :
                     `${Math.round(kf.time * 100)}%`

      webavKeyFrames[timeKey] = {
        x: kf.properties.x,
        y: kf.properties.y,
        w: kf.properties.width,   // width → w
        h: kf.properties.height,  // height → h
        angle: kf.properties.rotation,  // rotation → angle
        opacity: kf.properties.opacity
      }
    })

    return webavKeyFrames
  }

  // 项目动画配置 → WebAV IAnimationOpts格式
  static convertToWebAVOpts(config: ProjectAnimationConfig): IAnimationOpts {
    return {
      duration: config.duration,
      delay: config.delay || 0,
      iterCount: config.iterCount || 1
    }
  }
}
```

### 关键帧动画管理器

#### 核心管理类
```typescript
class KeyFrameAnimationManager {
  // 应用动画到WebAV Sprite
  applyAnimationToSprite(
    sprite: VideoVisibleSprite | ImageVisibleSprite,
    config: ProjectAnimationConfig
  ): void {
    if (!config.isEnabled || config.keyFrames.length < 2) {
      return
    }

    const webavKeyFrames = WebAVAnimationConverter.convertToWebAVKeyFrames(config.keyFrames)
    const webavOpts = WebAVAnimationConverter.convertToWebAVOpts(config)

    // 直接调用WebAV的setAnimation
    sprite.setAnimation(webavKeyFrames, webavOpts)
  }

  // 清除动画
  clearSpriteAnimation(sprite: VideoVisibleSprite | ImageVisibleSprite): void {
    // WebAV清除动画的方式
    sprite.setAnimation({}, { duration: 0 })
  }

  // 创建关键帧
  createKeyFrame(
    timelineItem: TimelineItem,
    property: AnimatableProperty,
    time: number,  // 当前播放时间（秒）
    value: number
  ): void {
    if (!timelineItem.animationConfig) {
      timelineItem.animationConfig = {
        keyFrames: [],
        duration: 2_000_000, // 默认2秒动画周期
        iterCount: 1,
        isEnabled: true
      }
    }

    // 计算相对时间（0-1）
    const relativeTime = this.calculateRelativeTime(time, timelineItem)

    // 查找或创建关键帧
    let keyFrame = timelineItem.animationConfig.keyFrames.find(kf =>
      Math.abs(kf.time - relativeTime) < 0.01 // 1%容差
    )

    if (!keyFrame) {
      keyFrame = {
        id: generateId(),
        time: relativeTime,
        properties: {}
      }
      timelineItem.animationConfig.keyFrames.push(keyFrame)
    }

    // 设置属性值
    keyFrame.properties[property] = value

    // 重新应用动画
    this.applyAnimationToSprite(timelineItem.sprite, timelineItem.animationConfig)
  }

  // 计算相对时间（关键逻辑）
  private calculateRelativeTime(currentTime: number, timelineItem: TimelineItem): number {
    const config = timelineItem.animationConfig!
    const animationDurationSeconds = config.duration / 1_000_000

    // 将当前时间映射到动画周期内的相对位置
    const timeInCycle = currentTime % animationDurationSeconds
    return timeInCycle / animationDurationSeconds
  }
}
```

## 🎮 MVP用户操作流程

### 📍 核心操作：设置关键帧

#### 简化操作步骤
1. **选择片段** - 在时间轴上选择要添加动画的片段
2. **移动播放头** - 拖拽到想要设置关键帧的时间点
3. **点击关键帧按钮** - 点击属性旁边的钻石按钮 ◆

#### 预期效果
- **按钮变化**：空心 ◇ → 实心 ◆（橙色）
- **动画生效**：如果已有其他关键帧，动画立即播放

```typescript
// MVP版本的关键帧切换逻辑
const handleKeyFrameToggle = (property: AnimatableProperty) => {
  const currentTime = videoStore.currentTime
  const currentValue = selectedTimelineItem.value[property]

  if (hasKeyFrameAtCurrentTime(property, currentTime)) {
    // 删除关键帧
    keyFrameManager.removeKeyFrame(selectedTimelineItem.value, property, currentTime)
  } else {
    // 创建关键帧（使用当前属性值）
    keyFrameManager.createKeyFrame(selectedTimelineItem.value, property, currentTime, currentValue)
  }
}
```

### 🔄 调整属性的效果

#### 在关键帧时间点调整
**操作**：移动到关键帧时间点，调整属性值

**效果**：
- 关键帧值立即更新
- 动画重新计算并生效

#### 在非关键帧时间点调整
**操作**：移动到非关键帧时间点，调整属性值

**效果**：
- 属性值立即改变（临时效果）
- 现有动画不受影响

### 🎯 MVP版本：关键帧导航

#### 基础导航（MVP核心功能）
**操作**：手动拖拽播放头到关键帧时间点

**效果**：
- 属性面板自动更新显示该时间点的属性值
- 关键帧按钮状态自动更新（有关键帧时显示实心）

```typescript
// MVP版本：简单的时间点检查
const updateKeyFrameButtonStates = (currentTime: number) => {
  ['x', 'y', 'width', 'height', 'rotation', 'opacity'].forEach(property => {
    const hasKeyFrame = hasKeyFrameAtCurrentTime(property, currentTime)
    updateKeyFrameButtonState(property, hasKeyFrame)
  })
}
```

### 🔍 MVP版本：找回关键帧

#### 方法1：播放头拖拽（MVP核心功能）
**操作**：拖拽播放头，观察关键帧按钮状态变化

**效果**：
- 当播放头移动到有关键帧的时间点时，对应按钮变为实心
- 属性面板显示该关键帧的属性值

#### 方法2：播放预览（MVP辅助功能）
**操作**：点击播放按钮，观察动画效果

**效果**：
- 可以看到动画在哪些时间点有变化
- 暂停后可以在变化点设置新的关键帧

### 🔧 MVP版本：增量属性设置

#### 在关键帧时间点调整属性
**操作**：移动播放头到关键帧时间点，调整属性值

**效果**：
- 关键帧值立即更新
- 动画重新计算并生效
- 属性面板显示新值

```typescript
// MVP版本：简单的关键帧属性更新
const updateKeyFrameProperty = (property: AnimatableProperty, newValue: number) => {
  const currentTime = videoStore.currentTime
  const keyFrame = findKeyFrameAtTime(currentTime, property)

  if (keyFrame) {
    // 更新关键帧值
    keyFrame.properties[property] = newValue
    // 重新应用动画
    applyAnimationToSprite(timelineItem.sprite, timelineItem.animationConfig)
  }
}
```

## 🎯 MVP实现计划

### 阶段1：核心功能（2-3天）
**目标**：实现最基础的关键帧动画功能

**任务清单**：
- [ ] 完善`animationTypes.ts`中的类型定义
- [ ] 实现`WebAVAnimationConverter`转换器
- [ ] 实现`KeyFrameAnimationManager`核心逻辑
- [ ] 扩展`KeyFrameButton.vue`组件
- [ ] 集成到`PropertiesPanel.vue`

**验收标准**：
- 能够点击关键帧按钮创建/删除关键帧
- 关键帧按钮状态正确反映当前时间点的关键帧存在性
- 调整属性值时关键帧能够正确更新
- 播放时能看到动画效果

### MVP功能范围

#### ✅ 包含功能
1. **基础关键帧操作**
   - 点击按钮创建/删除关键帧
   - 关键帧按钮状态显示（空心/实心）
   - 在关键帧时间点调整属性值

2. **简单导航**
   - 拖拽播放头查看关键帧状态
   - 播放预览观察动画效果

3. **基础动画**
   - 支持位置、大小、旋转、透明度动画
   - WebAV原生线性插值
   - 基础的动画播放

#### ❌ 暂不包含功能
1. **高级导航**
   - 关键帧导航按钮
   - 关键帧列表面板
   - 时间轴关键帧标记

2. **高级编辑**
   - 拖拽调整关键帧时间
   - 关键帧时间轴面板
   - 批量关键帧操作

3. **高级功能**
   - 缓动函数选择
   - 动画预设模板
   - 关键帧搜索过滤

## 🔗 相关文档

- [架构设计](../03-开发文档/架构设计.md) - 系统架构设计
- [API文档](../03-开发文档/API文档.md) - WebAV API接口
- [操作历史系统](操作历史系统.md) - 撤销/重做功能
- [WebAV集成](../05-重构记录/WebAV清理.md) - WebAV集成架构

## 📝 MVP总结

基于WebAV动画系统的深度分析，MVP版本的关键帧动画系统具有以下特点：

### 🎯 核心操作流程
1. **设置关键帧**：选择片段 → 移动播放头 → 点击关键帧按钮 ◆
2. **调整属性**：在关键帧时间点调整属性值，关键帧立即更新
3. **找回关键帧**：拖拽播放头观察按钮状态，或播放预览观察动画
4. **增量调整**：在关键帧时间点进行属性值的增量修改

### 🔧 技术特点
1. **WebAV原生驱动** - 完全依赖WebAV的setAnimation API
2. **简化交互** - 专注核心功能，避免复杂的UI组件
3. **渐进实现** - 从最基础功能开始，逐步扩展
4. **架构兼容** - 完全兼容现有的TimelineItem架构

### 🚀 实现优势
1. **快速上手** - 用户学习成本低，操作直观
2. **开发简单** - 避免复杂的时间轴UI，专注核心逻辑
3. **性能优秀** - 直接使用WebAV的30FPS渲染和线性插值
4. **扩展性强** - 为未来的高级功能预留了架构空间

这个MVP版本为用户提供了基础但完整的关键帧动画功能，是向专业视频编辑软件发展的重要第一步。

---

**提示**：MVP版本专注于核心功能的快速实现，为用户提供基础的关键帧动画能力，后续可根据用户反馈逐步扩展高级功能。

## 🔗 相关文档

- [架构设计](../03-开发文档/架构设计.md) - 系统架构设计
- [API文档](../03-开发文档/API文档.md) - WebAV API接口
- [操作历史系统](操作历史系统.md) - 撤销/重做功能
- [WebAV集成](../05-重构记录/WebAV清理.md) - WebAV集成架构

## 📝 MVP总结

基于WebAV动画系统的深度分析，MVP版本的关键帧动画系统具有以下特点：

### 🎯 核心操作流程
1. **设置关键帧**：选择片段 → 移动播放头 → 点击关键帧按钮 ◆
2. **调整属性**：在关键帧时间点调整属性值，关键帧立即更新
3. **找回关键帧**：拖拽播放头观察按钮状态，或播放预览观察动画
4. **增量调整**：在关键帧时间点进行属性值的增量修改

### 🔧 技术特点
1. **WebAV原生驱动** - 完全依赖WebAV的setAnimation API
2. **简化交互** - 专注核心功能，避免复杂的UI组件
3. **渐进实现** - 从最基础功能开始，逐步扩展
4. **架构兼容** - 完全兼容现有的TimelineItem架构

### 🚀 实现优势
1. **快速上手** - 用户学习成本低，操作直观
2. **开发简单** - 避免复杂的时间轴UI，专注核心逻辑
3. **性能优秀** - 直接使用WebAV的30FPS渲染和线性插值
4. **扩展性强** - 为未来的高级功能预留了架构空间

这个MVP版本为用户提供了基础但完整的关键帧动画功能，是向专业视频编辑软件发展的重要第一步。

---

**提示**：MVP版本专注于核心功能的快速实现，为用户提供基础的关键帧动画能力，后续可根据用户反馈逐步扩展高级功能。

