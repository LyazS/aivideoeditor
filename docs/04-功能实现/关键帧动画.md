# 关键帧动画系统

## 📋 概述

关键帧动画系统是视频编辑器的高级功能，基于WebAV原生的setAnimation API实现专业级的属性动画编辑。系统完全依赖WebAV的30FPS渲染循环和线性插值算法，提供高性能的实时动画效果。

## 🎯 设计目标

### 核心功能
- **WebAV原生驱动**：直接使用WebAV的setAnimation API，无需自建插值系统
- **关键帧编辑**：在时间轴上设置和编辑关键帧
- **属性动画**：支持位置、大小、旋转、透明度等属性的动画
- **时间轴同步**：动画duration与clip时长保持一致
- **实时预览**：基于WebAV 30FPS渲染循环的实时动画效果

### 用户体验
- **直观操作**：类似专业视频编辑软件的操作体验
- **可视化编辑**：图形化的关键帧时间轴
- **精确控制**：精确到帧的时间控制
- **批量操作**：支持多个关键帧的批量编辑

## 🏗️ 技术架构

### WebAV动画系统分析

#### WebAV核心类型
```typescript
// WebAV动画配置接口
interface IAnimationOpts {
  duration: number;  // 动画持续时间（微秒）
  delay?: number;    // 延迟时间（微秒）
  iterCount?: number; // 迭代次数
}

// WebAV可动画属性
type TAnimateProps = IRectBaseProps & { opacity: number };
// IRectBaseProps 包含: x, y, w, h, angle

// WebAV关键帧格式
type TKeyFrameOpts = Partial<
  Record<`${number}%` | 'from' | 'to', Partial<TAnimateProps>>
>;
```

#### WebAV动画执行原理
```typescript
// 1. 设置动画
sprite.setAnimation({
  '0%': { x: 0, y: 0 },
  '50%': { x: 500, y: 300 },
  '100%': { x: 1000, y: 0 }
}, {
  duration: 4e6,    // 4秒
  iterCount: 1      // 执行一次
});

// 2. WebAV自动执行（30FPS渲染循环）
// - 每帧调用 sprite.animate(time)
// - 线性插值计算当前属性值
// - 自动更新sprite的rect和opacity
// - Canvas重新绘制
```

#### 关键帧数据结构
```typescript
interface Keyframe {
  id: string
  time: number        // 时间（秒）
  value: any         // 属性值
  easing: EasingType // 缓动函数
  property: string   // 属性名称
  spriteId: string   // 所属精灵ID
}

interface AnimationTrack {
  id: string
  property: string   // 动画属性（x, y, scaleX, scaleY, rotation, opacity）
  keyframes: Keyframe[]
  isVisible: boolean
  isLocked: boolean
}

interface AnimationClip {
  id: string
  spriteId: string
  tracks: AnimationTrack[]
  duration: number
  isEnabled: boolean
}
```

## 🏗️ 系统架构设计

### 数据层设计

#### 项目关键帧数据结构
```typescript
// 项目内部关键帧格式（对标WebAV格式）
interface ProjectKeyFrame {
  id: string
  time: number  // 相对时间（0-1之间，对应WebAV的0%-100%）
  properties: {
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    opacity?: number
  }
}

// 项目动画配置（对标WebAV IAnimationOpts）
interface ProjectAnimationConfig {
  keyFrames: ProjectKeyFrame[]
  duration: number      // 动画周期时长（微秒）
  delay?: number        // 延迟时间（微秒）
  iterCount?: number    // 迭代次数，默认1
  isEnabled: boolean
}
```

#### TimelineItem集成
```typescript
// 扩展现有的TimelineItem
interface TimelineItem {
  // ... 现有属性
  animationConfig?: ProjectAnimationConfig // 动画配置
}
```

### WebAV格式转换器

#### 核心转换逻辑
```typescript
class WebAVAnimationConverter {
  // 项目关键帧 → WebAV TKeyFrameOpts格式
  static convertToWebAVKeyFrames(keyFrames: ProjectKeyFrame[]): TKeyFrameOpts {
    const webavKeyFrames: TKeyFrameOpts = {}

    keyFrames.forEach(kf => {
      const timeKey = kf.time === 0 ? 'from' :
                     kf.time === 1 ? 'to' :
                     `${Math.round(kf.time * 100)}%`

      webavKeyFrames[timeKey] = {
        x: kf.properties.x,
        y: kf.properties.y,
        w: kf.properties.width,   // width → w
        h: kf.properties.height,  // height → h
        angle: kf.properties.rotation,  // rotation → angle
        opacity: kf.properties.opacity
      }
    })

    return webavKeyFrames
  }

  // 项目动画配置 → WebAV IAnimationOpts格式
  static convertToWebAVOpts(config: ProjectAnimationConfig): IAnimationOpts {
    return {
      duration: config.duration,
      delay: config.delay || 0,
      iterCount: config.iterCount || 1
    }
  }
}
```

### 关键帧动画管理器

#### 核心管理类
```typescript
class KeyFrameAnimationManager {
  // 应用动画到WebAV Sprite
  applyAnimationToSprite(
    sprite: VideoVisibleSprite | ImageVisibleSprite,
    config: ProjectAnimationConfig
  ): void {
    if (!config.isEnabled || config.keyFrames.length < 2) {
      return
    }

    const webavKeyFrames = WebAVAnimationConverter.convertToWebAVKeyFrames(config.keyFrames)
    const webavOpts = WebAVAnimationConverter.convertToWebAVOpts(config)

    // 直接调用WebAV的setAnimation
    sprite.setAnimation(webavKeyFrames, webavOpts)
  }

  // 清除动画
  clearSpriteAnimation(sprite: VideoVisibleSprite | ImageVisibleSprite): void {
    // WebAV清除动画的方式
    sprite.setAnimation({}, { duration: 0 })
  }

  // 创建关键帧
  createKeyFrame(
    timelineItem: TimelineItem,
    property: AnimatableProperty,
    time: number,  // 当前播放时间（秒）
    value: number
  ): void {
    if (!timelineItem.animationConfig) {
      // 使用clip时长作为动画duration
      const clipDurationMicroseconds = getClipDuration(timelineItem) * 1_000_000
      timelineItem.animationConfig = {
        keyFrames: [],
        duration: clipDurationMicroseconds, // 动画时长等于clip时长
        iterCount: 1, // 固定为1次迭代
        isEnabled: true
      }
    }

    // 计算相对时间（0-1）
    const relativeTime = this.calculateRelativeTime(time, timelineItem)

    // 查找或创建关键帧
    let keyFrame = timelineItem.animationConfig.keyFrames.find(kf =>
      Math.abs(kf.time - relativeTime) < 0.01 // 1%容差
    )

    if (!keyFrame) {
      keyFrame = {
        id: generateId(),
        time: relativeTime,
        properties: {}
      }
      timelineItem.animationConfig.keyFrames.push(keyFrame)
    }

    // 设置属性值
    keyFrame.properties[property] = value

    // 重新应用动画
    this.applyAnimationToSprite(timelineItem.sprite, timelineItem.animationConfig)
  }

  // 计算相对时间（关键逻辑）
  private calculateRelativeTime(currentTime: number, timelineItem: TimelineItem): number {
    const config = timelineItem.animationConfig!
    const animationDurationSeconds = config.duration / 1_000_000

    // 直接计算相对时间，不使用取模运算
    // 因为动画duration现在等于clip时长，且只迭代一次
    return Math.max(0, Math.min(1, currentTime / animationDurationSeconds))
  }
}
```

## 🎮 MVP用户操作流程

### 📍 核心操作：设置关键帧

#### 简化操作步骤
1. **选择片段** - 在时间轴上选择要添加动画的片段
2. **移动播放头** - 拖拽到想要设置关键帧的时间点
3. **点击关键帧按钮** - 点击属性旁边的钻石按钮 ◆

#### 预期效果
- **按钮变化**：空心 ◇ → 实心 ◆（橙色）
- **动画生效**：如果已有其他关键帧，动画立即播放

```typescript
// MVP版本的关键帧切换逻辑
const handleKeyFrameToggle = (property: AnimatableProperty) => {
  const currentTime = videoStore.currentTime
  const currentValue = selectedTimelineItem.value[property]

  if (hasKeyFrameAtCurrentTime(property, currentTime)) {
    // 删除关键帧
    keyFrameManager.removeKeyFrame(selectedTimelineItem.value, property, currentTime)
  } else {
    // 创建关键帧（使用当前属性值）
    keyFrameManager.createKeyFrame(selectedTimelineItem.value, property, currentTime, currentValue)
  }
}
```

## 🔄 动画系统与操作历史系统集成

### 核心设计原则

#### 1. 智能操作路由
根据clip的动画状态，自动选择正确的操作方式：
- **无动画clip**：直接修改TimelineItem属性 → 触发setter → 更新sprite
- **有动画clip**：创建/更新关键帧 → 不直接修改TimelineItem属性

#### 2. 统一历史记录
所有操作（包括关键帧操作）都通过Command模式集成到操作历史系统中，确保完整的撤销/重做支持。

#### 3. 判断标准
```typescript
// 判断是否为有动画的clip
const hasAnimation = computed(() => {
  return selectedTimelineItem.value?.animationConfig !== null &&
         selectedTimelineItem.value?.animationConfig !== undefined
})
```

### 操作分类架构

#### 无动画clip操作
```typescript
UpdateTransformCommand // 已存在，直接修改TimelineItem属性
```

#### 有动画clip操作（新增）
```typescript
CreateKeyFrameCommand    // 创建关键帧
RemoveKeyFrameCommand    // 删除关键帧
UpdateKeyFrameCommand    // 更新关键帧值
ToggleAnimationCommand   // 启用/禁用动画
ClearAnimationCommand    // 清除所有动画
```

### 智能属性更新系统

#### 核心路由逻辑
```typescript
// 属性面板的智能更新方法
const updatePropertySmart = async (property: AnimatableProperty, newValue: number) => {
  if (!selectedTimelineItem.value) return

  const oldValue = getCurrentPropertyValue(selectedTimelineItem.value, property)
  if (oldValue === newValue) return

  if (hasAnimation.value) {
    // 有动画：通过关键帧命令更新
    await videoStore.createKeyFrameWithHistory(
      selectedTimelineItem.value.id,
      property,
      newValue
    )
  } else {
    // 无动画：通过变换命令更新
    await updatePropertyWithHistory(property, newValue)
  }
}
```

#### 智能属性值显示
```typescript
// 计算属性：根据动画状态智能显示当前值
const transformX = computed({
  get: () => {
    if (!selectedTimelineItem.value) return 0

    if (hasAnimation.value) {
      // 有动画：显示当前时间点的插值
      return getPropertyValueAtTime(
        selectedTimelineItem.value,
        'x',
        videoStore.currentTime
      )
    } else {
      // 无动画：显示TimelineItem属性
      return selectedTimelineItem.value.x
    }
  },
  set: (value: number) => {
    updatePropertySmart('x', value)
  }
})
```

### 关键帧命令类设计

#### CreateKeyFrameCommand
```typescript
export class CreateKeyFrameCommand implements SimpleCommand {
  id: string
  type = 'CREATE_KEYFRAME'
  description: string
  timestamp: number

  constructor(
    private timelineItemId: string,
    private property: AnimatableProperty,
    private time: number,
    private value: number,
    private timelineModule: TimelineModule,
    private videoResolution: { width: number; height: number }
  ) {
    this.id = generateCommandId()
    this.timestamp = Date.now()
    this.description = `创建关键帧: ${property} = ${value} (${time}s)`
  }

  async execute(): Promise<void> {
    const timelineItem = this.timelineModule.getTimelineItem(this.timelineItemId)
    if (!timelineItem) return

    KeyFrameAnimationManager.createKeyFrame(
      timelineItem,
      this.property,
      this.time,
      this.value,
      this.videoResolution
    )
  }

  async undo(): Promise<void> {
    const timelineItem = this.timelineModule.getTimelineItem(this.timelineItemId)
    if (!timelineItem) return

    KeyFrameAnimationManager.removeKeyFrameProperty(
      timelineItem,
      this.property,
      this.time
    )
  }
}
```

#### RemoveKeyFrameCommand
```typescript
export class RemoveKeyFrameCommand implements SimpleCommand {
  id: string
  type = 'REMOVE_KEYFRAME'
  description: string
  timestamp: number
  private removedKeyFrameData: {
    value: number
    videoResolution: { width: number; height: number }
  } | null = null

  constructor(
    private timelineItemId: string,
    private property: AnimatableProperty,
    private time: number,
    private timelineModule: TimelineModule,
    private videoResolution: { width: number; height: number }
  ) {
    this.id = generateCommandId()
    this.timestamp = Date.now()
    this.description = `删除关键帧: ${property} (${time}s)`

    // 保存要删除的关键帧数据用于撤销
    const timelineItem = this.timelineModule.getTimelineItem(timelineItemId)
    if (timelineItem) {
      const currentValue = getPropertyValueAtTime(timelineItem, property, time)
      this.removedKeyFrameData = {
        value: currentValue,
        videoResolution: { ...videoResolution }
      }
    }
  }

  async execute(): Promise<void> {
    const timelineItem = this.timelineModule.getTimelineItem(this.timelineItemId)
    if (!timelineItem) return

    KeyFrameAnimationManager.removeKeyFrameProperty(
      timelineItem,
      this.property,
      this.time
    )
  }

  async undo(): Promise<void> {
    const timelineItem = this.timelineModule.getTimelineItem(this.timelineItemId)
    if (!timelineItem || !this.removedKeyFrameData) return

    // 恢复被删除的关键帧
    KeyFrameAnimationManager.createKeyFrame(
      timelineItem,
      this.property,
      this.time,
      this.removedKeyFrameData.value,
      this.removedKeyFrameData.videoResolution
    )
  }
}
```

#### ClearAnimationCommand
```typescript
export class ClearAnimationCommand implements SimpleCommand {
  id: string
  type = 'CLEAR_ANIMATION'
  description: string
  timestamp: number
  private savedAnimationConfig: AnimationConfig | null = null

  constructor(
    private timelineItemId: string,
    private timelineModule: TimelineModule
  ) {
    this.id = generateCommandId()
    this.timestamp = Date.now()
    this.description = '清除动画'

    // 保存当前动画配置用于撤销
    const timelineItem = this.timelineModule.getTimelineItem(timelineItemId)
    if (timelineItem?.animationConfig) {
      this.savedAnimationConfig = JSON.parse(JSON.stringify(timelineItem.animationConfig))
    }
  }

  async execute(): Promise<void> {
    const timelineItem = this.timelineModule.getTimelineItem(this.timelineItemId)
    if (!timelineItem) return

    // 清除动画配置
    timelineItem.animationConfig = undefined
    KeyFrameAnimationManager.clearSpriteAnimation(timelineItem.sprite)
  }

  async undo(): Promise<void> {
    const timelineItem = this.timelineModule.getTimelineItem(this.timelineItemId)
    if (!timelineItem || !this.savedAnimationConfig) return

    // 恢复动画配置
    timelineItem.animationConfig = this.savedAnimationConfig
    KeyFrameAnimationManager.applyAnimationToSprite(
      timelineItem.sprite,
      this.savedAnimationConfig,
      timelineItem,
      videoStore.videoResolution
    )
  }
}
```

### VideoStore集成方法

#### 带历史记录的关键帧操作方法
```typescript
// 在videoStore中新增方法

/**
 * 带历史记录的创建关键帧方法
 */
async function createKeyFrameWithHistory(
  timelineItemId: string,
  property: AnimatableProperty,
  value?: number,
  time?: number
): Promise<void> {
  const timelineItem = timelineModule.getTimelineItem(timelineItemId)
  if (!timelineItem) return

  const targetTime = time ?? currentTime.value
  const targetValue = value ?? getCurrentPropertyValue(timelineItem, property)

  const command = new CreateKeyFrameCommand(
    timelineItemId,
    property,
    targetTime,
    targetValue,
    { getTimelineItem: timelineModule.getTimelineItem },
    videoResolution.value
  )

  await historyModule.executeCommand(command)
}

/**
 * 带历史记录的删除关键帧方法
 */
async function removeKeyFrameWithHistory(
  timelineItemId: string,
  property: AnimatableProperty,
  time?: number
): Promise<void> {
  const targetTime = time ?? currentTime.value

  const command = new RemoveKeyFrameCommand(
    timelineItemId,
    property,
    targetTime,
    { getTimelineItem: timelineModule.getTimelineItem },
    videoResolution.value
  )

  await historyModule.executeCommand(command)
}

/**
 * 带历史记录的清除动画方法
 */
async function clearAnimationWithHistory(timelineItemId: string): Promise<void> {
  const command = new ClearAnimationCommand(
    timelineItemId,
    { getTimelineItem: timelineModule.getTimelineItem }
  )

  await historyModule.executeCommand(command)
}
```

### 属性面板重构

#### 关键帧按钮行为
```typescript
const handleToggleKeyFrame = async (property: AnimatableProperty) => {
  if (!selectedTimelineItem.value) return

  if (hasKeyFrameAtTime(property)) {
    // 删除关键帧
    await videoStore.removeKeyFrameWithHistory(
      selectedTimelineItem.value.id,
      property
    )
  } else {
    // 创建关键帧
    await videoStore.createKeyFrameWithHistory(
      selectedTimelineItem.value.id,
      property
    )
  }
}
```

#### 首次创建关键帧的特殊处理
```typescript
const handleFirstKeyFrame = async (property: AnimatableProperty) => {
  if (!selectedTimelineItem.value) return

  // 如果是首次创建关键帧，需要：
  // 1. 初始化animationConfig
  // 2. 在时间0创建初始关键帧（当前值）
  // 3. 在当前时间创建目标关键帧

  if (!hasAnimation.value) {
    const currentValue = getCurrentPropertyValue(selectedTimelineItem.value, property)

    // 批量操作：创建初始关键帧 + 当前关键帧
    const batch = videoStore.startBatch('初始化动画')

    // 在时间0创建初始关键帧
    batch.addCommand(new CreateKeyFrameCommand(
      selectedTimelineItem.value.id,
      property,
      0,
      currentValue,
      timelineModule,
      videoStore.videoResolution
    ))

    // 在当前时间创建关键帧
    batch.addCommand(new CreateKeyFrameCommand(
      selectedTimelineItem.value.id,
      property,
      videoStore.currentTime,
      currentValue,
      timelineModule,
      videoStore.videoResolution
    ))

    await videoStore.executeBatchCommand(batch.build())
  }
}
```

### 边界情况处理

#### 1. 动画状态转换
```typescript
// 从无动画转为有动画
const initializeAnimation = async (property: AnimatableProperty) => {
  if (!selectedTimelineItem.value || hasAnimation.value) return

  // 创建初始关键帧，保持当前属性值
  const currentValue = getCurrentPropertyValue(selectedTimelineItem.value, property)
  await videoStore.createKeyFrameWithHistory(
    selectedTimelineItem.value.id,
    property,
    currentValue,
    0 // 在时间0创建初始关键帧
  )
}

// 从有动画转为无动画
const finalizeToStaticValue = async () => {
  if (!selectedTimelineItem.value || !hasAnimation.value) return

  // 获取当前时间点的插值作为最终静态值
  const finalValues: Record<string, number> = {}
  const animatableProperties: AnimatableProperty[] = ['x', 'y', 'width', 'height', 'rotation', 'opacity']

  animatableProperties.forEach(property => {
    finalValues[property] = getPropertyValueAtTime(
      selectedTimelineItem.value!,
      property,
      videoStore.currentTime
    )
  })

  // 批量操作：清除动画 + 设置最终值
  const batch = videoStore.startBatch('转换为静态属性')

  // 清除动画
  batch.addCommand(new ClearAnimationCommand(
    selectedTimelineItem.value.id,
    timelineModule
  ))

  // 设置最终静态值
  batch.addCommand(new UpdateTransformCommand(
    selectedTimelineItem.value.id,
    'transform',
    {}, // 旧值（将在命令中获取）
    finalValues,
    timelineModule,
    mediaModule,
    clipOperationsModule
  ))

  await videoStore.executeBatchCommand(batch.build())
}
```

#### 2. 多选状态处理
```typescript
// 多选时禁用动画功能
const isAnimationDisabled = computed(() => {
  return videoStore.isMultiSelectMode || !selectedTimelineItem.value
})

// 在属性面板中
const showAnimationControls = computed(() => {
  return !isAnimationDisabled.value && selectedTimelineItem.value
})
```

#### 3. 属性同步处理
```typescript
// 监听当前时间变化，更新动画属性显示
watch(
  () => videoStore.currentTime,
  (newTime) => {
    if (selectedTimelineItem.value?.animationConfig?.isEnabled) {
      // 触发计算属性重新计算，更新UI显示
      // Vue的响应式系统会自动处理
    }
  }
)

// 监听选中项目变化，同步动画管理器
watch(selectedTimelineItem, (newItem) => {
  setSelectedTimelineItem(newItem)
}, { immediate: true })
```

### 实现步骤

#### 阶段1：基础架构（第1-2周）
1. **创建关键帧Command类**
   - CreateKeyFrameCommand
   - RemoveKeyFrameCommand
   - ClearAnimationCommand

2. **扩展VideoStore方法**
   - createKeyFrameWithHistory()
   - removeKeyFrameWithHistory()
   - clearAnimationWithHistory()

#### 阶段2：属性面板重构（第3周）
3. **重构属性更新逻辑**
   - 实现updatePropertySmart()
   - 修改所有属性输入组件绑定

4. **优化属性值显示**
   - 实现智能计算属性
   - 处理动画插值显示

#### 阶段3：边界情况处理（第4周）
5. **动画状态转换**
   - 首次创建关键帧的批量操作
   - 清除动画时的状态处理

6. **完善用户体验**
   - 多选状态的动画控制禁用
   - 视觉反馈和状态指示器

#### 阶段4：测试和优化（第5周）
7. **全面测试**
   - 撤销/重做功能测试
   - 动画状态转换测试
   - 边界情况测试

8. **性能优化**
   - 批量操作优化
   - 内存管理优化

### 预期效果

#### 1. 统一的操作体验
- 所有属性修改操作都支持撤销/重做
- 动画和非动画clip的操作体验一致
- 智能的操作路由，用户无需关心底层实现

#### 2. 完整的历史记录
- 关键帧的创建、删除、修改都有历史记录
- 动画状态的启用/禁用可以撤销
- 批量操作作为单个历史记录项

#### 3. 清晰的状态管理
- 明确的动画/非动画状态判断
- 正确的属性值显示（静态值 vs 插值）
- 合理的边界情况处理

这个集成方案确保了动画系统与操作历史系统的完美结合，为用户提供了一致、可靠的编辑体验。

### 🔄 调整属性的效果

#### 在关键帧时间点调整
**操作**：移动到关键帧时间点，调整属性值

**效果**：
- 关键帧值立即更新
- 动画重新计算并生效

#### 在非关键帧时间点调整
**操作**：移动到非关键帧时间点，调整属性值

**效果**：
- 属性值立即改变（临时效果）
- 现有动画不受影响

### 🎯 MVP版本：关键帧导航

#### 基础导航（MVP核心功能）
**操作**：手动拖拽播放头到关键帧时间点

**效果**：
- 属性面板自动更新显示该时间点的属性值
- 关键帧按钮状态自动更新（有关键帧时显示实心）

```typescript
// MVP版本：简单的时间点检查
const updateKeyFrameButtonStates = (currentTime: number) => {
  ['x', 'y', 'width', 'height', 'rotation', 'opacity'].forEach(property => {
    const hasKeyFrame = hasKeyFrameAtCurrentTime(property, currentTime)
    updateKeyFrameButtonState(property, hasKeyFrame)
  })
}
```

### 🔍 MVP版本：找回关键帧

#### 方法1：播放头拖拽（MVP核心功能）
**操作**：拖拽播放头，观察关键帧按钮状态变化

**效果**：
- 当播放头移动到有关键帧的时间点时，对应按钮变为实心
- 属性面板显示该关键帧的属性值

#### 方法2：播放预览（MVP辅助功能）
**操作**：点击播放按钮，观察动画效果

**效果**：
- 可以看到动画在哪些时间点有变化
- 暂停后可以在变化点设置新的关键帧

### 🔧 MVP版本：增量属性设置

#### 在关键帧时间点调整属性
**操作**：移动播放头到关键帧时间点，调整属性值

**效果**：
- 关键帧值立即更新
- 动画重新计算并生效
- 属性面板显示新值

```typescript
// MVP版本：简单的关键帧属性更新
const updateKeyFrameProperty = (property: AnimatableProperty, newValue: number) => {
  const currentTime = videoStore.currentTime
  const keyFrame = findKeyFrameAtTime(currentTime, property)

  if (keyFrame) {
    // 更新关键帧值
    keyFrame.properties[property] = newValue
    // 重新应用动画
    applyAnimationToSprite(timelineItem.sprite, timelineItem.animationConfig)
  }
}
```

## 🎯 MVP实现计划

### 阶段1：核心功能（2-3天）
**目标**：实现最基础的关键帧动画功能

**任务清单**：
- [ ] 完善`animationTypes.ts`中的类型定义
- [ ] 实现`WebAVAnimationConverter`转换器
- [ ] 实现`KeyFrameAnimationManager`核心逻辑
- [ ] 扩展`KeyFrameButton.vue`组件
- [ ] 集成到`PropertiesPanel.vue`

**验收标准**：
- 能够点击关键帧按钮创建/删除关键帧
- 关键帧按钮状态正确反映当前时间点的关键帧存在性
- 调整属性值时关键帧能够正确更新
- 播放时能看到动画效果

### MVP功能范围

#### ✅ 包含功能
1. **基础关键帧操作**
   - 点击按钮创建/删除关键帧
   - 关键帧按钮状态显示（空心/实心）
   - 在关键帧时间点调整属性值

2. **简单导航**
   - 拖拽播放头查看关键帧状态
   - 播放预览观察动画效果

3. **基础动画**
   - 支持位置、大小、旋转、透明度动画
   - WebAV原生线性插值
   - 基础的动画播放

#### ❌ 暂不包含功能
1. **高级导航**
   - 关键帧导航按钮
   - 关键帧列表面板
   - 时间轴关键帧标记

2. **高级编辑**
   - 拖拽调整关键帧时间
   - 关键帧时间轴面板
   - 批量关键帧操作

3. **高级功能**
   - 缓动函数选择
   - 动画预设模板
   - 关键帧搜索过滤

## 🔗 相关文档

- [架构设计](../03-开发文档/架构设计.md) - 系统架构设计
- [API文档](../03-开发文档/API文档.md) - WebAV API接口
- [操作历史系统](操作历史系统.md) - 撤销/重做功能
- [WebAV集成](../05-重构记录/WebAV清理.md) - WebAV集成架构

## 📝 MVP总结

基于WebAV动画系统的深度分析，MVP版本的关键帧动画系统具有以下特点：

### 🎯 核心操作流程
1. **设置关键帧**：选择片段 → 移动播放头 → 点击关键帧按钮 ◆
2. **调整属性**：在关键帧时间点调整属性值，关键帧立即更新
3. **找回关键帧**：拖拽播放头观察按钮状态，或播放预览观察动画
4. **增量调整**：在关键帧时间点进行属性值的增量修改

### 🔧 技术特点
1. **WebAV原生驱动** - 完全依赖WebAV的setAnimation API
2. **简化交互** - 专注核心功能，避免复杂的UI组件
3. **渐进实现** - 从最基础功能开始，逐步扩展
4. **架构兼容** - 完全兼容现有的TimelineItem架构

### 🚀 实现优势
1. **快速上手** - 用户学习成本低，操作直观
2. **开发简单** - 避免复杂的时间轴UI，专注核心逻辑
3. **性能优秀** - 直接使用WebAV的30FPS渲染和线性插值
4. **扩展性强** - 为未来的高级功能预留了架构空间

这个MVP版本为用户提供了基础但完整的关键帧动画功能，是向专业视频编辑软件发展的重要第一步。

---

**提示**：MVP版本专注于核心功能的快速实现，为用户提供基础的关键帧动画能力，后续可根据用户反馈逐步扩展高级功能。

## 🔗 相关文档

- [架构设计](../03-开发文档/架构设计.md) - 系统架构设计
- [API文档](../03-开发文档/API文档.md) - WebAV API接口
- [操作历史系统](操作历史系统.md) - 撤销/重做功能
- [WebAV集成](../05-重构记录/WebAV清理.md) - WebAV集成架构

## 📝 MVP总结

基于WebAV动画系统的深度分析，MVP版本的关键帧动画系统具有以下特点：

### 🎯 核心操作流程
1. **设置关键帧**：选择片段 → 移动播放头 → 点击关键帧按钮 ◆
2. **调整属性**：在关键帧时间点调整属性值，关键帧立即更新
3. **找回关键帧**：拖拽播放头观察按钮状态，或播放预览观察动画
4. **增量调整**：在关键帧时间点进行属性值的增量修改

### 🔧 技术特点
1. **WebAV原生驱动** - 完全依赖WebAV的setAnimation API
2. **简化交互** - 专注核心功能，避免复杂的UI组件
3. **渐进实现** - 从最基础功能开始，逐步扩展
4. **架构兼容** - 完全兼容现有的TimelineItem架构

### 🚀 实现优势
1. **快速上手** - 用户学习成本低，操作直观
2. **开发简单** - 避免复杂的时间轴UI，专注核心逻辑
3. **性能优秀** - 直接使用WebAV的30FPS渲染和线性插值
4. **扩展性强** - 为未来的高级功能预留了架构空间

这个MVP版本为用户提供了基础但完整的关键帧动画功能，是向专业视频编辑软件发展的重要第一步。

---

**提示**：MVP版本专注于核心功能的快速实现，为用户提供基础的关键帧动画能力，后续可根据用户反馈逐步扩展高级功能。

