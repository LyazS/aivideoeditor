# 🆕 新数据流向架构

## 概述

已成功实现新的数据流向架构，确保数据流向清晰且一致：

**UI输入 → updateTimelineItemProperty → Sprite属性更新 → propsChange事件 → TimelineItem属性更新 → UI反馈**

## 数据流向详解

### 1. UI输入阶段
- 用户在属性面板中修改数值（位置、缩放、旋转、透明度等）
- 触发相应的更新方法（如 `updatePositionProperty`, `setScaleX`, `setOpacity` 等）

### 2. updateTimelineItemProperty 调用
- 所有属性更新都统一调用 `videoStore.updateTimelineItemProperty(timelineItemId, property, value)`
- 这个方法负责将UI输入的值转换并应用到WebAV Sprite对象

### 3. Sprite属性更新
- `updateTimelineItemProperty` 方法根据属性类型进行相应的处理：
  - 位置属性：进行坐标系转换（项目坐标 → WebAV坐标）
  - 尺寸属性：保持中心点不变的缩放
  - 其他属性：直接设置到sprite对象

### 4. propsChange事件触发
- WebAV的原生事件系统自动检测sprite属性变化
- 触发 `propsChange` 事件，传递变化的属性信息

### 5. TimelineItem属性更新
- `handleSpritePropsChangeImpl` 方法接收propsChange事件
- 将sprite的属性值同步回TimelineItem对象
- 进行必要的坐标系转换（WebAV坐标 → 项目坐标）

### 6. UI反馈
- Vue的响应式系统自动检测TimelineItem属性变化
- 更新属性面板中的显示值，完成数据流向闭环

## 已更新的方法

### 位置属性
```typescript
const updatePositionProperty = (axis: 'x' | 'y', newValue: number) => {
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, axis, newValue)
}
```

### 缩放属性
```typescript
const setScaleX = (value: number) => {
  const newWidth = originalResolution.width * value
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'width', newWidth)
}

const setScaleY = (value: number) => {
  const newHeight = originalResolution.height * value
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'height', newHeight)
}
```

### 变换属性
```typescript
const setRotation = (value: number) => {
  const newRotationRadians = uiDegreesToWebAVRadians(value)
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'rotation', newRotationRadians)
}

const setOpacity = (value: number) => {
  const newOpacity = Math.max(0, Math.min(1, value))
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'opacity', newOpacity)
}

const updateZIndex = (value: number) => {
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'zIndex', value)
}
```

### 音量属性
```typescript
const updateVolume = (newVolume: number) => {
  const clampedVolume = Math.max(0, Math.min(1, newVolume))
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'volume', clampedVolume)
  
  // 自动处理静音状态
  if (clampedVolume > 0 && selectedTimelineItem.value.isMuted) {
    videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'isMuted', false)
  } else if (clampedVolume === 0) {
    videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'isMuted', true)
  }
}

const toggleMute = () => {
  const newMutedState = !selectedTimelineItem.value.isMuted
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'isMuted', newMutedState)
}
```

### 等比缩放
```typescript
const updateUniformScale = (newScale: number) => {
  const newSize = {
    width: originalResolution.width * newScale,
    height: originalResolution.height * newScale,
  }
  
  // 同时更新宽度和高度
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'width', newSize.width)
  videoStore.updateTimelineItemProperty(selectedTimelineItem.value.id, 'height', newSize.height)
}
```

### 对齐功能
```typescript
const alignHorizontal = (alignment: 'left' | 'center' | 'right') => {
  // 计算新的X坐标
  let newProjectX = 0
  // ... 计算逻辑
  
  updatePositionProperty('x', Math.round(newProjectX))
}

const alignVertical = (alignment: 'top' | 'middle' | 'bottom') => {
  // 计算新的Y坐标
  let newProjectY = 0
  // ... 计算逻辑
  
  updatePositionProperty('y', Math.round(newProjectY))
}
```

## 优势

1. **数据流向清晰**：单一的数据流向路径，易于理解和调试
2. **一致性**：所有属性更新都使用相同的机制
3. **可维护性**：集中的属性更新逻辑，便于维护和扩展
4. **响应式**：利用Vue的响应式系统自动更新UI
5. **事件驱动**：基于WebAV原生事件系统，性能优异

## 调试信息

每个属性更新都会输出详细的调试信息：

```
🔄 [新数据流] UI输入 → updateTimelineItemProperty → X: {
  timelineItemId: "item-123",
  property: "x",
  newValue: 100,
  oldValue: 50
}
```

这样可以清楚地跟踪数据流向的每个步骤。

## 废弃的方法

以下方法已被新的数据流向替代：
- `updatePropertySmart` - 已废弃
- `updatePropertyWithHistory` - 已废弃
- 复杂的getter/setter逻辑 - 已简化

新架构更加简洁和可靠。

## 🎬 关键帧系统集成

### 问题修复

在实现新数据流向时，发现关键帧系统失效的问题。原因是：

1. **类型不匹配**：`KeyFrameAnimationManager.createKeyFrame` 方法的 `value` 参数类型定义为 `number`，但 `position` 属性需要传递 `{x, y}` 对象
2. **循环更新**：新数据流向可能导致关键帧更新触发 `propsChange` 事件，再次触发属性更新，形成无限循环

### 解决方案

#### 1. 修复类型定义
```typescript
// 修改前
static createKeyFrame(
  timelineItem: TimelineItem,
  property: AnimatableProperty,
  time: number,
  value: number, // ❌ 只支持number类型
  videoResolution: { width: number; height: number }
): KeyFrameOperationResult

// 修改后
static createKeyFrame(
  timelineItem: TimelineItem,
  property: AnimatableProperty,
  time: number,
  value: any, // ✅ 支持复合属性如position的{x,y}
  videoResolution: { width: number; height: number }
): KeyFrameOperationResult
```

#### 2. 防止循环更新
```typescript
// 添加循环检测标志
let isUpdatingFromKeyFrame = false

function updateTimelineItemProperty(timelineItemId: string, property: string, value: any) {
  // 检查动画配置
  if (hasAnimation) {
    isUpdatingFromKeyFrame = true // 🆕 设置标志
    try {
      // 通过关键帧系统更新
      KeyFrameAnimationManager.createKeyFrame(...)
    } finally {
      isUpdatingFromKeyFrame = false // 🆕 重置标志
    }
  }
}

const handleSpritePropsChangeImpl = (timelineItemId: string, changes: any): void => {
  // 🆕 如果正在通过关键帧系统更新，跳过处理避免循环
  if (isUpdatingFromKeyFrame) {
    return
  }
  // 正常处理sprite属性变化
}
```

#### 3. 智能属性路由
```typescript
// 🎬 有动画配置的clip：通过关键帧系统更新
if (hasAnimation) {
  // 位置属性特殊处理
  if (property === 'x' || property === 'y') {
    const positionValue = { x: currentX, y: currentY }
    KeyFrameAnimationManager.createKeyFrame(timelineItem, 'position', time, positionValue, resolution)
  } else {
    // 其他属性直接创建关键帧
    KeyFrameAnimationManager.createKeyFrame(timelineItem, property, time, value, resolution)
  }
}
// 📄 无动画配置的clip：直接更新sprite属性
else {
  sprite[property] = value
}
```

### 数据流向完整图

```
UI输入 → updateTimelineItemProperty
    ↓
    检查是否有动画配置？
    ↓                    ↓
   是                    否
    ↓                    ↓
关键帧系统更新          直接更新Sprite
    ↓                    ↓
WebAV动画应用          propsChange事件
    ↓                    ↓
   跳过循环处理          TimelineItem更新
                        ↓
                       UI反馈
```

### 测试验证

现在关键帧系统应该正常工作：

1. **创建关键帧**：在有动画配置的clip上修改属性时，会自动创建关键帧
2. **更新关键帧**：在已有关键帧的时间点修改属性时，会更新现有关键帧
3. **动画播放**：关键帧动画应该正常播放和预览
4. **无循环冲突**：不会出现无限循环更新的问题

可以通过以下步骤测试：
1. 选择一个clip并启用动画（创建第一个关键帧）
2. 在时间轴上移动到不同时间点
3. 修改位置、缩放、旋转等属性
4. 观察关键帧是否正确创建和更新
5. 播放时间轴查看动画效果
