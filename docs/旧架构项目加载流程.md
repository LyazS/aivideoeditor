# 旧架构项目加载流程分析

## 概述

本文档详细分析了旧架构中项目的加载流程，包括从用户选择项目到完全加载到内存中的整个过程。旧架构采用了分阶段加载策略，确保用户体验流畅，避免长时间阻塞。

## 整体架构

旧架构的项目加载主要由以下几个关键组件组成：

1. **ProjectManagement.vue** - 项目管理界面，负责项目列表显示和用户交互
2. **ProjectManager.ts** - 项目管理器，负责实际的项目文件操作
3. **projectModule** - 项目状态管理模块，负责项目加载状态跟踪
4. **videoStore** - 主状态存储，整合各个功能模块
5. **MediaManager** - 媒体文件管理器，负责媒体文件的加载

## 详细加载流程

### 1. 项目列表加载阶段

#### 1.1 工作目录权限检查
```typescript
// 文件: frontend/src/views/ProjectManagement.vue
async function checkWorkspaceAccess() {
  try {
    console.log('🔍 开始检查工作目录权限...')
    const hasAccess = await directoryManager.hasWorkspaceAccess()
    hasWorkspaceAccess.value = hasAccess
    
    if (hasAccess) {
      workspaceInfo.value = await directoryManager.getWorkspaceInfo()
      await loadProjects()
    }
  } catch (error) {
    console.error('❌ 检查工作目录权限失败:', error)
    hasWorkspaceAccess.value = false
  }
}
```

#### 1.2 项目列表扫描
```typescript
// 文件: frontend/src/utils/ProjectManager.ts
async listProjects(): Promise<ProjectConfig[]> {
  const workspaceHandle = await directoryManager.getWorkspaceHandle()
  const projectsHandle = await this.getOrCreateProjectsFolder(workspaceHandle)
  const projects: ProjectConfig[] = []

  // 遍历projects文件夹中的所有子文件夹
  for await (const [name, handle] of projectsHandle.entries()) {
    if (handle.kind === 'directory') {
      try {
        const projectConfig = await this.loadProjectConfig(handle)
        if (projectConfig) {
          projects.push(projectConfig)
        }
      } catch (error) {
        console.warn(`加载项目 ${name} 失败:`, error)
      }
    }
  }

  // 按更新时间排序
  projects.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
  return projects
}
```

### 2. 项目选择与页面跳转

#### 2.1 项目选择
用户在项目列表中点击项目卡片：
```typescript
// 文件: frontend/src/views/ProjectManagement.vue
function openProjectById(projectId: string) {
  // 使用页面重载方式打开项目，确保所有store状态都被重新创建
  console.log(`🚀 使用页面重载方式打开项目: ${projectId}`)
  window.location.href = `/editor/${projectId}`
}
```

#### 2.2 编辑器页面初始化
编辑器页面（`/editor/:projectId`）加载时，会触发以下流程：

1. URL参数解析获取项目ID
2. 初始化unifiedStore（替代了旧架构的videoStore）
3. 触发项目加载流程

##### 详细实现过程

###### 1. URL参数解析获取项目ID

URL参数解析在VideoEditor.vue组件的生命周期钩子中完成：

```typescript
// 文件: frontend/src/views/VideoEditor.vue
import { useRoute } from 'vue-router'

const route = useRoute()

// 在onBeforeMount和onMounted中获取项目ID
const projectId = route.params.projectId as string
```

路由配置在 [`router/index.ts`](frontend/src/router/index.ts:18) 中定义：

```typescript
// 文件: frontend/src/router/index.ts
{
  path: '/editor/:projectId?',
  name: 'VideoEditor',
  component: VideoEditor,
  meta: {
    title: '视频编辑器 - 光影绘梦',
  },
}
```

###### 2. 初始化unifiedStore

unifiedStore的初始化在应用程序启动时完成，具体在 [`main.ts`](frontend/src/main.ts:10) 中：

```typescript
// 文件: frontend/src/main.ts
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())  // 初始化Pinia状态管理
app.use(router)         // 初始化路由
```

然后在VideoEditor.vue组件中通过 [`useUnifiedStore`](frontend/src/views/VideoEditor.vue:134) 获取store实例：

```typescript
// 文件: frontend/src/views/VideoEditor.vue
import { useUnifiedStore } from '@/unified/unifiedStore'

const unifiedStore = useUnifiedStore()
```

unifiedStore是一个统一的状态管理器，整合了多个功能模块，包括：
- 统一媒体管理模块 (UnifiedMediaModule)
- 统一轨道管理模块 (UnifiedTrackModule)
- 统一时间轴管理模块 (UnifiedTimelineModule)
- 统一项目管理模块 (UnifiedProjectModule)
- 统一视口管理模块 (UnifiedViewportModule)
- 统一选择管理模块 (UnifiedSelectionModule)
- 统一片段操作模块 (UnifiedClipOperationsModule)
- 统一配置管理模块 (UnifiedConfigModule)
- 统一播放控制模块 (UnifiedPlaybackModule)
- 统一WebAV集成模块 (UnifiedWebavModule)
- 统一通知管理模块 (UnifiedNotificationModule)
- 统一历史记录模块 (UnifiedHistoryModule)

###### 3. 触发项目加载流程

项目加载流程在VideoEditor.vue组件的生命周期钩子中分两个阶段触发：

**第一阶段：预加载项目设置（onBeforeMount）**

```typescript
// 文件: frontend/src/views/VideoEditor.vue
onBeforeMount(async () => {
  console.log('🔄 [LIFECYCLE] VideoEditor.onBeforeMount 开始')

  // 从路由参数获取项目ID
  const projectId = route.params.projectId as string

  try {
    console.log('🔄 [LIFECYCLE] VideoEditor 开始预加载项目设置')
    await unifiedStore.preloadProjectSettings(projectId)
    console.log('✅ [LIFECYCLE] VideoEditor 项目设置预加载完成')
  } catch (error) {
    console.error('❌ [LIFECYCLE] VideoEditor 预加载项目设置失败:', error)
    // 对于现有项目，预加载失败是严重错误，需要通知用户
    if (projectId && projectId !== 'undefined') {
      projectTitle.value = '项目设置加载失败'
      throw new Error(`项目设置加载失败: ${error}`)
    }
    // 对于新项目，可以使用默认设置继续
    console.log('🔄 [LIFECYCLE] VideoEditor 新项目使用默认设置')
  }

  console.log('🔄 [LIFECYCLE] VideoEditor.onBeforeMount 完成')
})
```

**第二阶段：加载项目内容（onMounted）**

```typescript
// 文件: frontend/src/views/VideoEditor.vue
onMounted(async () => {
  console.log('🔄 [LIFECYCLE] VideoEditor.onMounted 开始')

  // 从路由参数获取项目ID
  const projectId = route.params.projectId as string

  try {
    console.log('📂 [VideoEditor] 开始加载项目内容...')
    await unifiedStore.loadProjectContent(projectId)

    if (unifiedStore.hasCurrentProject) {
      projectTitle.value = unifiedStore.currentProjectName
      console.log('✅ [VideoEditor] 项目内容加载完成:', unifiedStore.currentProjectName)

      // 启用自动保存
      autoSave.enableAutoSave()
      console.log('✅ [VideoEditor] 自动保存已启用')
    } else {
      projectTitle.value = '新建项目'
      console.log('📝 [VideoEditor] 准备创建新项目')

      // 对于新项目，暂时禁用自动保存，直到项目被创建
      autoSave.disableAutoSave()
    }
  } catch (error) {
    console.error('❌ [VideoEditor] 加载项目内容失败:', error)
    projectTitle.value = '加载失败'
    autoSave.disableAutoSave()
  }

  // 注册键盘快捷键
  window.addEventListener('keydown', handleKeydown)

  console.log('🔄 [LIFECYCLE] VideoEditor.onMounted 完成')
})
```

这种分阶段加载的设计确保了：
1. **快速响应**：预加载阶段只加载项目设置，不包含媒体文件，可以快速完成
2. **渐进式加载**：内容加载阶段在组件挂载后进行，不会阻塞界面渲染
3. **错误隔离**：设置预加载失败不会阻止组件挂载，可以显示错误信息
4. **用户体验**：用户可以立即看到编辑器界面，同时后台继续加载项目内容

### 3. 项目设置预加载阶段

#### 3.1 轻量级设置加载
```typescript
// 文件: frontend/src/stores/modules/projectModule.ts
async function preloadProjectSettings(projectId: string): Promise<void> {
  if (!projectId || projectId === 'undefined') {
    console.log('🔄 [LIFECYCLE] ProjectModule 新项目，使用默认设置')
    isProjectSettingsReady.value = true
    return
  }

  try {
    console.log(`🔧 [Settings Preload] 开始预加载项目设置: ${projectId}`)
    
    const settings = await projectManager.loadProjectSettings(projectId)
    
    if (settings) {
      // 恢复配置到configModule
      videoStore.restoreFromProjectSettings(settings)
      
      console.log('🔄 [LIFECYCLE] ProjectModule 项目设置预加载成功')
      isProjectSettingsReady.value = true
    } else {
      // settings为null表示项目不存在（新项目），使用默认设置
      console.log('🔄 [LIFECYCLE] ProjectModule 项目不存在，使用默认设置')
      isProjectSettingsReady.value = true
    }
  } catch (error) {
    console.error('❌ [Settings Preload] 预加载项目设置失败:', error)
    isProjectSettingsReady.value = false
    throw new Error(`项目设置加载失败，无法继续: ${error instanceof Error ? error.message : String(error)}`)
  }
}
```

#### 3.2 项目管理器中的设置加载实现
```typescript
// 文件: frontend/src/utils/ProjectManager.ts
async loadProjectSettings(projectId: string): Promise<ProjectConfig['settings'] | null> {
  try {
    console.log(`🔧 [Settings Preload] 开始预加载项目设置: ${projectId}`)
    
    const projectsHandle = await workspaceHandle.getDirectoryHandle(this.PROJECTS_FOLDER)
    const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
    const projectConfig = await this.loadProjectConfig(projectHandle)
    
    if (!projectConfig) {
      throw new Error(`项目配置文件读取失败或格式错误`)
    }
    
    if (!projectConfig.settings) {
      throw new Error(`项目配置文件缺少settings字段`)
    }
    
    // 验证关键设置字段
    if (!projectConfig.settings.videoResolution) {
      throw new Error(`项目配置缺少videoResolution设置`)
    }
    
    return projectConfig.settings
  } catch (error) {
    // 如果是项目不存在的错误，返回null（用于新项目）
    if (error instanceof Error && error.name === 'NotFoundError') {
      console.log(`📝 [Settings Preload] 项目不存在，返回null: ${projectId}`)
      return null
    }
    
    // 其他错误（文件损坏、格式错误等）抛出异常
    throw new Error(`无法加载项目设置: ${error instanceof Error ? error.message : String(error)}`)
  }
}
```

### 4. 项目内容加载阶段

#### 4.1 主要加载流程
```typescript
// 文件: frontend/src/stores/modules/projectModule.ts
async function loadProjectContent(projectId: string): Promise<void> {
  if (!projectId || projectId === 'undefined') {
    console.log('📂 [Content Load] 新项目，跳过内容加载')
    currentProject.value = null
    mediaReferences.value = {}
    lastSaved.value = null
    isProjectContentReady.value = true
    return
  }

  try {
    isLoading.value = true
    updateLoadingProgress('开始加载项目内容...', 5)
    console.log(`📂 [Content Load] 开始加载项目内容: ${projectId}`)

    // 获取预加载的设置（如果有的话）
    const { useVideoStore } = await import('../videoStore')
    const videoStore = useVideoStore()
    const preloadedSettings = {
      videoResolution: videoStore.videoResolution,
      frameRate: videoStore.frameRate,
      timelineDurationFrames: videoStore.timelineDurationFrames,
    }

    // 使用分阶段加载方法
    const result = await projectManager.loadProjectContent(projectId, preloadedSettings, {
      loadMedia: true,
      loadTimeline: true,
      onProgress: (stage, progress) => {
        updateLoadingProgress(stage, progress)
      },
    })

    if (result?.projectConfig) {
      const { projectConfig, mediaItems, timelineItems, tracks } = result

      // 设置项目配置
      currentProject.value = projectConfig
      mediaReferences.value = projectConfig.localMediaReferences || {}
      lastSaved.value = new Date(projectConfig.updatedAt)

      // 先清理无效的媒体引用，确保数据一致性
      await cleanupInvalidMediaReferences(mediaItems || [])

      // 然后恢复媒体文件到VideoStore中
      if (mediaItems && mediaItems.length > 0) {
        console.log(`📁 [Content Load] 恢复媒体文件到store: ${mediaItems.length}个文件`)
        videoStore.restoreMediaItems(mediaItems)
        console.log(`✅ [Content Load] 媒体文件恢复完成: ${mediaItems.length}个文件`)
      }

      // 如果有轨道数据，恢复轨道结构
      if (tracks && tracks.length > 0) {
        console.log(`📋 [Content Load] 恢复轨道结构: ${tracks.length}个轨道`)
        videoStore.restoreTracks(tracks)
        console.log(`✅ [Content Load] 轨道结构恢复完成: ${tracks.length}个轨道`)
      }

      // 如果有时间轴项目数据，恢复时间轴项目
      if (timelineItems && timelineItems.length > 0) {
        console.log(`⏰ [Content Load] 恢复时间轴项目: ${timelineItems.length}个项目`)
        await videoStore.restoreTimelineItems(timelineItems)
        console.log(`✅ [Content Load] 时间轴项目恢复完成: ${timelineItems.length}个项目`)
      }

      updateLoadingProgress('项目内容加载完成', 100)
      console.log(`✅ [Content Load] 项目内容加载成功: ${projectConfig.name}`)
    } else {
      console.warn(`❌ [Content Load] 项目不存在: ${projectId}`)
    }

    isProjectContentReady.value = true
  } catch (error) {
    console.error('❌ [Content Load] 加载项目内容失败:', error)
    throw error
  } finally {
    resetLoadingState()
  }
}
```

#### 4.2 项目管理器中的内容加载实现
```typescript
// 文件: frontend/src/utils/ProjectManager.ts
async loadProjectContent(
  projectId: string,
  preloadedSettings?: ProjectConfig['settings'],
  options: LoadProjectOptions = {},
): Promise<ProjectLoadResult | null> {
  const { loadMedia = true, loadTimeline = true, onProgress } = options

  try {
    console.log(`📂 [Content Load] 开始加载项目内容: ${projectId}`)
    const loadedStages: string[] = []

    // 阶段1: 加载项目配置 (如果没有预加载设置则需要加载)
    let projectConfig: ProjectConfig

    if (preloadedSettings) {
      console.log(`🔧 [Content Load] 使用预加载的设置，跳过配置文件读取`)
      onProgress?.('使用预加载设置...', 10)

      // 仍需要读取完整配置以获取其他数据，但设置部分使用预加载的
      const projectsHandle = await workspaceHandle.getDirectoryHandle(this.PROJECTS_FOLDER)
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      const fullConfig = await this.loadProjectConfig(projectHandle)

      if (!fullConfig) {
        throw new Error('项目配置加载失败')
      }

      // 使用预加载的设置覆盖文件中的设置
      projectConfig = {
        ...fullConfig,
        settings: preloadedSettings,
      }
    } else {
      console.log(`📂 [Content Load] 加载完整项目配置...`)
      onProgress?.('加载项目配置...', 10)

      const projectsHandle = await workspaceHandle.getDirectoryHandle(this.PROJECTS_FOLDER)
      const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
      const fullConfig = await this.loadProjectConfig(projectHandle)

      if (!fullConfig) {
        throw new Error('项目配置加载失败')
      }

      projectConfig = fullConfig
    }

    loadedStages.push('config-loaded')
    console.log(`✅ [Content Load] 项目配置处理完成: ${projectConfig.name}`)

    // 阶段2: 加载媒体文件 (20% -> 80%)
    let mediaItems: LocalMediaItem[] | undefined

    if (
      loadMedia &&
      projectConfig.localMediaReferences &&
      Object.keys(projectConfig.localMediaReferences).length > 0
    ) {
      onProgress?.('加载媒体文件...', 30)

      console.log(
        `📁 [Content Load] 开始加载媒体文件: ${Object.keys(projectConfig.localMediaReferences).length}个文件`,
      )

      try {
        mediaItems = await mediaManager.loadAllMediaForProject(
          projectId,
          projectConfig.localMediaReferences,
          {
            batchSize: 10,
            onProgress: (loaded, total) => {
              // 将媒体加载进度映射到30%-80%范围
              const mediaProgress = 30 + (loaded / total) * 50
              onProgress?.(`加载媒体文件 ${loaded}/${total}...`, mediaProgress)
            },
          },
        )

        loadedStages.push('media-loaded')
        console.log(`✅ [Content Load] 媒体文件加载完成: ${mediaItems.length}个文件`)
      } catch (error) {
        console.error('❌ [Content Load] 媒体文件加载失败:', error)
        // 媒体加载失败不应该阻止项目加载，继续后续流程
        mediaItems = []
      }
    }

    // 阶段3: 加载时间轴数据 (80% -> 95%)
    let timelineItems: LocalTimelineItemData[] | undefined
    let tracks: Track[] | undefined

    if (loadTimeline && projectConfig.timeline) {
      onProgress?.('加载时间轴数据...', 85)

      tracks = projectConfig.timeline.tracks || []
      console.log(`📋 [Content Load] 加载轨道数据: ${tracks.length}个轨道`)

      timelineItems = projectConfig.timeline.timelineItems || []
      console.log(`⏰ [Content Load] 加载时间轴项目数据: ${timelineItems.length}个项目`)

      onProgress?.('时间轴数据加载完成...', 95)
      loadedStages.push('timeline-loaded')
      console.log(
        `✅ [Content Load] 时间轴数据加载完成: ${tracks.length}个轨道, ${timelineItems.length}个项目`,
      )
    }

    // 阶段4: 完成加载 (95% -> 100%)
    onProgress?.('内容加载完成', 100)
    loadedStages.push('complete')

    const result: ProjectLoadResult = {
      projectConfig,
      mediaItems,
      timelineItems,
      tracks,
      loadedStages,
    }

    console.log(`✅ [Content Load] 项目内容加载完成: ${projectConfig.name}`, {
      loadedStages,
      mediaItemsCount: mediaItems?.length || 0,
      timelineItemsCount: timelineItems?.length || 0,
      tracksCount: tracks?.length || 0,
    })

    return result
  } catch (error) {
    console.error(`❌ [Content Load] 加载项目内容失败: ${projectId}`, error)
    throw error
  }
}
```

### 5. 时间轴项目重建阶段

#### 5.1 时间轴项目恢复
```typescript
// 文件: frontend/src/stores/videoStore.ts
async function restoreTimelineItems(restoredTimelineItems: LocalTimelineItemData[]) {
  console.log(`⏰ 开始恢复时间轴项目: ${restoredTimelineItems.length}个项目`)

  // 清空现有的时间轴项目
  timelineModule.timelineItems.value = []

  // 首先恢复时间轴项目数据（不包含sprite）
  for (const itemData of restoredTimelineItems) {
    // 基本验证：必须有ID
    if (!itemData.id) {
      console.warn('⚠️ 跳过无效的时间轴项目数据（缺少ID）:', itemData)
      continue
    }

    // 特殊处理文本类型（文本类型没有对应的媒体项目，mediaItemId可以为空）
    if (itemData.mediaType === 'text') {
      // 文本类型验证通过
    } else {
      // 非文本类型：必须有mediaItemId且对应的媒体项目必须存在
      if (!itemData.mediaItemId) {
        console.warn('⚠️ 跳过无效的时间轴项目数据（缺少mediaItemId）:', itemData)
        continue
      }

      const mediaItem = mediaModule.getLocalMediaItem(itemData.mediaItemId)
      if (!mediaItem) {
        console.warn(`⚠️ 跳过时间轴项目，对应的媒体项目不存在: ${itemData.mediaItemId}`)
        continue
      }
    }

    // 创建时间轴项目（不包含sprite和thumbnailUrl，都将在后续重建）
    const timelineItem: Partial<LocalTimelineItem> = {
      id: itemData.id,
      mediaItemId: itemData.mediaItemId,
      trackId: itemData.trackId,
      mediaType: itemData.mediaType,
      timeRange: itemData.timeRange,
      config: itemData.config,
      animation: itemData.animation ? { ...itemData.animation } : undefined, // 恢复动画配置
      mediaName: itemData.mediaName, // 恢复媒体名称
    }

    // 暂时添加到数组中（不完整的项目）
    timelineModule.timelineItems.value.push(timelineItem as LocalTimelineItem)
    console.log(`📋 恢复时间轴项目数据: ${itemData.id} (${itemData.mediaType})`)
  }

  console.log(`✅ 时间轴项目数据恢复完成: ${timelineModule.timelineItems.value.length}个项目`)

  // 然后等待WebAV画布准备好，重建所有sprite
  await rebuildTimelineItemSprites()
}
```

#### 5.2 Sprite重建
```typescript
// 文件: frontend/src/stores/videoStore.ts
async function rebuildTimelineItemSprites() {
  console.log(`🔄 开始重建时间轴项目的sprite...`)

  const items = timelineModule.timelineItems.value
  if (items.length === 0) {
    console.log(`ℹ️ 没有时间轴项目需要重建sprite`)
    return
  }

  // 等待WebAV画布准备好
  await webavModule.waitForWebAVReady()

  // 导入sprite工厂函数和缩略图生成函数
  const { createSpriteFromMediaItem } = await import('../utils/spriteFactory')
  const { regenerateThumbnailForTimelineItem } = await import('../utils/thumbnailGenerator')

  let rebuiltCount = 0
  for (const timelineItem of items) {
    try {
      if (isAsyncProcessingTimelineItem(timelineItem)) {
        continue
      }
      console.log(`🔄 重建sprite: ${timelineItem.id} (${rebuiltCount + 1}/${items.length})`)

      // 特殊处理文本类型的时间轴项目
      let newSprite: any
      if (timelineItem.mediaType === 'text') {
        // 文本类型：从配置中重新创建TextVisibleSprite
        const textConfig = timelineItem.config as TextMediaConfig
        const { TextVisibleSprite } = await import('../utils/TextVisibleSprite')
        newSprite = await TextVisibleSprite.create(textConfig.text, textConfig.style)
      } else {
        // 其他类型：从媒体项目创建sprite
        const mediaItem = mediaModule.getLocalMediaItem(timelineItem.mediaItemId)
        if (!mediaItem) {
          console.warn(`⚠️ 跳过时间轴项目，对应的媒体项目不存在: ${timelineItem.mediaItemId}`)
          continue
        }

        if (mediaItem.status !== 'ready') {
          console.warn(`⚠️ 跳过时间轴项目，媒体项目尚未准备好: ${mediaItem.name}`)
          continue
        }

        // 从原始素材重新创建sprite
        newSprite = await createSpriteFromMediaItem(mediaItem)
      }

      // 恢复时间范围设置
      newSprite.setTimeRange(timelineItem.timeRange)

      // 恢复配置设置（包括位置、大小、旋转、透明度等）
      if (timelineItem.config) {
        // 根据媒体类型应用配置
        if (timelineItem.mediaType === 'video') {
          // VideoVisibleSprite：应用视觉和音频属性
          const videoSprite = newSprite as VideoVisibleSprite
          const visualProps = getVisualPropsFromData(timelineItem)
          const audioProps = getAudioPropsFromData(timelineItem)

          // 应用坐标转换（位置和尺寸）
          if (visualProps) {
            const { projectToWebavCoords } = await import('../utils/coordinateTransform')
            const webavCoords = projectToWebavCoords(
              visualProps.x,
              visualProps.y,
              visualProps.width,
              visualProps.height,
              configModule.videoResolution.value.width,
              configModule.videoResolution.value.height,
            )
            videoSprite.rect.x = webavCoords.x
            videoSprite.rect.y = webavCoords.y
            videoSprite.rect.w = visualProps.width
            videoSprite.rect.h = visualProps.height
            videoSprite.rect.angle = visualProps.rotation
            videoSprite.opacity = visualProps.opacity
            videoSprite.zIndex = visualProps.zIndex
          }

          // 应用音频属性
          if (audioProps) {
            videoSprite.setAudioState({
              volume: audioProps.volume,
              isMuted: audioProps.isMuted,
            })
          }
        }
        // 其他媒体类型的处理...
      }

      // 添加到画布
      await webavModule.addSprite(newSprite)

      // 更新store中的sprite引用
      timelineModule.updateLocalTimelineItemSprite(timelineItem.id, markRaw(newSprite))

      // 重新设置双向数据同步
      timelineModule.setupBidirectionalSync(timelineItem)

      // 如果有动画配置，重新应用动画
      if (timelineItem.animation && timelineItem.animation.isEnabled) {
        try {
          console.log(`🎬 重新应用动画配置: ${timelineItem.id}`)
          const { updateWebAVAnimation } = await import('../utils/webavAnimationManager')
          await updateWebAVAnimation(timelineItem)
          console.log(`✅ 动画配置重新应用完成: ${timelineItem.id}`)
        } catch (animationError) {
          console.error(`❌ 动画配置重新应用失败: ${timelineItem.id}`, animationError)
        }
      }

      // 重新生成缩略图（因为之前的blob URL可能已失效）
      if (timelineItem.mediaType !== 'audio' && timelineItem.mediaType !== 'text') {
        const mediaItem = mediaModule.getLocalMediaItem(timelineItem.mediaItemId)
        if (mediaItem) {
          console.log(`🖼️ 重新生成缩略图: ${timelineItem.id}`)
          const newThumbnailUrl = await regenerateThumbnailForTimelineItem(
            timelineItem,
            mediaItem,
          )
          if (newThumbnailUrl) {
            timelineItem.thumbnailUrl = newThumbnailUrl
            console.log(`✅ 缩略图重新生成完成: ${timelineItem.id}`)
          }
        }
      }

      rebuiltCount++
      console.log(`✅ sprite重建完成: ${timelineItem.id} (${rebuiltCount}/${items.length})`)
    } catch (error) {
      console.error(`❌ sprite重建失败: ${timelineItem.id}`, error)
    }
  }

  console.log(`✅ 所有sprite重建完成: 成功${rebuiltCount}/${items.length}个`)
}
```

### 6. 媒体引用清理阶段

#### 6.1 清理无效媒体引用
```typescript
// 文件: frontend/src/stores/modules/projectModule.ts
async function cleanupInvalidMediaReferences(loadedMediaItems: LocalMediaItem[]): Promise<void> {
  const loadedMediaIds = new Set(loadedMediaItems.map((item) => item.id))
  const originalReferencesCount = Object.keys(mediaReferences.value).length

  console.log(
    `🧹 [MEDIA-CLEANUP] 检查媒体引用一致性: ${originalReferencesCount} 个引用, ${loadedMediaItems.length} 个成功加载`,
  )

  // 找出无效的媒体引用（在引用中存在但未成功加载的）
  const invalidMediaIds: string[] = []
  for (const mediaId in mediaReferences.value) {
    if (!loadedMediaIds.has(mediaId)) {
      invalidMediaIds.push(mediaId)
    }
  }

  if (invalidMediaIds.length > 0) {
    console.log(`🧹 [MEDIA-CLEANUP] 发现 ${invalidMediaIds.length} 个无效媒体引用，开始清理...`)

    // 移除无效的媒体引用
    for (const mediaId of invalidMediaIds) {
      const reference = mediaReferences.value[mediaId]
      console.log(
        `🧹 [MEDIA-CLEANUP] 清理无效媒体引用: ${mediaId} (${reference?.originalFileName || 'Unknown'})`,
      )
      delete mediaReferences.value[mediaId]
    }

    // 立即保存更新后的项目配置
    try {
      if (currentProject.value) {
        // 更新当前项目的 localMediaReferences
        currentProject.value.localMediaReferences = { ...mediaReferences.value }
        await projectManager.saveProject(currentProject.value)
        console.log(
          `🧹 [MEDIA-CLEANUP] ✅ 媒体引用清理完成: 移除 ${invalidMediaIds.length} 个无效引用 (${originalReferencesCount} -> ${Object.keys(mediaReferences.value).length})`,
        )
      }
    } catch (error) {
      console.error('🧹 [MEDIA-CLEANUP] ❌ 保存清理后的项目配置失败:', error)
    }
  } else {
    console.log(
      `🧹 [MEDIA-CLEANUP] ✅ 媒体引用检查完成: 所有 ${originalReferencesCount} 个引用都有效`,
    )
  }
}
```

## 加载状态管理

### 状态定义
```typescript
// 文件: frontend/src/stores/modules/projectModule.ts
// 项目加载状态
const isLoading = ref(false)

// 项目设置预加载状态
const isProjectSettingsReady = ref(false)

// 项目内容加载状态
const isProjectContentReady = ref(false)

// 加载进度状态
const loadingProgress = ref(0) // 0-100
const loadingStage = ref('') // 当前加载阶段
const loadingDetails = ref('') // 详细信息
```

### 进度更新
```typescript
// 文件: frontend/src/stores/modules/projectModule.ts
function updateLoadingProgress(stage: string, progress: number, details?: string): void {
  loadingStage.value = stage
  loadingProgress.value = Math.max(0, Math.min(100, progress))
  loadingDetails.value = details || ''
  console.log(`📊 加载进度: ${stage} (${progress}%)${details ? ` - ${details}` : ''}`)
}
```

### 状态重置
```typescript
// 文件: frontend/src/stores/modules/projectModule.ts
function resetLoadingState(delay: number = 300): void {
  if (delay > 0) {
    // 延迟重置，让用户看到加载完成的状态
    setTimeout(() => {
      isLoading.value = false
      loadingProgress.value = 0
      loadingStage.value = ''
      loadingDetails.value = ''
    }, delay)
  } else {
    // 立即重置
    isLoading.value = false
    loadingProgress.value = 0
    loadingStage.value = ''
    loadingDetails.value = ''
  }
}
```

## 文件结构

旧架构的项目文件结构如下：
```
工作目录/
└── projects/
    └── project_1234567890/
        ├── project.json          # 项目配置文件
        ├── media/                # 媒体文件目录
        │   ├── videos/           # 视频文件
        │   ├── images/           # 图片文件
        │   ├── audio/            # 音频文件
        │   └── thumbnails/       # 缩略图文件
        └── exports/              # 导出文件目录
```

## 项目配置文件结构

```json
{
  "id": "project_1234567890",
  "name": "我的视频项目",
  "description": "项目描述",
  "createdAt": "2023-01-01T00:00:00.000Z",
  "updatedAt": "2023-01-01T00:00:00.000Z",
  "version": "1.0.0",
  "settings": {
    "videoResolution": {
      "name": "1920x1080",
      "width": 1920,
      "height": 1080,
      "aspectRatio": "16:9"
    },
    "frameRate": 30,
    "timelineDurationFrames": 3000
  },
  "timeline": {
    "tracks": [...],
    "timelineItems": [...],
    "mediaItems": [...]
  },
  "localMediaReferences": {
    "media_1": {
      "originalFileName": "video1.mp4",
      "storedPath": "media/videos/video1.mp4",
      "fileSize": 1024000,
      "fileType": "video/mp4",
      "mediaType": "video"
    }
  },
  "asyncProcessingMediaReferences": {},
  "exports": []
}
```

## 错误处理机制

旧架构在项目加载过程中实现了多层错误处理：

1. **文件系统错误处理**：处理文件不存在、权限不足等文件系统错误
2. **媒体加载错误处理**：单个媒体文件加载失败不会阻止整个项目加载
3. **数据验证**：对加载的项目配置进行严格验证
4. **用户反馈**：通过控制台日志和UI状态向用户提供反馈

## 性能优化策略

1. **分阶段加载**：将项目加载分为设置预加载和内容加载两个阶段
2. **批量加载**：媒体文件采用批量加载策略，避免同时加载过多文件
3. **进度反馈**：提供详细的加载进度反馈，改善用户体验
4. **缓存机制**：预加载的设置会被缓存，避免重复读取
5. **延迟重建**：时间轴项目的sprite重建等待WebAV画布准备完成后进行

## 总结

旧架构的项目加载流程设计合理，采用了分阶段加载策略，确保了用户体验的流畅性。通过设置预加载和内容加载的分离，以及详细的进度反馈机制，用户可以快速看到项目界面，同时后台继续加载媒体文件和时间轴数据。

该架构的主要优点包括：
- 响应迅速：设置预加载确保界面快速响应
- 容错性强：单个媒体文件加载失败不影响整体项目加载
- 用户体验好：详细的进度反馈让用户了解加载状态
- 数据一致性：通过媒体引用清理确保数据一致性

主要的改进空间包括：
- 可以进一步优化大媒体文件的加载策略
- 可以增加更多的缓存机制提高重复加载速度
- 可以优化错误恢复机制，提供更多的自动修复选项