# 统一时间轴项目设计 - 使用示例

## 基础创建示例

### 创建loading状态的时间轴项目

```typescript
import { createTimelineItem } from '@/timeline/timelineManager'

// 创建一个新的时间轴项目
const mediaItem = { 
  id: 'vid_123',
  mediaType: 'video' as const,
  mediaStatus: 'asyncprocessing'
}

const timelineItem = createTimelineItem(
  mediaItem,
  'track_1',
  {
    timelineStartTime: 0,
    timelineEndTime: 10
  }
)

// 初始状态检查
console.log(timelineItem.timelineStatus) // 'loading'
console.log(timelineItem.config.type)    // 'loading'
console.log(timelineItem.sprite)         // undefined
```

### 处理媒体项目状态变化

```typescript
// 监听媒体项目状态变化
mediaItem.onStatusChanged?.((oldStatus, newStatus) => {
  console.log(`媒体项目状态变化: ${oldStatus} → ${newStatus}`)
  
  switch (newStatus) {
    case 'ready':
      // 媒体处理完成，准备创建sprite
      await createSpriteForTimelineItem(timelineItem, mediaItem)
      break
      
    case 'error':
      // 处理错误状況
      timelineItem.transitionTo('error', {
        status: 'error',
        errorMessage: '媒体处理失败',
        errorCode: 'MEDIA_PROCESSING_ERROR',
        retryable: true,
        lastUpdated: Date.now()
      })
      break
  }
})
```

## 状态转换示例

### 手动状态转换

```typescript
// 从loading转换到ready
const readyTransition = () => {
  const readyContext: SpritePreparedContext = {
    type: 'sprite_prepared',
    timestamp: Date.now(),
    source: 'SpriteFactory',
    reason: 'Video sprite created successfully',
    mediaItemId: mediaItem.id,
    sprite: createdSprite,
    webavObjects: webavObjects,
    preparationTime: 120
  }
  
  timelineItem.transitionTo('ready', {
    status: 'ready',
    lastUpdated: Date.now()
  }, readyContext)
}

// 监听状态变化
console.log('转换前:', timelineItem.timelineStatus) // 'loading'
await readyTransition()
console.log('转换后:', timelineItem.timelineStatus) // 'ready'
console.log('sprite是否存在:', timelineItem.sprite !== undefined) // true
```

### 错误处理和重试

```typescript
// 错误状态转换
const handleError = (error: Error) => {
  const errorContext: TimelineErrorContext = {
    type: 'timeline_error',
    timestamp: Date.now(),
    source: 'SpriteFactory',
    reason: 'Sprite creation failed',
    mediaItemId: mediaItem.id,
    errorMessage: error.message,
    errorCode: 'SPRITE_CREATION_ERROR',
    errorDetails: error,
    retryable: true
  }
  
  timelineItem.transitionTo('error', {
    status: 'error',
    errorMessage: error.message,
    errorCode: 'SPRITE_CREATION_ERROR',
    retryable: true,
    lastUpdated: Date.now()
  }, errorContext)
}

// 重试操作
const retryTimelineItem = () => {
  const loadingContext: LoadingStartedContext = {
    type: 'loading_started',
    timestamp: Date.now(),
    source: 'TimelineItemManager',
    reason: 'Retrying failed item',
    mediaItemId: mediaItem.id,
    loadingConfig: {
      type: 'loading',
      name: 'Retrying...'
    },
    loadingPhase: 'processing'
  }
  
  timelineItem.transitionTo('loading', {
    status: 'loading',
    loadingPhase: 'processing',
    progress: 0,
    lastUpdated: Date.now()
  }, loadingContext)
  
  // 重新尝试创建sprite
  createSpriteForTimelineItem(timelineItem, mediaItem)
}
```

## 运行时状态检查

### 方法1：类型守卫检查

```typescript
import { isLoadingTimeRange, isVideoTimeRange } from '@/timeline/typeGuards'

// 检查时间范围类型
if (isLoadingTimeRange(timelineItem.timeRange)) {
  console.log('项目在加载中，无完整信息')
  // 显示加载占位符
} else if (isVideoTimeRange(timelineItem.timeRange)) {
  console.log('视频就绪，时长:', timelineItem.timeRange.clipEndTime - timelineItem.timeRange.clipStartTime)
}

// 检查配置类型并访问特定属性
import { isVideoMediaConfig, getThumbnailUrl } from '@/timeline/typeGuards'

if (isVideoMediaConfig(timelineItem.config)) {
  console.log('视频播放速率:', timelineItem.config.playbackRate)
  console.log('缩略图:', timelineItem.config.thumbnailUrl)
}
```

### 方法2：状态验证

```typescript
import { validateTimelineItemState } from '@/timeline/validation'

const validation = validateTimelineItemState(timelineItem)
if (!validation.isValid) {
  console.error('状态不一致:', validation.errors)
}

// 检查具体时间范围信息
const getTimelineDuration = (item: UnifiedTimelineItem): number => {
  switch (item.timeRange.type) {
    case 'loading':
      return item.timeRange.timelineEndTime - item.timeRange.timelineStartTime
      
    case 'video':
    case 'audio':
      return item.timeRange.clipEndTime - item.timeRange.clipStartTime
      
    case 'image':
      return item.timeRange.displayDuration
  }
}
```

## UI组件使用示例

### React组件示例

```typescript
// TimelineItemComponent.tsx
import { useEffect, useState } from 'react'
import { UnifiedTimelineItem } from '@/types/timeline'

interface TimelineItemProps {
  item: UnifiedTimelineItem
}

const TimelineItemComponent: React.FC<TimelineItemProps> = ({ item }) => {
  const [status, setStatus] = useState(item.timelineStatus)
  
  useEffect(() => {
    const handleStatusChange = (newStatus: TimelineItemStatus) => {
      setStatus(newStatus)
    }
    
    // 订阅状态变化
    const unsubscribe = subscribeToItemStatus(item.id, handleStatusChange)
    
    return unsubscribe
  }, [item.id])
  
  return (
    <div className={`timeline-item ${status}`}>
      {status === 'loading' && (
        <LoadingIndicator 
          progress={item.statusDetail.progress}
          phase={item.statusDetail.loadingPhase}
        />
      )}
      
      {status === 'ready' && (
        <ReadyItem 
          sprite={item.sprite}
          config={item.config}
          timeRange={item.timeRange}
        />
      )}
      
      {status === 'error' && (
        <ErrorDisplay
          message={item.statusDetail.errorMessage}
          code={item.statusDetail.errorCode}
          retryable={item.statusDetail.retryable}
          onRetry={() => retryTimelineItem(item)}
        />
      )}
    </div>
  )
}
```

### Vue组件示例

```typescript
<!-- TimelineItem.vue -->
<template>
  <div :class="['timeline-item', item.timelineStatus]">
    <!-- 加载中状态 -->
    <div v-if="item.timelineStatus === 'loading'" class="loading">
      <LoadingProgress 
        :progress="item.statusDetail.progress"
        :phase="item.statusDetail.loadingPhase"
      />
    </div>
    
    <!-- 就绪状态 -->
    <div v-else-if="item.timelineStatus === 'ready'" class="ready">
      <ReadyDisplay
        :sprite="item.sprite"
        :config="item.config"
        :timeRange="item.timeRange"
      />
    </div>
    
    <!-- 错误状态 -->
    <div v-else-if="item.timelineStatus === 'error'" class="error">
      <ErrorDisplay
        :message="item.statusDetail.errorMessage"
        :code="item.statusDetail.errorCode"
        :retryable="item.statusDetail.retryable"
        @retry="handleRetry"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { UnifiedTimelineItem } from '@/types/timeline'

const props = defineProps<{
  item: UnifiedTimelineItem
}>()

const handleRetry = () => {
  timelineItemManager.retryItem(props.item.id)
}
</script>
```

## 批量操作示例

### 同时创建多个时间轴项目

```typescript
const createMultipleTimelineItems = async (mediaItems: UnifiedMediaItem[]) => {
  const items = mediaItems.map(mediaItem => 
    createTimelineItem(
      mediaItem,
      `track_${mediaItem.id}`,
      {
        timelineStartTime: items.length * 5, // 每个间隔5秒
        timelineEndTime: items.length * 5 + 10
      }
    )
  )
  
  return items
}

// 等待所有项目就绪
const waitForAllItemsReady = async (items: UnifiedTimelineItem[]) => {
  await Promise.all(
    items.map(item => 
      new Promise<void>((resolve) => {
        const unsubscribe = subscribeToItemStatus(item.id, (status) => {
          if (status !== 'loading') {
            unsubscribe()
            resolve()
          }
        })
      })
    )
  )
}
```

## 动画配置示例

```typescript
// 为就绪的项目添加动画
const addAnimationToReadyItem = (item: UnifiedTimelineItem) => {
  if (item.timelineStatus === 'ready') {
    item.animation = {
      type: 'fadeIn',
      duration: 0.5,
      easing: 'ease-in-out',
      delay: 0
    }
  }
}

// 批量动画应用
const animateAllReadyItems = (items: UnifiedTimelineItem[]) => {
  items
    .filter(item => item.timelineStatus === 'ready')
    .forEach((item, index) => {
      item.animation = {
        type: 'enter',
        duration: 0.3,
        delay: index * 0.1,
        easing: 'ease-out'
      }
    })
}
```