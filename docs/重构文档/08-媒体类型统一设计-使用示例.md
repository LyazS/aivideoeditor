# 媒体类型统一设计 - 使用示例

## 概述

本文档提供统一媒体类型的具体使用示例，展示精简后的API设计，强调自动化处理和简洁的用户接口。基于统一异步源架构，所有媒体项目创建后自动开始处理，用户只需关注状态查询和必要的控制操作。

## 状态机最佳实践

### 重要变更：统一的数据流管理

**所有数据设置都必须通过 `transitionTo` 方法和转换上下文进行**，以下方法已被移除：

```typescript
// ❌ 已移除的方法
// mediaItem.setUserDuration(duration, description)
// mediaItem.setServerMetadata(metadata)

// ✅ 正确的替代方式：通过转换上下文
// 1. 用户输入时长
mediaItem.transitionTo(mediaItem.mediaStatus, {
  type: 'user_input',
  timestamp: Date.now(),
  source: 'user',
  reason: 'User provided duration',
  userDuration: 1800,
  userDescription: "用户预估30秒视频"
})

// 2. 服务器元数据
mediaItem.transitionTo('asyncprocessing', {
  type: 'server_metadata',
  timestamp: Date.now(),
  source: 'server',
  reason: 'Server provided metadata',
  serverDuration: 3600,
  serverWidth: 1920,
  serverHeight: 1080,
  serverResolution: "1920x1080",
  serverFormat: "mp4",
  serverFileSize: 52428800
})
```

### 状态机设计原则

1. **完整的状态追踪**：每次变更都有完整的转换上下文记录
2. **类型安全**：利用 TypeScript 的联合类型确保上下文类型安全
3. **一致的副作用处理**：所有状态转换的副作用都在 `handleStatusTransition` 中统一处理
4. **可追溯性**：通过 `onStatusChanged` 钩子可以完整追踪所有状态变更

## 精简API设计特点

### 1. 自动化处理
- **创建即启动**：媒体项目创建后自动开始处理，无需调用 `startProcessing()`
- **状态驱动**：所有状态转换由数据源和管理器自动驱动
- **统一流程**：本地文件和远程文件使用相同的处理流程

### 2. 精简的操作方法
```typescript
// ✅ 保留的用户控制方法
mediaItem.cancel()     // 取消处理
mediaItem.retry()      // 重试处理

// ✅ 保留的查询方法
mediaItem.isReady()           // 是否已就绪
mediaItem.isProcessing()      // 是否正在处理
mediaItem.hasError()          // 是否有错误
mediaItem.getError()          // 获取错误信息
mediaItem.getProgress()       // 获取进度 (0-1)
mediaItem.getDuration()       // 获取时长
mediaItem.getUrl()           // 获取URL

// ❌ 移除的方法（由架构自动处理）
// mediaItem.startProcessing() // 创建时自动开始
// mediaItem.pause()           // 由管理器控制
// mediaItem.resume()          // 由管理器控制
// mediaItem.forceTransition() // 违反状态机原则
```

## 基础使用示例

### 1. 创建和初始化媒体项目

```typescript
import {
  UserSelectedFileSource,
  RemoteFileSource,
  ProjectFileSource,
  isUserSelectedSource,
  isProjectFileSource,
  isRemoteSource,
  type DataSource
} from './数据源扩展类型设计'
import { BaseDataSource } from './数据源基础类型设计'

// 创建本地文件媒体项目（自动开始处理）
function createLocalMediaItem(file: File): UnifiedMediaItem {
  // 使用工厂方法创建，自动配置数据源和开始处理
  return UnifiedMediaItemFactory.fromUserSelectedFile(file, {
    onStatusChanged: (oldStatus, newStatus, context) => {
      console.log(`媒体状态变化: ${oldStatus} → ${newStatus}`)

      // 根据状态变化更新UI
      if (newStatus === 'ready') {
        console.log('媒体已就绪，可以使用')
      } else if (newStatus === 'error') {
        console.error('媒体处理失败:', context?.errorMessage)
      }
    }
  })
  // 注意：创建后自动开始处理，无需调用 startProcessing()
}

// 创建远程文件媒体项目（自动开始下载）
function createRemoteMediaItem(url: string): UnifiedMediaItem {
  // 使用工厂方法创建，自动配置数据源和开始下载
  return UnifiedMediaItemFactory.fromRemoteUrl(url, {
    timeout: 30000,
    onStatusChanged: (oldStatus, newStatus, context) => {
      console.log(`媒体状态变化: ${oldStatus} → ${newStatus}`)

      // 处理下载进度
      if (newStatus === 'asyncprocessing' && context?.type === 'progress_update') {
        const progressCtx = context as ProgressUpdateContext
        console.log(`下载进度: ${progressCtx.progress}% - ${progressCtx.progressMessage}`)
      }
    }
  })
  // 注意：创建后自动开始下载，无需手动启动
}

// 批量创建媒体项目（拖拽文件场景）
function handleFileDrop(files: FileList): UnifiedMediaItem[] {
  return UnifiedMediaItemFactory.fromFileList(files, {
    onStatusChanged: (oldStatus, newStatus, context) => {
      // 统一的状态变化处理
      updateMediaItemUI(this.id, newStatus, context)
    }
  })
  // 所有媒体项目创建后自动开始处理
}
```

### 2. 精简API的实际使用

```typescript
// 用户拖拽文件的完整处理流程
class MediaLibrary {
  private mediaItems: Map<string, UnifiedMediaItem> = new Map()

  // 处理文件拖拽
  handleFileDrop(files: FileList) {
    const newItems = UnifiedMediaItemFactory.fromFileList(files, {
      onStatusChanged: (oldStatus, newStatus, context) => {
        this.handleMediaStatusChange(this.id, oldStatus, newStatus, context)
      }
    })

    // 添加到媒体库
    newItems.forEach(item => {
      this.mediaItems.set(item.id, item)
    })

    return newItems
  }

  // 统一的状态变化处理
  private handleMediaStatusChange(
    itemId: string,
    oldStatus: MediaStatus,
    newStatus: MediaStatus,
    context?: TransitionContext
  ) {
    const item = this.mediaItems.get(itemId)
    if (!item) return

    switch (newStatus) {
      case 'ready':
        console.log(`媒体就绪: ${item.name}`)
        this.updateUI(itemId, 'ready')
        break

      case 'error':
        console.error(`媒体错误: ${item.name}`, item.getError())
        this.updateUI(itemId, 'error', item.getError())
        break

      case 'asyncprocessing':
        if (context?.type === 'progress_update') {
          const progress = item.getProgress()
          this.updateProgress(itemId, progress || 0)
        }
        break
    }
  }

  // 用户操作：取消处理
  cancelMediaItem(itemId: string) {
    const item = this.mediaItems.get(itemId)
    if (item && item.isProcessing()) {
      item.cancel()
    }
  }

  // 用户操作：重试处理
  retryMediaItem(itemId: string) {
    const item = this.mediaItems.get(itemId)
    if (item && item.hasError()) {
      item.retry()
    }
  }

  // 查询媒体状态
  getReadyMediaItems(): UnifiedMediaItem[] {
    return Array.from(this.mediaItems.values()).filter(item => item.isReady())
  }

  private updateUI(itemId: string, status: string, error?: string) {
    // 更新UI显示
  }

  private updateProgress(itemId: string, progress: number) {
    // 更新进度条
  }
}
```

### 3. 状态转换钩子的使用

```typescript
// 实现状态转换钩子
class MediaItemWithHooks extends UnifiedMediaItemImpl {
  onStatusChanged(oldStatus: MediaStatus, newStatus: MediaStatus, context?: TransitionContext): void {
    console.log(`状态转换: ${oldStatus} → ${newStatus}`)
    
    // 根据上下文类型进行类型安全的处理
    if (context) {
      switch (context.type) {
        case 'progress_update':
          this.handleProgressUpdate(context)
          break
        case 'error':
          this.handleError(context)
          break
        case 'download_completed':
          this.handleDownloadCompleted(context)
          break
        case 'parse_completed':
          this.handleParseCompleted(context)
          break
      }
    }
    
    // 通知UI更新
    this.notifyUIUpdate(newStatus, context)
  }
  
  private handleProgressUpdate(context: ProgressUpdateContext) {
    // TypeScript 知道这里 context 是 ProgressUpdateContext
    console.log(`下载进度: ${context.progress}% - ${context.progressMessage}`)
    if (context.downloadSpeed) {
      console.log(`下载速度: ${context.downloadSpeed}`)
    }
  }
  
  private handleError(context: ErrorContext) {
    // TypeScript 知道这里 context 是 ErrorContext
    console.error(`错误: ${context.errorMessage} (${context.errorCode})`)
    if (context.retryable) {
      console.log(`可重试，已重试 ${context.retryCount || 0} 次`)
    }
  }
  
  private handleDownloadCompleted(context: DownloadCompletedContext) {
    // TypeScript 知道这里 context 是 DownloadCompletedContext
    console.log(`下载完成: ${context.fileSize} bytes in ${context.downloadDuration}ms`)
    console.log(`平均速度: ${context.averageSpeed}`)
  }
  
  private handleParseCompleted(context: ParseCompletedContext) {
    // TypeScript 知道这里 context 是 ParseCompletedContext
    const { parsedMetadata } = context
    console.log(`解析完成: ${parsedMetadata.duration}s, ${parsedMetadata.format}`)
    if (parsedMetadata.resolution) {
      console.log(`分辨率: ${parsedMetadata.resolution}`)
    }
  }
}
```

## 管理器实现示例

### 1. 下载管理器完整实现

```typescript
import { isRemoteSource } from './数据源扩展类型设计'

class DownloadManager {
  private activeDownloads = new Map<string, AbortController>()

  async startDownload(item: UnifiedMediaItem): Promise<void> {
    if (!isRemoteSource(item.source)) {
      throw new Error('只能下载远程文件')
    }
    
    const controller = new AbortController()
    this.activeDownloads.set(item.id, controller)
    
    // 开始下载
    item.transitionTo('asyncprocessing', {
      type: 'async_processing',
      timestamp: Date.now(),
      source: 'DownloadManager',
      reason: '开始远程文件下载',
      initialProgress: 0,
      estimatedDuration: this.estimateDownloadTime(item.source.url)
    })
    
    try {
      const startTime = Date.now()
      const response = await fetch(item.source.getRemoteUrl(), {
        signal: controller.signal,
        headers: item.source.getConfig().headers || {}
      })
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const contentLength = response.headers.get('content-length')
      const totalBytes = contentLength ? parseInt(contentLength, 10) : 0
      
      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error('无法读取响应流')
      }
      
      const chunks: Uint8Array[] = []
      let downloadedBytes = 0
      
      while (true) {
        const { done, value } = await reader.read()
        
        if (done) break
        
        chunks.push(value)
        downloadedBytes += value.length
        
        // 更新进度
        const progress = totalBytes > 0 ? Math.round((downloadedBytes / totalBytes) * 100) : 0
        const currentTime = Date.now()
        const elapsed = currentTime - startTime
        
        item.onStatusChanged?.('asyncprocessing', 'asyncprocessing', {
          type: 'progress_update',
          timestamp: currentTime,
          source: 'DownloadManager',
          reason: '下载进度更新',
          progress,
          progressMessage: `下载中... ${progress}% (${this.formatBytes(downloadedBytes)}/${this.formatBytes(totalBytes)})`,
          estimatedTime: this.calculateETA(progress, elapsed),
          downloadSpeed: this.calculateSpeed(downloadedBytes, elapsed),
          downloadedBytes,
          totalBytes
        })
      }
      
      // 创建文件对象
      const blob = new Blob(chunks)
      const file = new File([blob], this.extractFilename(item.source.getRemoteUrl()), {
        type: response.headers.get('content-type') || 'application/octet-stream'
      })

      // 通过数据源的内部方法更新状态
      const url = URL.createObjectURL(file)
      item.source.setAcquired(file, url)
      
      // 转换到解析状态
      item.transitionTo('webavdecoding', {
        type: 'download_completed',
        timestamp: Date.now(),
        source: 'DownloadManager',
        reason: '下载完成，开始WebAV解析',
        downloadedFile: file,
        downloadedUrl: url,
        fileSize: file.size,
        downloadDuration: Date.now() - startTime,
        averageSpeed: this.calculateAverageSpeed(file.size, Date.now() - startTime)
      })
      
    } catch (error) {
      if (error.name === 'AbortError') {
        // 用户取消
        item.transitionTo('cancelled', {
          type: 'cancelled',
          timestamp: Date.now(),
          source: 'DownloadManager',
          reason: '用户取消下载',
          cancelReason: '用户主动取消',
          partialProgress: this.getPartialProgress(item),
          canResume: false
        })
      } else {
        // 下载错误 - 通过数据源方法设置错误状态
        item.source.setError(error.message)
        
        item.transitionTo('error', {
          type: 'error',
          timestamp: Date.now(),
          source: 'DownloadManager',
          reason: '下载失败',
          errorMessage: error.message,
          errorCode: this.getErrorCode(error),
          errorDetails: error,
          retryable: this.isRetryableError(error),
          retryCount: (item.retryCount || 0) + 1
        })
      }
    } finally {
      this.activeDownloads.delete(item.id)
    }
  }
  
  cancelDownload(itemId: string): void {
    const controller = this.activeDownloads.get(itemId)
    if (controller) {
      controller.abort()
    }
  }
  
  private estimateDownloadTime(url: string): number {
    // 简单的估算逻辑
    return 30000 // 30秒
  }
  
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }
  
  private calculateETA(progress: number, elapsed: number): number {
    if (progress <= 0) return 0
    return Math.round((elapsed / progress) * (100 - progress))
  }
  
  private calculateSpeed(bytes: number, elapsed: number): string {
    const bytesPerSecond = bytes / (elapsed / 1000)
    return this.formatBytes(bytesPerSecond) + '/s'
  }
  
  private calculateAverageSpeed(totalBytes: number, totalTime: number): string {
    return this.calculateSpeed(totalBytes, totalTime)
  }
  
  private extractFilename(url: string): string {
    try {
      const urlObj = new URL(url)
      const pathname = urlObj.pathname
      return pathname.split('/').pop() || 'download'
    } catch {
      return 'download'
    }
  }
  
  private getErrorCode(error: any): string {
    if (error.name === 'TypeError') return 'NETWORK_ERROR'
    if (error.message.includes('HTTP')) return 'HTTP_ERROR'
    return 'UNKNOWN_ERROR'
  }
  
  private isRetryableError(error: any): boolean {
    const retryableCodes = ['NETWORK_ERROR', 'HTTP_ERROR']
    return retryableCodes.includes(this.getErrorCode(error))
  }
  
  private getPartialProgress(item: UnifiedMediaItem): number {
    if (item.source.type === 'remote') {
      return item.source.downloadProgress
    }
    return 0
  }
}
```

## 业务场景使用示例

### 1. 用户上传文件处理

```typescript
// 用户上传文件的完整处理流程
class FileUploadHandler {
  private downloadManager = new DownloadManager()
  private webavProcessor = new WebAVProcessor()

  async handleFileUpload(files: FileList): Promise<UnifiedMediaItem[]> {
    const items: UnifiedMediaItem[] = []

    for (const file of Array.from(files)) {
      const item = new MediaItemWithHooks({
        id: generateId(),
        mediaType: 'unknown',
        mediaStatus: 'pending',
        source: {
          type: 'local',
          file,
          url: URL.createObjectURL(file)
        }
      })

      items.push(item)

      // 开始处理
      this.processLocalFile(item)
    }

    return items
  }

  async handleUrlInput(url: string): Promise<UnifiedMediaItem> {
    const item = new MediaItemWithHooks({
      id: generateId(),
      mediaType: 'unknown',
      mediaStatus: 'pending',
      source: {
        type: 'remote',
        url,
        downloadStatus: 'pending',
        downloadProgress: 0,
        config: { timeout: 30000 }
      }
    })

    // 开始下载
    this.processRemoteFile(item)

    return item
  }

  private async processLocalFile(item: UnifiedMediaItem): Promise<void> {
    try {
      item.transitionTo('webavdecoding')
      await this.webavProcessor.parseFile(item)
    } catch (error) {
      console.error('本地文件处理失败:', error)
    }
  }

  private async processRemoteFile(item: UnifiedMediaItem): Promise<void> {
    try {
      await this.downloadManager.startDownload(item)
      // 下载完成后会自动转换到webavdecoding状态
      await this.webavProcessor.parseFile(item)
    } catch (error) {
      console.error('远程文件处理失败:', error)
    }
  }
}
```

### 2. 项目保存和加载

```typescript
// 项目配置接口
interface ProjectConfig {
  id: string
  name: string
  mediaItems: MediaItemConfig[]
  createdAt: string
  updatedAt: string
}

interface MediaItemConfig {
  id: string
  mediaType: MediaType
  duration: number
  source: {
    type: 'local' | 'remote'
    originalPath?: string
    url?: string
    fileName: string
  }
}

class ProjectManager {
  private webavProcessor = new WebAVProcessor()

  // 保存项目
  saveProject(items: UnifiedMediaItem[]): ProjectConfig {
    return {
      id: generateId(),
      name: '未命名项目',
      mediaItems: items.map(item => ({
        id: item.id,
        mediaType: item.mediaType,
        duration: item.duration || 0,
        source: {
          type: item.source.getType(),
          originalPath: isUserSelectedSource(item.source) ? item.source.getSelectedFile().name :
                       isProjectFileSource(item.source) ? item.source.getFileInfo().filePath : undefined,
          url: isRemoteSource(item.source) ? item.source.getRemoteUrl() : undefined,
          fileName: this.getFileName(item)
        }
      })),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
  }

  // 加载项目
  async loadProject(config: ProjectConfig): Promise<UnifiedMediaItem[]> {
    const items: UnifiedMediaItem[] = []

    for (const itemConfig of config.mediaItems) {
      const item = await this.restoreMediaItem(itemConfig)
      items.push(item)
    }

    return items
  }

  private async restoreMediaItem(config: MediaItemConfig): Promise<UnifiedMediaItem> {
    // 根据配置创建对应的数据源实例
    let source: DataSource

    if (config.source.type === 'local' || config.source.type === 'user-selected') {
      // 创建占位的用户选择文件数据源
      const placeholderFile = new File([], config.source.fileName)
      source = new UserSelectedFileSource(placeholderFile)
    } else if (config.source.type === 'project-file') {
      // 创建工程文件数据源
      source = new ProjectFileSource({
        filePath: config.source.originalPath || '',
        fileName: config.source.fileName,
        fileSize: 0,
        lastModified: 0
      })
    } else {
      // 创建远程文件数据源
      source = new RemoteFileSource(config.source.url!, {})
    }

    const item = new MediaItemWithHooks({
      id: config.id,
      mediaType: config.mediaType,
      mediaStatus: 'pending',
      duration: config.duration,
      source
    })

    // 检查文件是否存在
    if (config.source.type === 'local' || config.source.type === 'project-file') {
      // 本地文件或工程文件需要用户重新选择
      item.transitionTo('missing', {
        type: 'missing',
        timestamp: Date.now(),
        source: 'ProjectManager',
        reason: '项目加载时发现文件缺失',
        originalPath: config.source.originalPath,
        expectedSize: 0
      })
    } else {
      // 远程文件可以重新下载
      item.transitionTo('webavdecoding')
      await this.webavProcessor.parseFile(item)
    }

    return item
  }

  private getFileName(item: UnifiedMediaItem): string {
    if (isUserSelectedSource(item.source)) {
      return item.source.getSelectedFile().name
    } else if (isProjectFileSource(item.source)) {
      return item.source.getFileInfo().fileName
    } else if (isRemoteSource(item.source)) {
      return item.source.getRemoteUrl().split('/').pop() || 'unknown'
    } else {
      return 'unknown'
    }
  }
}
```

### 3. UI组件集成示例

```typescript
// React组件示例
interface MediaItemComponentProps {
  item: UnifiedMediaItem
  onRetry: (item: UnifiedMediaItem) => void
  onCancel: (item: UnifiedMediaItem) => void
}

const MediaItemComponent: React.FC<MediaItemComponentProps> = ({ item, onRetry, onCancel }) => {
  const [status, setStatus] = useState(item.mediaStatus)
  const [progress, setProgress] = useState(0)
  const [errorMessage, setErrorMessage] = useState('')

  useEffect(() => {
    // 监听状态变化
    const originalOnStatusChanged = item.onStatusChanged

    item.onStatusChanged = (oldStatus, newStatus, context) => {
      setStatus(newStatus)

      if (context) {
        switch (context.type) {
          case 'progress_update':
            setProgress(context.progress)
            break
          case 'error':
            setErrorMessage(context.errorMessage)
            break
        }
      }

      // 调用原始钩子
      originalOnStatusChanged?.(oldStatus, newStatus, context)
    }

    return () => {
      item.onStatusChanged = originalOnStatusChanged
    }
  }, [item])

  const renderStatusContent = () => {
    switch (status) {
      case 'pending':
        return <div>等待处理...</div>

      case 'asyncprocessing':
        return (
          <div>
            <div>下载中... {progress}%</div>
            <progress value={progress} max={100} />
            <button onClick={() => onCancel(item)}>取消</button>
          </div>
        )

      case 'webavdecoding':
        return <div>解析中...</div>

      case 'ready':
        return (
          <div>
            <div>就绪 - {item.mediaType}</div>
            {item.duration && <div>时长: {item.duration}s</div>}
            {item.webav?.thumbnailUrl && (
              <img src={item.webav.thumbnailUrl} alt="缩略图" />
            )}
          </div>
        )

      case 'error':
        return (
          <div>
            <div>错误: {errorMessage}</div>
            <button onClick={() => onRetry(item)}>重试</button>
          </div>
        )

      case 'cancelled':
        return (
          <div>
            <div>已取消</div>
            <button onClick={() => onRetry(item)}>重新开始</button>
          </div>
        )

      case 'missing':
        return (
          <div>
            <div>文件缺失</div>
            <button onClick={() => onRetry(item)}>重新选择文件</button>
          </div>
        )

      default:
        return <div>未知状态</div>
    }
  }

  const getDisplayName = () => {
    if (isUserSelectedSource(item.source)) {
      return item.source.getSelectedFile().name
    } else if (isProjectFileSource(item.source)) {
      return item.source.getFileInfo().fileName
    } else if (isRemoteSource(item.source)) {
      return item.source.getRemoteUrl()
    } else {
      return 'Unknown Source'
    }
  }

  return (
    <div className="media-item">
      <h3>{getDisplayName()}</h3>
      {renderStatusContent()}
    </div>
  )
}
```

### 4. 错误处理和重试机制

```typescript
class ErrorHandler {
  private maxRetries = 3
  private retryDelay = 1000 // 1秒

  async handleItemError(item: UnifiedMediaItem): Promise<void> {
    const retryCount = (item as any).retryCount || 0

    if (retryCount < this.maxRetries) {
      // 延迟重试
      await this.delay(this.retryDelay * Math.pow(2, retryCount)) // 指数退避

      item.transitionTo('pending', {
        type: 'retry',
        timestamp: Date.now(),
        source: 'ErrorHandler',
        reason: '自动重试',
        retryCount: retryCount + 1,
        retryDelay: this.retryDelay * Math.pow(2, retryCount)
      })

      // 重新开始处理
      await this.restartProcessing(item)
    } else {
      console.error(`媒体项目 ${item.id} 重试次数已达上限`)
    }
  }

  private async restartProcessing(item: UnifiedMediaItem): Promise<void> {
    if (item.source.type === 'remote') {
      const downloadManager = new DownloadManager()
      await downloadManager.startDownload(item)
    }

    const webavProcessor = new WebAVProcessor()
    await webavProcessor.parseFile(item)
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

## 工具函数示例

```typescript
// 类型守卫函数 - 重新导出数据源类型守卫
export { isUserSelectedSource, isProjectFileSource, isRemoteSource } from './数据源扩展类型设计'

export function isReadyItem(item: UnifiedMediaItem): boolean {
  return item.mediaStatus === 'ready'
}

export function isProcessingItem(item: UnifiedMediaItem): boolean {
  return ['asyncprocessing', 'webavdecoding'].includes(item.mediaStatus)
}

// 状态检查函数
export function canRetry(item: UnifiedMediaItem): boolean {
  return ['error', 'cancelled'].includes(item.mediaStatus)
}

export function canCancel(item: UnifiedMediaItem): boolean {
  return item.mediaStatus === 'asyncprocessing'
}

// 进度计算函数
export function calculateOverallProgress(items: UnifiedMediaItem[]): number {
  if (items.length === 0) return 0

  let totalProgress = 0
  for (const item of items) {
    switch (item.mediaStatus) {
      case 'ready':
        totalProgress += 100
        break
      case 'asyncprocessing':
        if (isRemoteSource(item.source)) {
          totalProgress += item.source.getProgress() * 0.8 // 下载占80%
        }
        break
      case 'webavdecoding':
        totalProgress += 80 // 解析阶段算80%
        break
      default:
        totalProgress += 0
    }
  }

  return Math.round(totalProgress / items.length)
}

// ID生成函数
export function generateId(): string {
  return `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}
```

## 总结

这些使用示例展示了统一媒体类型设计的实际应用：

1. **类型安全**：通过联合类型的上下文设计，确保编译时和运行时的类型安全
2. **状态管理**：清晰的状态转换流程，便于理解和维护
3. **错误处理**：完善的错误处理和重试机制
4. **UI集成**：易于与前端框架集成的响应式设计
5. **扩展性**：模块化的管理器设计，便于功能扩展
6. **用户体验**：丰富的进度信息和状态反馈
```

### 2. WebAV处理器实现

```typescript
class WebAVProcessor {
  async parseFile(item: UnifiedMediaItem): Promise<void> {
    const file = this.getFileFromItem(item)
    if (!file) {
      throw new Error('无法获取文件对象')
    }
    
    const startTime = Date.now()
    
    try {
      // 检测媒体类型
      const detectedType = await this.detectMediaType(file)
      item.mediaType = detectedType
      
      // 根据类型解析
      const webavObjects: any = {}
      let metadata: any = {}
      
      switch (detectedType) {
        case 'video':
          const mp4Clip = await this.parseVideoFile(file)
          webavObjects.mp4Clip = mp4Clip
          metadata = await this.extractVideoMetadata(mp4Clip)
          webavObjects.thumbnailUrl = await this.generateVideoThumbnail(mp4Clip)
          break
          
        case 'audio':
          const audioClip = await this.parseAudioFile(file)
          webavObjects.audioClip = audioClip
          metadata = await this.extractAudioMetadata(audioClip)
          break
          
        case 'image':
          const imgClip = await this.parseImageFile(file)
          webavObjects.imgClip = imgClip
          metadata = await this.extractImageMetadata(imgClip)
          webavObjects.thumbnailUrl = URL.createObjectURL(file)
          break
          
        default:
          throw new Error(`不支持的媒体类型: ${detectedType}`)
      }
      
      // 更新项目
      item.webav = webavObjects
      item.duration = metadata.duration
      
      // 转换到就绪状态
      item.transitionTo('ready', {
        type: 'parse_completed',
        timestamp: Date.now(),
        source: 'WebAVProcessor',
        reason: 'WebAV解析完成',
        parsedMetadata: {
          duration: metadata.duration,
          resolution: metadata.resolution,
          format: metadata.format,
          bitrate: metadata.bitrate,
          codecInfo: {
            video: metadata.videoCodec,
            audio: metadata.audioCodec
          }
        },
        thumbnailGenerated: !!webavObjects.thumbnailUrl,
        webavObjects,
        parseTime: Date.now() - startTime,
        metadata: {
          objectTypes: Object.keys(webavObjects),
          fileFormat: metadata.format,
          hasVideo: !!webavObjects.mp4Clip,
          hasAudio: !!webavObjects.audioClip
        }
      })
      
    } catch (error) {
      item.transitionTo('error', {
        type: 'error',
        timestamp: Date.now(),
        source: 'WebAVProcessor',
        reason: 'WebAV解析失败',
        errorMessage: `WebAV解析失败: ${error.message}`,
        errorCode: 'WEBAV_PARSE_ERROR',
        errorDetails: error,
        retryable: false,
        retryCount: 0
      })
    }
  }
  
  private getFileFromItem(item: UnifiedMediaItem): File | null {
    if (item.source.type === 'local') {
      return item.source.file
    } else if (item.source.type === 'remote') {
      return item.source.downloadedFile || null
    }
    return null
  }
  
  private async detectMediaType(file: File): Promise<MediaType> {
    const mimeType = file.type
    if (mimeType.startsWith('video/')) return 'video'
    if (mimeType.startsWith('audio/')) return 'audio'
    if (mimeType.startsWith('image/')) return 'image'
    
    // 基于文件扩展名的后备检测
    const extension = file.name.split('.').pop()?.toLowerCase()
    if (['mp4', 'avi', 'mov', 'mkv'].includes(extension || '')) return 'video'
    if (['mp3', 'wav', 'aac', 'flac'].includes(extension || '')) return 'audio'
    if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(extension || '')) return 'image'
    
    return 'unknown'
  }
  
  private async parseVideoFile(file: File): Promise<any> {
    // WebAV视频解析逻辑
    // 这里是示例，实际需要使用WebAV库
    return { type: 'video', file }
  }
  
  private async parseAudioFile(file: File): Promise<any> {
    // WebAV音频解析逻辑
    return { type: 'audio', file }
  }
  
  private async parseImageFile(file: File): Promise<any> {
    // WebAV图片解析逻辑
    return { type: 'image', file }
  }
  
  private async extractVideoMetadata(clip: any): Promise<any> {
    return {
      duration: 120.5,
      resolution: '1920x1080',
      format: 'mp4',
      bitrate: 2500,
      videoCodec: 'h264',
      audioCodec: 'aac'
    }
  }
  
  private async extractAudioMetadata(clip: any): Promise<any> {
    return {
      duration: 180.2,
      format: 'mp3',
      bitrate: 320,
      audioCodec: 'mp3'
    }
  }
  
  private async extractImageMetadata(clip: any): Promise<any> {
    return {
      duration: 0,
      resolution: '1920x1080',
      format: 'jpeg'
    }
  }
  
  private async generateVideoThumbnail(clip: any): Promise<string> {
    // 生成视频缩略图
    return 'blob:thumbnail-url'
  }
}
```
