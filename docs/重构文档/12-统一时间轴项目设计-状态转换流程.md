# 统一时间轴项目设计 - 状态转换流程

## 生命周期总览

### 完整状态机图

```
媒体项目状态 → 时间轴状态 → 时间轴表现形式
├── pending         → loading      → 基础时间范围 + LoadingConfig
├── asyncprocessing → loading      → 下载阶段时间范围
├── webavdecoding   → loading      → 处理阶段时间范围
├── ready           → ready        → 媒体特定时间范围 + 特定媒体Config + Sprite
├── error           → error        → 基础时间范围 + LoadingConfig + 错误信息
├── cancelled       → error        → 取消信息
└── missing         → error        → 缺失文件信息
```

## 详细转换流程

### 流程1：新建时间轴项目

**初始状态建立**

```typescript
sequence:
1. 用户拖拽媒体到时间轴 → TimelineItemManager.createTimelineItem()
2. 创建loading状态项目
3. 自动订阅媒体状态变化
4. 根据媒体当前状态确定初始UI表现

状态映射:
- 任何媒体状态 → 时间轴loading状态
- timeRange类型 → LoadingTimeRange
- config类型 → LoadingConfig
```

### 流程2：正常的成功处理

**完整成功流程**

```typescript
async function normalSuccessFlow() {
  const item = timelineItemManager.createTimelineItem(pendingMedia, 'track1', timeRange)
  
  // Step 1: pending → asyncprocessing
  await mediaItem.updateStatus('asyncprocessing', { progress: 0 })
  // 触发: timelineStatus = 'loading', loadingPhase = 'downloading'
  
  // Step 2: asyncprocessing → webavdecoding  
  await mediaItem.updateStatus('webavdecoding', { progress: 50 })
  // 触发: timelineStatus = 'loading', loadingPhase = 'processing'
  
  // Step 3: webavdecoding → ready
  await mediaItem.updateStatus('ready', { webavObjects: videoObjects })
  
  // Step 4: 时间轴项目准备就绪sprite
  const sprite = await spriteLifecycleManager.createSpriteForTimelineItem(item, mediaItem)
  
  // 触发: timelineStatus = 'ready', 完整媒体配置, sprite对象
  return { success: true, sprite }
}
```

### 流程3：失败处理

**错误转换路径**

```typescript
async function errorHandlingFlow() {
  // 从ready状态收到错误
  if (mediaItem.mediaStatus === 'error') {
    timelineItem.transitionTo('error', {
      status: 'error',
      errorMessage: mediaItem.errorMessage,
      errorCode: mediaItem.errorCode,
      retryable: true,
      lastUpdated: Date.now()
    })
  }
  
  // 从任意状态到错误状态的处理
  const oldStatus = timelineItem.timelineStatus
  timelineItem.sprite = undefined  // 清理sprite资源
  timelineItem.config = loadingConfig  // 降级到基础配置
  timelineItem.timeRange = loadingTimeRange  // 降级到基础时间范围
}
```

### 流程4：重试流程

**错误状态的重新加载**

```typescript
async function retryFlow(timelineItem: UnifiedTimelineItem) {
  const mediaItem = mediaManager.find(timelineItem.mediaItemId)
  
  if (!mediaItem) return { success: false, reason: '未找到媒体项目' }
  
  // Step 1: 转换回loading状态
  timelineItem.transitionTo('loading', {
    status: 'loading',
    loadingPhase: 'pending', 
    progress: 0,
    lastUpdated: Date.now()
  })
  
  // Step 2: 重新处理媒体项目
  try {
    await mediaManager.retryMediaProcessing(mediaItem.id)
    
    // Step 3: 成功后的sprite创建
    const sprite = await spriteLifecycleManager.createSpriteForTimelineItem(
      timelineItem, 
      mediaItem
    )
    
    return { success: true, sprite }
  } catch (error) {
    // 回到错误状态但保留信息
    timelineItem.transitionTo('error', {
      status: 'error',
      errorMessage: error.message,
      errorCode: 'RETRY_FAILED',
      retryable: error.retryable ?? true,
      lastUpdated: Date.now()
    })
    
    return { success: false, error }
  }
}
```

## 状态同步机制

### 媒体项目→时间轴项目状态转播

```typescript
class TimelineItemManager {
  createTimelineItem(
    mediaItem: UnifiedMediaItem,
    trackId: string,
    initialTimeRange: BaseTimeRange
  ): UnifiedTimelineItem {
    const item = new UnifiedTimelineItemImpl({
      id: generateId(),
      mediaItemId: mediaItem.id,
      trackId,
      timelineStatus: this.mapMediaStatus(mediaItem.mediaStatus),
      ...
    })
    
    // 建立双向同步订阅
    this.subscribeToMediaStatus(mediaItem, item)
    
    return item
  }
  
  private subscribeToMediaStatus(
    mediaItem: UnifiedMediaItem, 
    timelineItem: UnifiedTimelineItem
  ): () => void {
    const unsubscribe = mediaItem.onStatusChanged?.((old, new) => {
      const newStatus = this.mapMediaStatus(new)
      
      if (timelineItem.canTransitionTo(newStatus)) {
        timelineItem.transitionTo(newStatus, createStatusDetail(new), createContext(new))
      }
    })
    
    return unsubscribe  // 返回清理函数
  }
}
```

### 状态转换动画控制

```typescript
const STATE_TRANSITION_ANIMATIONS = {
  'loading→ready': 'fadeIn',
  'loading→error': 'shake',
  'error→loading': 'pulse',
  'ready→error': 'shake',
}

class TimelineAnimator {
  prepareStateTransition(
    item: UnifiedTimelineItem,
    newStatus: TimelineItemStatus
  ): AnimationConfig | undefined {
    const transitionKey = `${item.timelineStatus}→${newStatus}`
    return STATE_TRANSITION_ANIMATIONS[transitionKey]
  }
  
  animateTransition(item: UnifiedTimelineItem, animation: AnimationConfig) {
    // 实际动画逻辑...
  }
}
```

## 并发状态处理

### 快速状态变化场景

```typescript
// 处理极快速状态变化（pending→ready可能在几毫秒内完成）
class RobustStatusHandler {
  private pendingTransitions: Map<string, NodeJS.Timeout> = new Map()
  
  handleMediaStatusChange(
    itemId: string,
    oldStatus: MediaStatus,
    newStatus: MediaStatus
  ) {
    // 清除可能存在的pending转换
    const timeout = this.pendingTransitions.get(itemId)
    if (timeout) {
      clearTimeout(timeout)
      this.pendingTransitions.delete(itemId)
    }
    
    // 快速状态变化的处理策略
    switch (`${oldStatus}→${newStatus}`) {
      case 'pending→ready':
        // 使用微过渡，确保UI感知变化
        this.fastTransition(itemId, 'loading', () => {
          // 0ms延迟后立即ready
          setTimeout(() => this.finalizeReady(itemId), 0)
        })
        break
        
      case 'webavdecoding→error':
        // 直接进入错误状态，无动画
        this.immediateTransition(itemId, 'error')
        break
    }
  }
}
```

## 错误状态详细分类

### 错误状态映射表

```typescript
const ERROR_STATUS_MAPPING: Record<MediaStatus, TimelineErrorState> = {
  error: {
    category: 'processing_error',
    retryable: true,
    uiBehavior: 'show_retry',
    message: '媒体处理失败，可重试'
  },
  cancelled: {
    category: 'user_cancelled', 
    retryable: true,
    uiBehavior: 'show_retry',
    message: '用户取消了处理'
  },
  missing: {
    category: 'file_not_found',
    retryable: false,
    uiBehavior: 'show_missing',
    message: '文件已删除或移动'
  }
}

const getErrorPresentation = (mediaStatus: MediaStatus): TimelineErrorState => {
  return ERROR_STATUS_MAPPING[mediaStatus] ?? ERROR_STATUS_MAPPING.error
}
```

## 资源清理流程

### 状态降级时的资源释放

```typescript
class ResourceCleanupManager {
  onStateDowngrade(
    item: UnifiedTimelineItem,
    fromStatus: TimelineItemStatus,
    toStatus: TimelineItemStatus
  ) {
    switch (`${fromStatus}→${toStatus}`) {
      case 'ready→loading':
        // 释放sprite资源但保留缓存
        this.releaseSprite(item.sprite, { keepCache: true })
        this.cleanupUIReferences(item.id)
        break
        
      case 'ready→error':
        // 完全清理，释放所有资源
        this.releaseSprite(item.sprite, { keepCache: false })
        this.cleanupWebAVObjects(item.id)
        this.destroyThumbnailBuffer(item.id)
        break
    }
  }
  
  private releaseSprite(sprite: CustomSprite | undefined, options: ReleaseOptions) {
    if (!sprite) return
    
    sprite.destroy()
    
    if (!options.keepCache) {
      spriteCache.delete(sprite.id)
    }
  }
}

interface ReleaseOptions {
  keepCache: boolean
}
```

## 测试验证用例

### 核心状态转换测试

```typescript
// 测试用例1：正常成功流
test('正常媒体处理流程', async () => {
  const item = createTimelineItem(pendingVideo, 'track1', range)
  
  expect(item.timelineStatus).toBe('loading')
  
  mediaItem.updateStatus('ready')
  await createSpriteForTimelineItem(item, mediaItem)
  
  expect(item.timelineStatus).toBe('ready')
  expect(item.sprite).toBeDefined()
  expect(item.config).toMatchObject({ type: 'video' })
})

// 测试用例2：快速状态变化
test('快速pending→ready状态变化', async () => {
  const item = createTimelineItem(alreadyReadyMedia, 'track1', range)
  
  expect(item.timelineStatus).toBe('ready')
  expect(item.sprite).toBeDefined()
})

// 测试用例3：错误状态转换
test('媒体处理错误处理', async () => {
  const item = createTimelineItem(failingMedia, 'track1', range)
  
  mediaItem.updateStatus('error', { errorCode: 'INVALID_FORMAT' })
  
  expect(item.timelineStatus).toBe('error')
  expect(item.sprite).toBeUndefined()
  expect(item.statusDetail.errorCode).toBe('INVALID_FORMAT')
})

// 测试用例4：重试流程
test('错误状态重试', async () => {
  const item = createTimelineItem(failingMedia, 'track1', range)
  
  mediaItem.updateStatus('error')
  
  await retryTimelineItem(item)
  
  expect(item.timelineStatus).toBe('loading')
  
  mediaItem.updateStatus('ready')
  
  expect(item.timelineStatus).toBe('ready')
})
```