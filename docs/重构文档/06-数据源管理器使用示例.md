# 数据源管理器使用示例

## 概述

本文档提供各种数据源管理器的具体使用示例，展示如何在实际应用中使用管理器进行任务调度和资源管理。

## 1. 用户选择文件管理器使用

### 基本使用

```typescript
// 获取管理器实例
const userFileManager = UserSelectedFileManager.getInstance()

// 处理文件选择
const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
fileInput.addEventListener('change', async (e) => {
  const files = Array.from((e.target as HTMLInputElement).files || [])
  
  for (const file of files) {
    // 创建数据源
    const source = new UserSelectedFileSource(file, (source) => {
      console.log(`文件 ${file.name} 状态: ${source.getStatus()}`)
      
      if (source.getStatus() === 'acquired') {
        console.log(`文件验证成功: ${file.name}`)
        // 可以开始使用文件
        processFile(source.getFile()!, source.getUrl()!)
      } else if (source.getStatus() === 'error') {
        console.error(`文件验证失败: ${file.name} - ${source.getError()}`)
        showErrorMessage(`文件 ${file.name} 验证失败: ${source.getError()}`)
      }
    })
    
    // 开始验证
    source.startAcquisition()
  }
})

function processFile(file: File, url: string) {
  console.log(`开始处理文件: ${file.name}`)
  // 添加到媒体项目或时间线
}

function showErrorMessage(message: string) {
  // 显示错误消息给用户
  const errorDiv = document.createElement('div')
  errorDiv.className = 'error-message'
  errorDiv.textContent = message
  document.body.appendChild(errorDiv)
  
  setTimeout(() => {
    document.body.removeChild(errorDiv)
  }, 5000)
}
```

### 批量文件处理

```typescript
class BatchFileProcessor {
  private userFileManager = UserSelectedFileManager.getInstance()
  private processedFiles: Map<string, ProcessResult> = new Map()

  async processBatchFiles(files: File[]): Promise<ProcessResult[]> {
    const results: ProcessResult[] = []
    
    // 创建所有数据源
    const sources = files.map(file => {
      return new UserSelectedFileSource(file, (source) => {
        this.handleFileUpdate(file.name, source)
      })
    })
    
    // 开始处理所有文件
    sources.forEach(source => source.startAcquisition())
    
    // 等待所有文件处理完成
    return new Promise((resolve) => {
      const checkCompletion = () => {
        const completed = sources.filter(source => 
          source.getStatus() === 'acquired' || source.getStatus() === 'error'
        )
        
        if (completed.length === sources.length) {
          // 所有文件处理完成
          const results = sources.map(source => ({
            fileName: source.getSelectedFile().name,
            success: source.getStatus() === 'acquired',
            error: source.getError(),
            file: source.getFile(),
            url: source.getUrl()
          }))
          resolve(results)
        } else {
          setTimeout(checkCompletion, 100)
        }
      }
      
      checkCompletion()
    })
  }

  private handleFileUpdate(fileName: string, source: UserSelectedFileSource) {
    const status = source.getStatus()
    const progress = source.getProgress()
    
    console.log(`${fileName}: ${status} (${progress}%)`)
    
    // 更新UI
    this.updateFileProgress(fileName, status, progress)
  }

  private updateFileProgress(fileName: string, status: string, progress: number) {
    const element = document.getElementById(`file-${this.sanitizeId(fileName)}`)
    if (element) {
      element.innerHTML = `
        <div class="file-item">
          <span class="file-name">${fileName}</span>
          <span class="file-status">${status}</span>
          <div class="progress-bar">
            <div class="progress-fill" style="width: ${progress}%"></div>
          </div>
        </div>
      `
    }
  }

  private sanitizeId(fileName: string): string {
    return fileName.replace(/[^a-zA-Z0-9]/g, '_')
  }

  // 获取管理器统计信息
  getManagerStats() {
    return this.userFileManager.getStats()
  }
}

interface ProcessResult {
  fileName: string
  success: boolean
  error?: string
  file?: File | null
  url?: string | null
}

// 使用示例
const processor = new BatchFileProcessor()

document.getElementById('batch-upload')?.addEventListener('change', async (e) => {
  const files = Array.from((e.target as HTMLInputElement).files || [])
  
  try {
    const results = await processor.processBatchFiles(files)
    
    const successful = results.filter(r => r.success)
    const failed = results.filter(r => !r.success)
    
    console.log(`处理完成: ${successful.length} 成功, ${failed.length} 失败`)
    
    // 显示统计信息
    const stats = processor.getManagerStats()
    console.log('管理器统计:', stats)
    
  } catch (error) {
    console.error('批量处理失败:', error)
  }
})
```

## 2. 工程文件管理器使用

### 工程加载场景

```typescript
class ProjectLoader {
  private projectFileManager = ProjectFileManager.getInstance()
  private missingFiles: ProjectFileSource[] = []

  async loadProject(projectConfig: ProjectConfig): Promise<LoadResult> {
    const results: LoadResult = {
      totalFiles: projectConfig.mediaItems.length,
      loadedFiles: 0,
      missingFiles: 0,
      errors: []
    }

    const sources = projectConfig.mediaItems.map(item => {
      return new ProjectFileSource({
        filePath: item.filePath,
        fileName: item.fileName,
        fileSize: item.fileSize,
        lastModified: item.lastModified
      }, (source) => {
        this.handleProjectFileUpdate(item.fileName, source, results)
      })
    })

    // 开始加载所有文件
    sources.forEach(source => source.startAcquisition())

    // 等待加载完成
    return new Promise((resolve) => {
      const checkCompletion = () => {
        const completed = sources.filter(source => {
          const status = source.getStatus()
          return status === 'acquired' || status === 'missing' || status === 'error'
        })

        if (completed.length === sources.length) {
          resolve(results)
        } else {
          setTimeout(checkCompletion, 100)
        }
      }

      checkCompletion()
    })
  }

  private handleProjectFileUpdate(
    fileName: string, 
    source: ProjectFileSource, 
    results: LoadResult
  ) {
    const status = source.getStatus()
    
    switch (status) {
      case 'acquired':
        results.loadedFiles++
        console.log(`文件加载成功: ${fileName}`)
        break
        
      case 'missing':
        results.missingFiles++
        this.missingFiles.push(source)
        console.log(`文件缺失: ${fileName} - ${source.getError()}`)
        this.showFileRelocateDialog(source)
        break
        
      case 'error':
        results.errors.push(`${fileName}: ${source.getError()}`)
        console.error(`文件加载错误: ${fileName} - ${source.getError()}`)
        break
    }

    this.updateLoadingProgress(results)
  }

  private updateLoadingProgress(results: LoadResult) {
    const total = results.totalFiles
    const completed = results.loadedFiles + results.missingFiles + results.errors.length
    const progress = (completed / total) * 100

    console.log(`加载进度: ${progress.toFixed(1)}% (${completed}/${total})`)
    
    // 更新UI
    const progressElement = document.getElementById('loading-progress')
    if (progressElement) {
      progressElement.innerHTML = `
        <div class="loading-stats">
          <div>总文件: ${total}</div>
          <div>已加载: ${results.loadedFiles}</div>
          <div>缺失: ${results.missingFiles}</div>
          <div>错误: ${results.errors.length}</div>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${progress}%"></div>
        </div>
      `
    }
  }

  private showFileRelocateDialog(source: ProjectFileSource) {
    const fileInfo = source.getFileInfo()
    
    const dialog = document.createElement('div')
    dialog.className = 'relocate-dialog'
    dialog.innerHTML = `
      <div class="dialog-content">
        <h3>文件缺失</h3>
        <p>无法找到文件: ${fileInfo.fileName}</p>
        <p>原路径: ${fileInfo.filePath}</p>
        <button id="relocate-btn">重新定位</button>
        <button id="skip-btn">跳过</button>
      </div>
    `
    
    document.body.appendChild(dialog)
    
    // 重新定位按钮
    dialog.querySelector('#relocate-btn')?.addEventListener('click', () => {
      this.relocateFile(source)
      document.body.removeChild(dialog)
    })
    
    // 跳过按钮
    dialog.querySelector('#skip-btn')?.addEventListener('click', () => {
      document.body.removeChild(dialog)
    })
  }

  private relocateFile(source: ProjectFileSource) {
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = this.getAcceptType(source.getFileInfo().fileName)
    
    input.addEventListener('change', (e) => {
      const newFile = (e.target as HTMLInputElement).files?.[0]
      if (newFile) {
        // 验证文件匹配
        if (this.validateFileMatch(newFile, source.getFileInfo())) {
          source.relocateFile(newFile)
          console.log(`文件重新定位成功: ${source.getFileInfo().fileName}`)
        } else {
          if (confirm('文件信息不匹配，是否仍要使用此文件？')) {
            source.relocateFile(newFile)
          }
        }
      }
    })
    
    input.click()
  }

  private validateFileMatch(file: File, fileInfo: any): boolean {
    // 检查文件名
    if (file.name !== fileInfo.fileName) {
      return false
    }
    
    // 检查文件大小（允许一定误差）
    if (fileInfo.fileSize && Math.abs(file.size - fileInfo.fileSize) > 1024) {
      return false
    }
    
    return true
  }

  private getAcceptType(fileName: string): string {
    const ext = fileName.split('.').pop()?.toLowerCase()
    const typeMap: Record<string, string> = {
      'mp4': 'video/mp4',
      'avi': 'video/avi',
      'mov': 'video/quicktime',
      'mp3': 'audio/mpeg',
      'wav': 'audio/wav',
      'jpg': 'image/jpeg',
      'png': 'image/png'
    }
    
    return typeMap[ext || ''] || '*/*'
  }

  // 获取缺失文件列表
  getMissingFiles(): ProjectFileSource[] {
    return [...this.missingFiles]
  }

  // 清理已完成的任务
  cleanup() {
    this.projectFileManager.cleanupCompletedTasks()
    this.missingFiles = []
  }
}

interface ProjectConfig {
  mediaItems: Array<{
    filePath: string
    fileName: string
    fileSize?: number
    lastModified?: number
  }>
}

interface LoadResult {
  totalFiles: number
  loadedFiles: number
  missingFiles: number
  errors: string[]
}

// 使用示例
const projectLoader = new ProjectLoader()

async function loadProjectFromFile(projectFile: File) {
  try {
    const projectText = await projectFile.text()
    const projectConfig: ProjectConfig = JSON.parse(projectText)
    
    console.log(`开始加载工程，共 ${projectConfig.mediaItems.length} 个文件`)
    
    const result = await projectLoader.loadProject(projectConfig)
    
    console.log('工程加载完成:', result)
    
    if (result.missingFiles > 0) {
      console.log(`有 ${result.missingFiles} 个文件缺失，需要重新定位`)
    }
    
    if (result.errors.length > 0) {
      console.error('加载错误:', result.errors)
    }
    
  } catch (error) {
    console.error('工程加载失败:', error)
  }
}
```

## 3. 远程文件管理器使用

### 单文件下载

```typescript
class RemoteFileDownloader {
  private remoteFileManager = RemoteFileManager.getInstance()
  private activeDownloads: Map<string, RemoteFileSource> = new Map()

  async downloadFile(
    url: string, 
    config: RemoteFileConfig = {}
  ): Promise<DownloadResult> {
    
    return new Promise((resolve, reject) => {
      const source = new RemoteFileSource(url, config, (source) => {
        this.handleDownloadUpdate(url, source, resolve, reject)
      })
      
      this.activeDownloads.set(url, source)
      source.startAcquisition()
    })
  }

  private handleDownloadUpdate(
    url: string,
    source: RemoteFileSource,
    resolve: (result: DownloadResult) => void,
    reject: (error: Error) => void
  ) {
    const status = source.getStatus()
    const progress = source.getProgress()
    const stats = source.getDownloadStats()
    
    // 更新UI
    this.updateDownloadUI(url, status, progress, stats)
    
    switch (status) {
      case 'acquiring':
        console.log(`下载中: ${url} (${progress}%)`)
        if (stats.downloadSpeed) {
          console.log(`下载速度: ${stats.downloadSpeed}`)
        }
        break
        
      case 'acquired':
        console.log(`下载完成: ${url}`)
        this.activeDownloads.delete(url)
        resolve({
          success: true,
          file: source.getFile()!,
          url: source.getUrl()!,
          stats
        })
        break
        
      case 'error':
        console.error(`下载失败: ${url} - ${source.getError()}`)
        this.activeDownloads.delete(url)
        reject(new Error(source.getError() || '下载失败'))
        break
        
      case 'cancelled':
        console.log(`下载已取消: ${url}`)
        this.activeDownloads.delete(url)
        reject(new Error('下载已取消'))
        break
    }
  }

  private updateDownloadUI(
    url: string, 
    status: string, 
    progress: number, 
    stats: any
  ) {
    const urlId = this.getUrlId(url)
    const element = document.getElementById(`download-${urlId}`)
    
    if (element) {
      element.innerHTML = `
        <div class="download-item">
          <div class="download-url">${this.truncateUrl(url)}</div>
          <div class="download-status">${status}</div>
          <div class="download-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${progress}%"></div>
            </div>
            <span class="progress-text">${progress.toFixed(1)}%</span>
          </div>
          <div class="download-stats">
            ${stats.downloadSpeed ? `速度: ${stats.downloadSpeed}` : ''}
            ${stats.totalBytes > 0 ? `大小: ${this.formatBytes(stats.totalBytes)}` : ''}
          </div>
          <div class="download-actions">
            <button onclick="cancelDownload('${url}')">取消</button>
          </div>
        </div>
      `
    }
  }

  cancelDownload(url: string) {
    const source = this.activeDownloads.get(url)
    if (source) {
      source.cancel()
    }
  }

  retryDownload(url: string) {
    const source = this.activeDownloads.get(url)
    if (source) {
      source.retry()
    }
  }

  private getUrlId(url: string): string {
    return btoa(url).replace(/[^a-zA-Z0-9]/g, '')
  }

  private truncateUrl(url: string, maxLength: number = 50): string {
    return url.length > maxLength ? url.substring(0, maxLength) + '...' : url
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes'
    
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  // 获取所有活跃下载
  getActiveDownloads(): string[] {
    return Array.from(this.activeDownloads.keys())
  }

  // 获取管理器统计信息
  getManagerStats() {
    return this.remoteFileManager.getStats()
  }
}

interface DownloadResult {
  success: boolean
  file: File
  url: string
  stats: any
}

// 使用示例
const downloader = new RemoteFileDownloader()

// 下载单个文件
async function downloadSingleFile() {
  try {
    const result = await downloader.downloadFile(
      'https://example.com/video.mp4',
      {
        timeout: 60000,
        retryCount: 3,
        headers: {
          'User-Agent': 'VideoEditor/1.0'
        }
      }
    )
    
    console.log('下载成功:', result)
    // 使用下载的文件
    processDownloadedFile(result.file, result.url)
    
  } catch (error) {
    console.error('下载失败:', error)
    showErrorMessage(`下载失败: ${error.message}`)
  }
}

function processDownloadedFile(file: File, url: string) {
  console.log(`处理下载的文件: ${file.name}`)
  // 添加到媒体项目
}

// 全局取消下载函数（供UI调用）
function cancelDownload(url: string) {
  downloader.cancelDownload(url)
}
```

## 4. 管理器监控和统计

### 全局管理器监控

```typescript
class ManagerMonitor {
  private registry = DataSourceManagerRegistry.getInstance()
  private updateInterval: number = 1000
  private intervalId?: number

  startMonitoring() {
    this.intervalId = window.setInterval(() => {
      this.updateStats()
    }, this.updateInterval)
  }

  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = undefined
    }
  }

  private updateStats() {
    const globalStats = this.registry.getGlobalStats()
    
    console.log('=== 管理器统计 ===')
    console.log(`总管理器数: ${globalStats.totalManagers}`)
    
    globalStats.managerStats.forEach((stats, type) => {
      console.log(`${type}:`, {
        总任务: stats.totalTasks,
        运行中: stats.runningTasks,
        已完成: stats.completedTasks,
        失败: stats.failedTasks,
        并发限制: `${stats.currentRunningTasks}/${stats.maxConcurrentTasks}`
      })
    })
    
    // 更新UI
    this.updateMonitorUI(globalStats)
  }

  private updateMonitorUI(globalStats: any) {
    const monitorElement = document.getElementById('manager-monitor')
    if (!monitorElement) return
    
    let html = '<div class="manager-stats">'
    html += `<h3>管理器监控 (${globalStats.totalManagers} 个管理器)</h3>`
    
    globalStats.managerStats.forEach((stats: any, type: string) => {
      html += `
        <div class="manager-stat-item">
          <h4>${type}</h4>
          <div class="stat-grid">
            <div>总任务: ${stats.totalTasks}</div>
            <div>运行中: ${stats.runningTasks}</div>
            <div>已完成: ${stats.completedTasks}</div>
            <div>失败: ${stats.failedTasks}</div>
            <div>并发: ${stats.currentRunningTasks}/${stats.maxConcurrentTasks}</div>
          </div>
        </div>
      `
    })
    
    html += '</div>'
    monitorElement.innerHTML = html
  }

  // 清理所有管理器的已完成任务
  cleanupAll() {
    this.registry.cleanupAllCompletedTasks()
    console.log('已清理所有管理器的已完成任务')
  }

  // 调整管理器并发设置
  adjustConcurrency(managerType: string, maxConcurrent: number) {
    const manager = this.registry.getManager(managerType)
    if (manager) {
      manager.setMaxConcurrentTasks(maxConcurrent)
      console.log(`已调整 ${managerType} 管理器并发数为 ${maxConcurrent}`)
    }
  }
}

// 使用示例
const monitor = new ManagerMonitor()

// 开始监控
monitor.startMonitoring()

// 定期清理
setInterval(() => {
  monitor.cleanupAll()
}, 60000) // 每分钟清理一次

// 根据系统负载调整并发
function adjustConcurrencyBasedOnLoad() {
  const memoryInfo = (performance as any).memory
  if (memoryInfo) {
    const memoryUsage = memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize
    
    if (memoryUsage > 0.8) {
      // 内存使用率高，降低并发
      monitor.adjustConcurrency('remote', 2)
      monitor.adjustConcurrency('user-selected', 5)
    } else if (memoryUsage < 0.5) {
      // 内存使用率低，提高并发
      monitor.adjustConcurrency('remote', 5)
      monitor.adjustConcurrency('user-selected', 10)
    }
  }
}

// 每30秒检查一次系统负载
setInterval(adjustConcurrencyBasedOnLoad, 30000)
```

这些示例展示了如何在实际应用中使用各种数据源管理器，包括错误处理、进度跟踪、资源管理和性能优化等方面的最佳实践。
