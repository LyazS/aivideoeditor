# 统一时间轴项目设计 - 使用示例（响应式重构版）

## 概述

基于"核心数据 + 行为分离"的重构方案，统一时间轴项目采用与数据源、媒体项目一致的响应式架构模式，彻底解决Vue3响应式支持问题。

## 重构背景

### 架构一致性问题
当前统一时间轴项目使用类模式，与已重构的数据源、媒体项目的"核心数据 + 行为分离"模式不一致：
- 数据源和媒体项目：已采用响应式数据对象 + 无状态函数
- 时间轴项目：仍使用类实例，存在响应式支持问题

### 解决方案
采用统一的"核心数据 + 行为分离"模式：
- **核心数据**：纯粹的响应式状态对象，使用 `reactive()` 包装
- **行为函数**：无状态的纯函数，操作数据对象
- **查询函数**：纯函数，用于状态查询和计算

## 响应式数据结构设计

### 1. 统一时间轴项目数据接口

```typescript
import { reactive } from 'vue'
import type { MediaType } from '@/types'
import type { UnifiedDataSourceData } from '@/unified/sources'

/**
 * 统一时间轴项目数据接口 - 纯响应式状态对象
 */
export interface UnifiedTimelineItemData {
  // ==================== 核心属性 ====================
  readonly id: string
  mediaItemId: string // 关联的统一媒体项目ID
  trackId?: string

  // ==================== 状态管理 ====================
  timelineStatus: TimelineItemStatus // 仅3状态：ready|loading|error

  // ==================== 状态上下文 - 动态状态信息 ====================
  statusContext?: TimelineStatusContext // 承载当前状态的详细信息和UI展示数据

  // ==================== 媒体信息 ====================
  mediaType: MediaType | 'unknown' // 从关联的媒体项目同步

  // ==================== 时间范围 ====================
  timeRange: {
    timelineStartTime: number // 时间轴开始时间（帧数）
    timelineEndTime: number   // 时间轴结束时间（帧数）
  }

  // ==================== 基础配置 ====================
  config: BasicTimelineConfig // 静态配置信息

  // ==================== Sprite引用 ====================
  spriteId?: string // Sprite ID，由SpriteLifecycleManager管理
}
```

## 类型安全使用示例

### 1. 基本状态查询示例

```typescript
/**
 * 类型安全的状态查询示例
 */
function displayTimelineStatus(data: UnifiedTimelineItemData) {
  const context = data.statusContext
  if (!context) return

  switch (context.stage) {
    case 'downloading':
      // TypeScript 知道这里是 DownloadContext
      console.log(`下载进度: ${context.progress.percent}%`)
      if (context.downloadSpeed) {
        console.log(`下载速度: ${context.downloadSpeed}`)
      }
      break

    case 'parsing':
      // TypeScript 知道这里是 ParseContext
      console.log(`解析进度: ${context.progress.percent}%`)
      if (context.currentStep) {
        console.log(`当前步骤: ${context.currentStep}`)
      }
      break

    case 'error':
      // TypeScript 知道这里是 ErrorContext
      console.log(`错误: ${context.error.message}`)
      if (context.error.recoverable) {
        console.log('可以重试')
      }
      break
  }
}
```

### 2. 响应式行为函数示例

```typescript
// ==================== 工厂函数 ====================

/**
 * 创建响应式时间轴项目数据对象
 */
export function createTimelineItemData(options: {
  mediaItemId: string
  trackId?: string
  timeRange: { timelineStartTime: number; timelineEndTime: number }
  config: BasicTimelineConfig
  mediaType?: MediaType
}): UnifiedTimelineItemData {
  return reactive({
    id: generateUUID4(),
    mediaItemId: options.mediaItemId,
    trackId: options.trackId,
    timelineStatus: 'loading' as TimelineItemStatus,
    statusContext: TIMELINE_CONTEXT_TEMPLATES.downloadStart(),
    mediaType: options.mediaType || 'unknown',
    timeRange: options.timeRange,
    config: options.config
  })
}

// ==================== 状态转换行为函数 ====================

/**
 * 状态转换行为函数 - 无状态纯函数
 * 基于3状态 + 类型安全 TimelineStatusContext 的转换
 */
export async function transitionTimelineStatus(
  data: UnifiedTimelineItemData,
  newStatus: TimelineItemStatus,
  context?: TimelineStatusContext
): Promise<void> {
  if (!canTransitionTo(data, newStatus)) {
    throw new Error(`Invalid timeline transition: ${data.timelineStatus} → ${newStatus}`)
  }

  const oldStatus = data.timelineStatus
  data.timelineStatus = newStatus // ✅ 自动触发响应式更新
  data.statusContext = context // 统一存储所有差异信息

  // 精灵生命周期管理 - 更清晰的3分支
  await handleSpriteLifecycle(data, oldStatus, newStatus)

  console.log(`✅ 时间轴项目状态转换: ${oldStatus} → ${newStatus}`, context)
}

/**
 * Sprite生命周期管理函数
 */
async function handleSpriteLifecycle(
  data: UnifiedTimelineItemData,
  oldStatus: TimelineItemStatus,
  newStatus: TimelineItemStatus
): Promise<void> {
  switch (newStatus) {
    case 'ready':
      // 只在ready时创建sprite，所有准备工作已完成
      if (oldStatus !== 'ready') {
        await createSprite(data)
      }
      break

    case 'loading':           // 保持现状不变
    case 'error':            // 清理资源
    default:
      if (oldStatus === 'ready') {
        await destroySprite(data)
      }
  }
}

/**
 * 创建Sprite函数
 */
async function createSprite(data: UnifiedTimelineItemData): Promise<void> {
  // 类型安全的上下文检查
  if (!data.statusContext || !TimelineContextUtils.isReady(data.statusContext)) {
    throw new Error('缺少就绪状态的媒体元数据')
  }

  // 获取关联的媒体项目
  const mediaItem = await getAssociatedMediaItem(data.mediaItemId)
  if (!mediaItem) {
    throw new Error('无法找到关联的媒体项目')
  }

  // 通过 SpriteLifecycleManager 创建并添加 Sprite
  const spriteId = await SpriteLifecycleManager.createAndAddSprite(
    mediaItem,
    data,
    data.statusContext as ReadyContext
  )

  data.spriteId = spriteId // ✅ 响应式更新
}

/**
 * 销毁Sprite函数
 */
async function destroySprite(data: UnifiedTimelineItemData): Promise<void> {
  if (!data.spriteId) {
    return
  }

  // 通过 SpriteLifecycleManager 移除 Sprite（AVCanvas 会自动销毁）
  await SpriteLifecycleManager.removeSprite(data.spriteId)
  data.spriteId = undefined // ✅ 响应式更新
}

// ==================== 查询函数 ====================

/**
 * 状态转换验证函数
 */
export function canTransitionTo(
  data: UnifiedTimelineItemData,
  newStatus: TimelineItemStatus
): boolean {
  // 3状态间的简单规则
  const allowed = VALID_TIMELINE_TRANSITIONS[data.timelineStatus]
  return allowed?.includes(newStatus) ?? false
}

// ==================== 便捷操作函数 ====================

/**
 * 开始下载
 */
export function startDownload(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'loading', TIMELINE_CONTEXT_TEMPLATES.downloadStart())
}

/**
 * 更新下载进度
 */
export function updateDownloadProgress(
  data: UnifiedTimelineItemData,
  percent: number,
  speed?: string
): Promise<void> {
  return transitionTimelineStatus(data, 'loading', TIMELINE_CONTEXT_TEMPLATES.downloadProgress(percent, speed))
}

/**
 * 开始解析
 */
export function startParsing(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'loading', TIMELINE_CONTEXT_TEMPLATES.parseStart())
}

/**
 * 设置为就绪状态
 */
export function setReady(
  data: UnifiedTimelineItemData,
  metadata?: ReadyContext['metadata']
): Promise<void> {
  return transitionTimelineStatus(data, 'ready', TIMELINE_CONTEXT_TEMPLATES.ready(metadata))
}

/**
 * 设置错误状态
 */
export function setError(
  data: UnifiedTimelineItemData,
  code: string,
  message: string,
  recoverable = true
): Promise<void> {
  return transitionTimelineStatus(data, 'error', TIMELINE_CONTEXT_TEMPLATES.error(code, message, recoverable))
}
```

## 响应式状态转换流程示例

### 1. 本地文件处理流程（响应式版本）

```typescript
// 用户拖拽本地文件到时间轴
async function handleLocalFileDrop(file: File, trackId: string) {
  // 1. 创建响应式媒体项目数据
  const mediaData = createMediaItemData({
    source: createUserSelectedFileSourceData(file),
    mediaType: detectMediaType(file)
  })

  // 2. 创建响应式时间轴项目数据
  const timelineData = createTimelineItemData({
    mediaItemId: mediaData.id,
    trackId,
    timeRange: { timelineStartTime: 0, timelineEndTime: 300 }, // 默认5秒
    config: createBasicTimelineConfig(file.name)
  })

  // 3. 开始媒体解析（自动触发UI更新）
  await startMediaProcessing(mediaData)

  // 4. 监听媒体状态变化，自动同步到时间轴
  watchMediaStatus(mediaData, timelineData)
}

// 响应式状态同步
function watchMediaStatus(
  mediaData: UnifiedMediaItemData,
  timelineData: UnifiedTimelineItemData
) {
  watch(() => mediaData.mediaStatus, async (newStatus) => {
    const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

    if (timelineData.timelineStatus !== targetTimelineStatus) {
      const context = createTimelineContextFromMedia(mediaData)
      await transitionTimelineStatus(timelineData, targetTimelineStatus, context)
    }
  }, { immediate: true })
}
```

**响应式流程特点**：
- ✅ **自动UI更新**：所有状态变化自动触发Vue组件重新渲染
- ✅ **类型安全**：完整的TypeScript类型检查
- ✅ **状态同步**：媒体状态自动映射到时间轴状态
- ✅ **无需回调**：不需要手动触发UI更新

### 2. 远程文件下载流程（响应式版本）

```typescript
// 输入远程URL创建时间轴项目
async function handleRemoteUrlAdd(url: string, trackId: string) {
  // 1. 创建响应式数据对象
  const mediaData = createMediaItemData({
    source: createRemoteFileSourceData(url),
    mediaType: 'unknown'
  })

  const timelineData = createTimelineItemData({
    mediaItemId: mediaData.id,
    trackId,
    timeRange: { timelineStartTime: 0, timelineEndTime: 300 },
    config: createBasicTimelineConfig(extractFilename(url))
  })

  // 2. 开始下载（状态变化自动反映到UI）
  await startDownload(timelineData)

  // 3. 监听下载进度（自动更新进度条）
  watchDownloadProgress(mediaData, timelineData)

  // 4. 下载完成后自动开始解析
  watch(() => mediaData.source.status, async (status) => {
    if (status === 'acquired') {
      await startParsing(timelineData)
      await startMediaProcessing(mediaData)
    }
  })
}

// 进度监听函数
function watchDownloadProgress(
  mediaData: UnifiedMediaItemData,
  timelineData: UnifiedTimelineItemData
) {
  watch(() => mediaData.source.progress, (progress) => {
    // 自动更新下载进度（触发UI更新）
    updateDownloadProgress(timelineData, progress, mediaData.source.downloadSpeed)
  })
}
```

**响应式流程特点**：
- ✅ **实时进度**：下载进度自动更新到UI组件
- ✅ **状态驱动**：基于状态变化自动执行后续操作
- ✅ **错误处理**：网络错误自动反映到时间轴状态
- ✅ **用户体验**：无需手动刷新，状态变化立即可见

### 3. 项目加载流程（响应式版本）

```typescript
// 加载项目时恢复时间轴项目
async function loadProjectTimelineItems(projectConfig: ProjectConfig) {
  const timelineItems: UnifiedTimelineItemData[] = []

  for (const itemConfig of projectConfig.timeline.timelineItems) {
    // 1. 创建响应式时间轴数据
    const timelineData = createTimelineItemData({
      mediaItemId: itemConfig.mediaItemId,
      trackId: itemConfig.trackId,
      timeRange: itemConfig.timeRange,
      config: itemConfig.config
    })

    // 2. 检查关联媒体项目状态
    const mediaData = await getMediaItemData(itemConfig.mediaItemId)

    if (mediaData) {
      // 媒体项目存在，同步状态
      const timelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaData.mediaStatus]
      await transitionTimelineStatus(timelineData, timelineStatus)

      // 建立状态同步
      watchMediaStatus(mediaData, timelineData)
    } else {
      // 媒体项目不存在，标记为错误
      await setError(timelineData, 'MEDIA_MISSING', '关联的媒体项目不存在')
    }

    timelineItems.push(timelineData)
  }

  return timelineItems
}
```

**响应式流程特点**：
- ✅ **状态恢复**：自动恢复时间轴项目的正确状态
- ✅ **依赖检查**：自动验证媒体项目依赖关系
- ✅ **错误标记**：缺失文件自动标记为错误状态
- ✅ **实时同步**：加载后继续保持状态同步

## 响应式Sprite生命周期管理

### 1. 响应式Sprite管理器

```typescript
/**
 * 响应式Sprite生命周期管理器
 * 基于数据驱动的Sprite管理，与响应式时间轴项目数据配合
 */
export class SpriteLifecycleManager {
  private avCanvas: AVCanvas
  private spriteRegistry = new Map<string, Raw<CustomSprite>>() // spriteId -> sprite映射

  constructor(avCanvas: AVCanvas) {
    this.avCanvas = avCanvas
  }

  /**
   * 创建并添加 Sprite 到 AVCanvas
   * 返回spriteId供时间轴项目数据引用
   */
  async createAndAddSprite(
    mediaData: UnifiedMediaItemData,
    timelineData: UnifiedTimelineItemData,
    context?: ReadyContext
  ): Promise<string> {
    const { mediaType, webav } = mediaData

    if (!webav) {
      throw new Error('媒体项目WebAV对象未就绪')
    }

    // 生成唯一的spriteId
    const spriteId = generateUUID4()

    // 检查是否已存在 Sprite
    if (timelineData.spriteId && this.spriteRegistry.has(timelineData.spriteId)) {
      console.warn(`时间轴项目 ${timelineData.id} 的 Sprite 已存在，先移除旧的`)
      await this.removeSprite(timelineData.spriteId)
    }

    let sprite: Raw<CustomSprite>

    // 根据媒体类型创建对应的 Sprite
    switch (mediaType) {
      case 'video':
        if (!webav.mp4Clip) throw new Error('视频WebAV对象缺失')
        sprite = new VideoVisibleSprite(webav.mp4Clip)
        break

      case 'image':
        if (!webav.imgClip) throw new Error('图片WebAV对象缺失')
        sprite = new ImageVisibleSprite(webav.imgClip)
        break

      case 'audio':
        if (!webav.audioClip) throw new Error('音频WebAV对象缺失')
        sprite = new AudioVisibleSprite(webav.audioClip)
        break

      default:
        throw new Error(`不支持的媒体类型: ${mediaType}`)
    }

    // 设置 Sprite 的基础属性
    await this.setupSpriteProperties(sprite, timelineData)

    // 添加到 AVCanvas
    await this.avCanvas.addSprite(sprite)

    // 注册到管理器
    this.spriteRegistry.set(spriteId, sprite)

    console.log(`✅ Sprite 已创建并添加到 AVCanvas: ${spriteId} (${mediaType})`)

    return spriteId
  }

  /**
   * 从 AVCanvas 移除 Sprite（AVCanvas 会自动销毁）
   */
  async removeSprite(spriteId: string): Promise<void> {
    const sprite = this.spriteRegistry.get(spriteId)
    if (!sprite) {
      console.warn(`未找到 Sprite: ${spriteId}`)
      return
    }

    try {
      // 从 AVCanvas 移除（AVCanvas 会自动销毁 Sprite）
      await this.avCanvas.removeSprite(sprite)

      // 从注册表移除
      this.spriteRegistry.delete(spriteId)

      console.log(`🗑️ Sprite 已从 AVCanvas 移除: ${spriteId}`)
    } catch (error) {
      console.error(`❌ Sprite 移除失败: ${spriteId}`, error)
      throw error
    }
  }

  /**
   * 设置Sprite基础属性
   */
  private async setupSpriteProperties(
    sprite: Raw<CustomSprite>,
    timelineData: UnifiedTimelineItemData
  ): Promise<void> {
    // 设置时间范围
    sprite.setTimeRange({
      timelineStartTime: timelineData.timeRange.timelineStartTime,
      timelineEndTime: timelineData.timeRange.timelineEndTime
    })

    // 设置基础变换属性
    const config = timelineData.config
    if (config.transform) {
      sprite.setTransform(config.transform)
    }

    // 设置其他属性...
  }

  /**
   * 获取Sprite实例（用于直接操作）
   */
  getSprite(spriteId: string): Raw<CustomSprite> | undefined {
    return this.spriteRegistry.get(spriteId)
  }

  /**
   * 更新Sprite属性（响应式更新）
   */
  async updateSpriteProperties(
    spriteId: string,
    updates: Partial<{
      timeRange: { timelineStartTime: number; timelineEndTime: number }
      transform: TransformData
      opacity: number
    }>
  ): Promise<void> {
    const sprite = this.spriteRegistry.get(spriteId)
    if (!sprite) {
      console.warn(`未找到 Sprite: ${spriteId}`)
      return
    }

    if (updates.timeRange) {
      sprite.setTimeRange(updates.timeRange)
    }

    if (updates.transform) {
      sprite.setTransform(updates.transform)
    }

    if (updates.opacity !== undefined) {
      sprite.setOpacity(updates.opacity)
    }
  }
}
```

### 2. 响应式状态同步管理

```typescript
/**
 * 响应式时间轴项目与媒体项目的状态同步管理器
 * 基于Vue3的watch机制实现自动状态同步
 */
export class TimelineMediaSyncManager {
  private timelineItems = new Map<string, UnifiedTimelineItemData>()
  private mediaItems = new Map<string, UnifiedMediaItemData>()
  private watchStopHandles = new Map<string, WatchStopHandle>() // 用于清理watch

  /**
   * 注册时间轴项目，建立与媒体项目的响应式关联
   */
  registerTimelineItem(timelineData: UnifiedTimelineItemData) {
    this.timelineItems.set(timelineData.id, timelineData)

    // 检查关联媒体项目的状态
    const mediaData = this.mediaItems.get(timelineData.mediaItemId)
    if (mediaData) {
      // 验证MediaItem是否ready
      if (mediaData.mediaStatus !== 'ready') {
        console.warn(`⚠️ TimelineItem ${timelineData.id} 关联的MediaItem ${mediaData.id} 尚未ready`)
      }
      this.setupMediaStatusSync(timelineData, mediaData)
    } else {
      console.error(`❌ TimelineItem ${timelineData.id} 找不到关联的MediaItem ${timelineData.mediaItemId}`)
    }
  }

  /**
   * 建立媒体项目状态到时间轴项目状态的响应式同步
   */
  private setupMediaStatusSync(
    timelineData: UnifiedTimelineItemData,
    mediaData: UnifiedMediaItemData
  ) {
    // 使用Vue3的watch建立响应式同步
    const stopHandle = watch(
      () => mediaData.mediaStatus,
      async (newStatus, oldStatus) => {
        const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

        if (timelineData.timelineStatus !== targetTimelineStatus) {
          // 创建时间轴转换上下文
          const timelineContext = this.createTimelineContext(mediaData)

          // 触发时间轴项目状态转换（自动触发UI更新）
          await transitionTimelineStatus(timelineData, targetTimelineStatus, timelineContext)

          console.log(`🔄 状态同步: MediaItem(${newStatus}) → TimelineItem(${targetTimelineStatus})`)
        }
      },
      { immediate: true } // 立即执行一次同步当前状态
    )

    // 保存停止句柄，用于清理
    this.watchStopHandles.set(timelineData.id, stopHandle)
  }

  /**
   * 创建时间轴上下文从媒体数据
   */
  private createTimelineContext(mediaData: UnifiedMediaItemData): TimelineStatusContext | undefined {
    switch (mediaData.mediaStatus) {
      case 'pending':
        return TIMELINE_CONTEXT_TEMPLATES.downloadStart()

      case 'asyncprocessing':
        // 根据数据源状态创建不同的上下文
        if (mediaData.source.status === 'acquiring') {
          return TIMELINE_CONTEXT_TEMPLATES.downloadProgress(
            mediaData.source.progress,
            mediaData.source.downloadSpeed
          )
        }
        return TIMELINE_CONTEXT_TEMPLATES.parseStart()

      case 'webavdecoding':
        return TIMELINE_CONTEXT_TEMPLATES.parseStart()

      case 'ready':
        return TIMELINE_CONTEXT_TEMPLATES.ready({
          duration: mediaData.duration,
          format: mediaData.format || 'unknown'
        })

      case 'error':
        return TIMELINE_CONTEXT_TEMPLATES.error(
          'MEDIA_ERROR',
          mediaData.source.errorMessage || '媒体处理失败'
        )

      default:
        return undefined
    }
  }

  /**
   * 响应式时间轴项目工厂方法
   * 确保只有ready状态的MediaItem才能直接创建ready的TimelineItem
   */
  createTimelineItem(
    mediaItemId: string,
    trackId: string,
    timeRange: { timelineStartTime: number; timelineEndTime: number },
    config: BasicTimelineConfig
  ): UnifiedTimelineItemData | null {
    const mediaData = this.mediaItems.get(mediaItemId)

    if (!mediaData) {
      console.error(`❌ 找不到MediaItem: ${mediaItemId}`)
      return null
    }

    // 创建响应式TimelineItem数据
    const timelineData = createTimelineItemData({
      mediaItemId,
      trackId,
      timeRange,
      config,
      mediaType: mediaData.mediaType
    })

    // 根据MediaItem状态设置初始状态
    const initialStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaData.mediaStatus]
    const initialContext = this.createTimelineContext(mediaData)

    // 同步设置初始状态（不需要await，因为是同步操作）
    timelineData.timelineStatus = initialStatus
    timelineData.statusContext = initialContext

    // 注册到管理器（建立响应式同步）
    this.registerTimelineItem(timelineData)

    console.log(`✅ 创建时间轴项目: ${timelineData.id}, 初始状态: ${initialStatus}`)

    return timelineData
  }

  /**
   * 注册媒体项目
   */
  registerMediaItem(mediaData: UnifiedMediaItemData) {
    this.mediaItems.set(mediaData.id, mediaData)
  }

  /**
   * 清理时间轴项目（停止响应式监听）
   */
  unregisterTimelineItem(timelineId: string) {
    // 停止watch监听
    const stopHandle = this.watchStopHandles.get(timelineId)
    if (stopHandle) {
      stopHandle()
      this.watchStopHandles.delete(timelineId)
    }

    // 从注册表移除
    this.timelineItems.delete(timelineId)

    console.log(`🗑️ 清理时间轴项目: ${timelineId}`)
  }
}
```

## Vue组件中的使用示例

### 1. 时间轴项目组件

```vue
<template>
  <div class="timeline-item" :class="statusClass">
    <!-- 基础信息显示 -->
    <div class="item-header">
      <span class="item-name">{{ timelineData.config.name }}</span>
      <span class="item-status">{{ statusText }}</span>
    </div>

    <!-- 进度显示 -->
    <div v-if="showProgress" class="progress-bar">
      <div
        class="progress-fill"
        :style="{ width: `${progressPercent}%` }"
      ></div>
      <span class="progress-text">{{ progressText }}</span>
    </div>

    <!-- 错误信息显示 -->
    <div v-if="timelineData.timelineStatus === 'error'" class="error-info">
      <span class="error-message">{{ errorMessage }}</span>
      <button v-if="canRetry" @click="handleRetry">重试</button>
    </div>

    <!-- Sprite控制 -->
    <div v-if="timelineData.spriteId" class="sprite-controls">
      <button @click="updateOpacity(0.5)">半透明</button>
      <button @click="updateOpacity(1.0)">不透明</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, inject } from 'vue'
import type { UnifiedTimelineItemData } from '@/unified/timeline'
import { TimelineContextUtils } from '@/unified/timeline/utils'

// 注入依赖
const spriteManager = inject<SpriteLifecycleManager>('spriteManager')!

// Props
interface Props {
  timelineData: UnifiedTimelineItemData
}
const props = defineProps<Props>()

// 计算属性 - 自动响应数据变化
const statusClass = computed(() => {
  return `status-${props.timelineData.timelineStatus}`
})

const statusText = computed(() => {
  const context = props.timelineData.statusContext
  if (!context) return '未知状态'

  switch (context.stage) {
    case 'downloading': return '下载中...'
    case 'parsing': return '解析中...'
    case 'ready': return '就绪'
    case 'error': return '错误'
    default: return context.message || '处理中...'
  }
})

const showProgress = computed(() => {
  const context = props.timelineData.statusContext
  return context && TimelineContextUtils.hasProgress(context)
})

const progressPercent = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasProgress(context)) return 0
  return context.progress.percent
})

const progressText = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasProgress(context)) return ''

  if (context.stage === 'downloading' && 'downloadSpeed' in context) {
    return `${context.progress.percent}% (${context.downloadSpeed})`
  }

  return `${context.progress.percent}%`
})

const errorMessage = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasError(context)) return ''
  return context.error.message
})

const canRetry = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasError(context)) return false
  return context.error.recoverable
})

// 方法
async function handleRetry() {
  // 重新开始处理流程
  await startDownload(props.timelineData)
}

async function updateOpacity(opacity: number) {
  if (!props.timelineData.spriteId) return

  await spriteManager.updateSpriteProperties(props.timelineData.spriteId, {
    opacity
  })
}
</script>
```

### 2. 时间轴管理组件

```vue
<template>
  <div class="timeline-manager">
    <div class="timeline-tracks">
      <div
        v-for="track in tracks"
        :key="track.id"
        class="track"
      >
        <div class="track-header">{{ track.name }}</div>
        <div class="track-items">
          <TimelineItemComponent
            v-for="item in getTrackItems(track.id)"
            :key="item.id"
            :timeline-data="item"
            @update="handleItemUpdate"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, provide, onMounted, onUnmounted } from 'vue'
import type { UnifiedTimelineItemData } from '@/unified/timeline'
import { TimelineMediaSyncManager, SpriteLifecycleManager } from '@/unified/timeline'

// 响应式数据
const timelineItems = ref<UnifiedTimelineItemData[]>([])
const tracks = ref([
  { id: 'video-1', name: '视频轨道 1' },
  { id: 'audio-1', name: '音频轨道 1' }
])

// 管理器实例
const syncManager = new TimelineMediaSyncManager()
const spriteManager = new SpriteLifecycleManager(avCanvas)

// 提供给子组件
provide('syncManager', syncManager)
provide('spriteManager', spriteManager)

// 计算属性
const getTrackItems = computed(() => (trackId: string) => {
  return timelineItems.value.filter(item => item.trackId === trackId)
})

// 方法
function handleItemUpdate(itemData: UnifiedTimelineItemData) {
  // 响应式数据自动更新UI，无需手动处理
  console.log('时间轴项目已更新:', itemData.id)
}

// 生命周期
onMounted(() => {
  // 初始化时间轴项目
  loadTimelineItems()
})

onUnmounted(() => {
  // 清理所有watch监听
  timelineItems.value.forEach(item => {
    syncManager.unregisterTimelineItem(item.id)
  })
})

async function loadTimelineItems() {
  // 从项目配置加载时间轴项目
  const items = await loadProjectTimelineItems(projectConfig)
  timelineItems.value = items
}
</script>
```

## 响应式重构的优势总结

### 1. 架构一致性
- **统一模式**：数据源、媒体项目、时间轴项目都采用"核心数据 + 行为分离"
- **响应式支持**：所有状态变化自动触发Vue组件更新
- **类型安全**：完整的TypeScript类型检查和智能提示

### 2. 开发体验提升
- **自动更新**：无需手动调用UI更新方法
- **调试便利**：Vue DevTools可以直接查看所有状态变化
- **代码简洁**：消除了大量的回调和手动更新代码

### 3. 维护性改善
- **职责清晰**：数据、行为、UI完全分离
- **易于测试**：纯函数易于单元测试
- **扩展简单**：添加新功能只需要添加新的行为函数

### 4. 性能优化
- **精确更新**：Vue3的响应式系统只更新变化的部分
- **内存管理**：自动清理不再使用的watch监听
- **批量更新**：Vue3自动批量处理状态更新

## 实现建议

### 1. 迁移策略
1. **创建新架构**：实现响应式数据接口和行为函数
2. **并行开发**：新组件使用新架构，旧组件保持不变
3. **渐进式替换**：逐个组件从类模式迁移到数据+函数模式
4. **清理旧代码**：移除类定义和回调机制

### 2. 测试重点
- **响应式更新测试**：验证状态变化自动触发UI更新
- **状态同步测试**：验证媒体项目与时间轴项目状态同步
- **Sprite生命周期测试**：验证Sprite的创建、更新、销毁
- **内存泄漏测试**：验证watch监听的正确清理

---

*文档更新时间：2025-01-27*
*基于响应式重构版本：v2.0*
*关联文档：16-Vue3响应式重构方案-核心数据与行为分离.md, 10-统一时间轴项目设计-类型设计.md*
