# ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®è®¾è®¡ - ä½¿ç”¨ç¤ºä¾‹ï¼ˆå“åº”å¼é‡æ„ç‰ˆï¼‰

## æ¦‚è¿°

åŸºäº"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"çš„é‡æ„æ–¹æ¡ˆï¼Œç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®é‡‡ç”¨ä¸æ•°æ®æºã€åª’ä½“é¡¹ç›®ä¸€è‡´çš„å“åº”å¼æ¶æ„æ¨¡å¼ï¼Œå½»åº•è§£å†³Vue3å“åº”å¼æ”¯æŒé—®é¢˜ã€‚

## é‡æ„èƒŒæ™¯

### æ¶æ„ä¸€è‡´æ€§é—®é¢˜
å½“å‰ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®ä½¿ç”¨ç±»æ¨¡å¼ï¼Œä¸å·²é‡æ„çš„æ•°æ®æºã€åª’ä½“é¡¹ç›®çš„"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"æ¨¡å¼ä¸ä¸€è‡´ï¼š
- æ•°æ®æºå’Œåª’ä½“é¡¹ç›®ï¼šå·²é‡‡ç”¨å“åº”å¼æ•°æ®å¯¹è±¡ + æ— çŠ¶æ€å‡½æ•°
- æ—¶é—´è½´é¡¹ç›®ï¼šä»ä½¿ç”¨ç±»å®ä¾‹ï¼Œå­˜åœ¨å“åº”å¼æ”¯æŒé—®é¢˜

### è§£å†³æ–¹æ¡ˆ
é‡‡ç”¨ç»Ÿä¸€çš„"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"æ¨¡å¼ï¼š
- **æ ¸å¿ƒæ•°æ®**ï¼šçº¯ç²¹çš„å“åº”å¼çŠ¶æ€å¯¹è±¡ï¼Œä½¿ç”¨ `reactive()` åŒ…è£…
- **è¡Œä¸ºå‡½æ•°**ï¼šæ— çŠ¶æ€çš„çº¯å‡½æ•°ï¼Œæ“ä½œæ•°æ®å¯¹è±¡
- **æŸ¥è¯¢å‡½æ•°**ï¼šçº¯å‡½æ•°ï¼Œç”¨äºçŠ¶æ€æŸ¥è¯¢å’Œè®¡ç®—

## å“åº”å¼æ•°æ®ç»“æ„è®¾è®¡

### 1. ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®æ•°æ®æ¥å£

```typescript
import { reactive } from 'vue'
import type { MediaType } from '@/types'
import type { UnifiedDataSourceData } from '@/unified/sources'

/**
 * ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®æ•°æ®æ¥å£ - çº¯å“åº”å¼çŠ¶æ€å¯¹è±¡
 */
export interface UnifiedTimelineItemData {
  // ==================== æ ¸å¿ƒå±æ€§ ====================
  readonly id: string
  mediaItemId: string // å…³è”çš„ç»Ÿä¸€åª’ä½“é¡¹ç›®ID
  trackId?: string

  // ==================== çŠ¶æ€ç®¡ç† ====================
  timelineStatus: TimelineItemStatus // ä»…3çŠ¶æ€ï¼šready|loading|error

  // ==================== çŠ¶æ€ä¸Šä¸‹æ–‡ - åŠ¨æ€çŠ¶æ€ä¿¡æ¯ ====================
  statusContext?: TimelineStatusContext // æ‰¿è½½å½“å‰çŠ¶æ€çš„è¯¦ç»†ä¿¡æ¯å’ŒUIå±•ç¤ºæ•°æ®

  // ==================== åª’ä½“ä¿¡æ¯ ====================
  mediaType: MediaType | 'unknown' // ä»å…³è”çš„åª’ä½“é¡¹ç›®åŒæ­¥

  // ==================== æ—¶é—´èŒƒå›´ ====================
  timeRange: {
    timelineStartTime: number // æ—¶é—´è½´å¼€å§‹æ—¶é—´ï¼ˆå¸§æ•°ï¼‰
    timelineEndTime: number   // æ—¶é—´è½´ç»“æŸæ—¶é—´ï¼ˆå¸§æ•°ï¼‰
  }

  // ==================== åŸºç¡€é…ç½® ====================
  config: BasicTimelineConfig // é™æ€é…ç½®ä¿¡æ¯

  // ==================== Spriteå¼•ç”¨ ====================
  spriteId?: string // Sprite IDï¼Œç”±SpriteLifecycleManagerç®¡ç†
}
```

## ç±»å‹å®‰å…¨ä½¿ç”¨ç¤ºä¾‹

### 1. åŸºæœ¬çŠ¶æ€æŸ¥è¯¢ç¤ºä¾‹

```typescript
/**
 * ç±»å‹å®‰å…¨çš„çŠ¶æ€æŸ¥è¯¢ç¤ºä¾‹
 */
function displayTimelineStatus(data: UnifiedTimelineItemData) {
  const context = data.statusContext
  if (!context) return

  switch (context.stage) {
    case 'downloading':
      // TypeScript çŸ¥é“è¿™é‡Œæ˜¯ DownloadContext
      console.log(`ä¸‹è½½è¿›åº¦: ${context.progress.percent}%`)
      if (context.downloadSpeed) {
        console.log(`ä¸‹è½½é€Ÿåº¦: ${context.downloadSpeed}`)
      }
      break

    case 'parsing':
      // TypeScript çŸ¥é“è¿™é‡Œæ˜¯ ParseContext
      console.log(`è§£æè¿›åº¦: ${context.progress.percent}%`)
      if (context.currentStep) {
        console.log(`å½“å‰æ­¥éª¤: ${context.currentStep}`)
      }
      break

    case 'error':
      // TypeScript çŸ¥é“è¿™é‡Œæ˜¯ ErrorContext
      console.log(`é”™è¯¯: ${context.error.message}`)
      if (context.error.recoverable) {
        console.log('å¯ä»¥é‡è¯•')
      }
      break
  }
}
```

### 2. å“åº”å¼è¡Œä¸ºå‡½æ•°ç¤ºä¾‹

```typescript
// ==================== å·¥å‚å‡½æ•° ====================

/**
 * åˆ›å»ºå“åº”å¼æ—¶é—´è½´é¡¹ç›®æ•°æ®å¯¹è±¡
 */
export function createTimelineItemData(options: {
  mediaItemId: string
  trackId?: string
  timeRange: { timelineStartTime: number; timelineEndTime: number }
  config: BasicTimelineConfig
  mediaType?: MediaType
}): UnifiedTimelineItemData {
  return reactive({
    id: generateUUID4(),
    mediaItemId: options.mediaItemId,
    trackId: options.trackId,
    timelineStatus: 'loading' as TimelineItemStatus,
    statusContext: TIMELINE_CONTEXT_TEMPLATES.downloadStart(),
    mediaType: options.mediaType || 'unknown',
    timeRange: options.timeRange,
    config: options.config
  })
}

// ==================== çŠ¶æ€è½¬æ¢è¡Œä¸ºå‡½æ•° ====================

/**
 * çŠ¶æ€è½¬æ¢è¡Œä¸ºå‡½æ•° - æ— çŠ¶æ€çº¯å‡½æ•°
 * åŸºäº3çŠ¶æ€ + ç±»å‹å®‰å…¨ TimelineStatusContext çš„è½¬æ¢
 */
export async function transitionTimelineStatus(
  data: UnifiedTimelineItemData,
  newStatus: TimelineItemStatus,
  context?: TimelineStatusContext
): Promise<void> {
  if (!canTransitionTo(data, newStatus)) {
    throw new Error(`Invalid timeline transition: ${data.timelineStatus} â†’ ${newStatus}`)
  }

  const oldStatus = data.timelineStatus
  data.timelineStatus = newStatus // âœ… è‡ªåŠ¨è§¦å‘å“åº”å¼æ›´æ–°
  data.statusContext = context // ç»Ÿä¸€å­˜å‚¨æ‰€æœ‰å·®å¼‚ä¿¡æ¯

  // ç²¾çµç”Ÿå‘½å‘¨æœŸç®¡ç† - æ›´æ¸…æ™°çš„3åˆ†æ”¯
  await handleSpriteLifecycle(data, oldStatus, newStatus)

  console.log(`âœ… æ—¶é—´è½´é¡¹ç›®çŠ¶æ€è½¬æ¢: ${oldStatus} â†’ ${newStatus}`, context)
}

/**
 * Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†å‡½æ•°
 */
async function handleSpriteLifecycle(
  data: UnifiedTimelineItemData,
  oldStatus: TimelineItemStatus,
  newStatus: TimelineItemStatus
): Promise<void> {
  switch (newStatus) {
    case 'ready':
      // åªåœ¨readyæ—¶åˆ›å»ºspriteï¼Œæ‰€æœ‰å‡†å¤‡å·¥ä½œå·²å®Œæˆ
      if (oldStatus !== 'ready') {
        await createSprite(data)
      }
      break

    case 'loading':           // ä¿æŒç°çŠ¶ä¸å˜
    case 'error':            // æ¸…ç†èµ„æº
    default:
      if (oldStatus === 'ready') {
        await destroySprite(data)
      }
  }
}

/**
 * åˆ›å»ºSpriteå‡½æ•°
 */
async function createSprite(data: UnifiedTimelineItemData): Promise<void> {
  // ç±»å‹å®‰å…¨çš„ä¸Šä¸‹æ–‡æ£€æŸ¥
  if (!data.statusContext || !TimelineContextUtils.isReady(data.statusContext)) {
    throw new Error('ç¼ºå°‘å°±ç»ªçŠ¶æ€çš„åª’ä½“å…ƒæ•°æ®')
  }

  // è·å–å…³è”çš„åª’ä½“é¡¹ç›®
  const mediaItem = await getAssociatedMediaItem(data.mediaItemId)
  if (!mediaItem) {
    throw new Error('æ— æ³•æ‰¾åˆ°å…³è”çš„åª’ä½“é¡¹ç›®')
  }

  // é€šè¿‡ SpriteLifecycleManager åˆ›å»ºå¹¶æ·»åŠ  Sprite
  const spriteId = await SpriteLifecycleManager.createAndAddSprite(
    mediaItem,
    data,
    data.statusContext as ReadyContext
  )

  data.spriteId = spriteId // âœ… å“åº”å¼æ›´æ–°
}

/**
 * é”€æ¯Spriteå‡½æ•°
 */
async function destroySprite(data: UnifiedTimelineItemData): Promise<void> {
  if (!data.spriteId) {
    return
  }

  // é€šè¿‡ SpriteLifecycleManager ç§»é™¤ Spriteï¼ˆAVCanvas ä¼šè‡ªåŠ¨é”€æ¯ï¼‰
  await SpriteLifecycleManager.removeSprite(data.spriteId)
  data.spriteId = undefined // âœ… å“åº”å¼æ›´æ–°
}

// ==================== æŸ¥è¯¢å‡½æ•° ====================

/**
 * çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°
 */
export function canTransitionTo(
  data: UnifiedTimelineItemData,
  newStatus: TimelineItemStatus
): boolean {
  // 3çŠ¶æ€é—´çš„ç®€å•è§„åˆ™
  const allowed = VALID_TIMELINE_TRANSITIONS[data.timelineStatus]
  return allowed?.includes(newStatus) ?? false
}

// ==================== ä¾¿æ·æ“ä½œå‡½æ•° ====================

/**
 * å¼€å§‹ä¸‹è½½
 */
export function startDownload(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'loading', TIMELINE_CONTEXT_TEMPLATES.downloadStart())
}

/**
 * æ›´æ–°ä¸‹è½½è¿›åº¦
 */
export function updateDownloadProgress(
  data: UnifiedTimelineItemData,
  percent: number,
  speed?: string
): Promise<void> {
  return transitionTimelineStatus(data, 'loading', TIMELINE_CONTEXT_TEMPLATES.downloadProgress(percent, speed))
}

/**
 * å¼€å§‹è§£æ
 */
export function startParsing(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'loading', TIMELINE_CONTEXT_TEMPLATES.parseStart())
}

/**
 * è®¾ç½®ä¸ºå°±ç»ªçŠ¶æ€
 */
export function setReady(
  data: UnifiedTimelineItemData,
  metadata?: ReadyContext['metadata']
): Promise<void> {
  return transitionTimelineStatus(data, 'ready', TIMELINE_CONTEXT_TEMPLATES.ready(metadata))
}

/**
 * è®¾ç½®é”™è¯¯çŠ¶æ€
 */
export function setError(
  data: UnifiedTimelineItemData,
  code: string,
  message: string,
  recoverable = true
): Promise<void> {
  return transitionTimelineStatus(data, 'error', TIMELINE_CONTEXT_TEMPLATES.error(code, message, recoverable))
}
```

## å“åº”å¼çŠ¶æ€è½¬æ¢æµç¨‹ç¤ºä¾‹

### 1. æœ¬åœ°æ–‡ä»¶å¤„ç†æµç¨‹ï¼ˆå“åº”å¼ç‰ˆæœ¬ï¼‰

```typescript
// ç”¨æˆ·æ‹–æ‹½æœ¬åœ°æ–‡ä»¶åˆ°æ—¶é—´è½´
async function handleLocalFileDrop(file: File, trackId: string) {
  // 1. åˆ›å»ºå“åº”å¼åª’ä½“é¡¹ç›®æ•°æ®
  const mediaData = createMediaItemData({
    source: createUserSelectedFileSourceData(file),
    mediaType: detectMediaType(file)
  })

  // 2. åˆ›å»ºå“åº”å¼æ—¶é—´è½´é¡¹ç›®æ•°æ®
  const timelineData = createTimelineItemData({
    mediaItemId: mediaData.id,
    trackId,
    timeRange: { timelineStartTime: 0, timelineEndTime: 300 }, // é»˜è®¤5ç§’
    config: createBasicTimelineConfig(file.name)
  })

  // 3. å¼€å§‹åª’ä½“è§£æï¼ˆè‡ªåŠ¨è§¦å‘UIæ›´æ–°ï¼‰
  await startMediaProcessing(mediaData)

  // 4. ç›‘å¬åª’ä½“çŠ¶æ€å˜åŒ–ï¼Œè‡ªåŠ¨åŒæ­¥åˆ°æ—¶é—´è½´
  watchMediaStatus(mediaData, timelineData)
}

// å“åº”å¼çŠ¶æ€åŒæ­¥
function watchMediaStatus(
  mediaData: UnifiedMediaItemData,
  timelineData: UnifiedTimelineItemData
) {
  watch(() => mediaData.mediaStatus, async (newStatus) => {
    const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

    if (timelineData.timelineStatus !== targetTimelineStatus) {
      const context = createTimelineContextFromMedia(mediaData)
      await transitionTimelineStatus(timelineData, targetTimelineStatus, context)
    }
  }, { immediate: true })
}
```

**å“åº”å¼æµç¨‹ç‰¹ç‚¹**ï¼š
- âœ… **è‡ªåŠ¨UIæ›´æ–°**ï¼šæ‰€æœ‰çŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘Vueç»„ä»¶é‡æ–°æ¸²æŸ“
- âœ… **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„TypeScriptç±»å‹æ£€æŸ¥
- âœ… **çŠ¶æ€åŒæ­¥**ï¼šåª’ä½“çŠ¶æ€è‡ªåŠ¨æ˜ å°„åˆ°æ—¶é—´è½´çŠ¶æ€
- âœ… **æ— éœ€å›è°ƒ**ï¼šä¸éœ€è¦æ‰‹åŠ¨è§¦å‘UIæ›´æ–°

### 2. è¿œç¨‹æ–‡ä»¶ä¸‹è½½æµç¨‹ï¼ˆå“åº”å¼ç‰ˆæœ¬ï¼‰

```typescript
// è¾“å…¥è¿œç¨‹URLåˆ›å»ºæ—¶é—´è½´é¡¹ç›®
async function handleRemoteUrlAdd(url: string, trackId: string) {
  // 1. åˆ›å»ºå“åº”å¼æ•°æ®å¯¹è±¡
  const mediaData = createMediaItemData({
    source: createRemoteFileSourceData(url),
    mediaType: 'unknown'
  })

  const timelineData = createTimelineItemData({
    mediaItemId: mediaData.id,
    trackId,
    timeRange: { timelineStartTime: 0, timelineEndTime: 300 },
    config: createBasicTimelineConfig(extractFilename(url))
  })

  // 2. å¼€å§‹ä¸‹è½½ï¼ˆçŠ¶æ€å˜åŒ–è‡ªåŠ¨åæ˜ åˆ°UIï¼‰
  await startDownload(timelineData)

  // 3. ç›‘å¬ä¸‹è½½è¿›åº¦ï¼ˆè‡ªåŠ¨æ›´æ–°è¿›åº¦æ¡ï¼‰
  watchDownloadProgress(mediaData, timelineData)

  // 4. ä¸‹è½½å®Œæˆåè‡ªåŠ¨å¼€å§‹è§£æ
  watch(() => mediaData.source.status, async (status) => {
    if (status === 'acquired') {
      await startParsing(timelineData)
      await startMediaProcessing(mediaData)
    }
  })
}

// è¿›åº¦ç›‘å¬å‡½æ•°
function watchDownloadProgress(
  mediaData: UnifiedMediaItemData,
  timelineData: UnifiedTimelineItemData
) {
  watch(() => mediaData.source.progress, (progress) => {
    // è‡ªåŠ¨æ›´æ–°ä¸‹è½½è¿›åº¦ï¼ˆè§¦å‘UIæ›´æ–°ï¼‰
    updateDownloadProgress(timelineData, progress, mediaData.source.downloadSpeed)
  })
}
```

**å“åº”å¼æµç¨‹ç‰¹ç‚¹**ï¼š
- âœ… **å®æ—¶è¿›åº¦**ï¼šä¸‹è½½è¿›åº¦è‡ªåŠ¨æ›´æ–°åˆ°UIç»„ä»¶
- âœ… **çŠ¶æ€é©±åŠ¨**ï¼šåŸºäºçŠ¶æ€å˜åŒ–è‡ªåŠ¨æ‰§è¡Œåç»­æ“ä½œ
- âœ… **é”™è¯¯å¤„ç†**ï¼šç½‘ç»œé”™è¯¯è‡ªåŠ¨åæ˜ åˆ°æ—¶é—´è½´çŠ¶æ€
- âœ… **ç”¨æˆ·ä½“éªŒ**ï¼šæ— éœ€æ‰‹åŠ¨åˆ·æ–°ï¼ŒçŠ¶æ€å˜åŒ–ç«‹å³å¯è§

### 3. é¡¹ç›®åŠ è½½æµç¨‹ï¼ˆå“åº”å¼ç‰ˆæœ¬ï¼‰

```typescript
// åŠ è½½é¡¹ç›®æ—¶æ¢å¤æ—¶é—´è½´é¡¹ç›®
async function loadProjectTimelineItems(projectConfig: ProjectConfig) {
  const timelineItems: UnifiedTimelineItemData[] = []

  for (const itemConfig of projectConfig.timeline.timelineItems) {
    // 1. åˆ›å»ºå“åº”å¼æ—¶é—´è½´æ•°æ®
    const timelineData = createTimelineItemData({
      mediaItemId: itemConfig.mediaItemId,
      trackId: itemConfig.trackId,
      timeRange: itemConfig.timeRange,
      config: itemConfig.config
    })

    // 2. æ£€æŸ¥å…³è”åª’ä½“é¡¹ç›®çŠ¶æ€
    const mediaData = await getMediaItemData(itemConfig.mediaItemId)

    if (mediaData) {
      // åª’ä½“é¡¹ç›®å­˜åœ¨ï¼ŒåŒæ­¥çŠ¶æ€
      const timelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaData.mediaStatus]
      await transitionTimelineStatus(timelineData, timelineStatus)

      // å»ºç«‹çŠ¶æ€åŒæ­¥
      watchMediaStatus(mediaData, timelineData)
    } else {
      // åª’ä½“é¡¹ç›®ä¸å­˜åœ¨ï¼Œæ ‡è®°ä¸ºé”™è¯¯
      await setError(timelineData, 'MEDIA_MISSING', 'å…³è”çš„åª’ä½“é¡¹ç›®ä¸å­˜åœ¨')
    }

    timelineItems.push(timelineData)
  }

  return timelineItems
}
```

**å“åº”å¼æµç¨‹ç‰¹ç‚¹**ï¼š
- âœ… **çŠ¶æ€æ¢å¤**ï¼šè‡ªåŠ¨æ¢å¤æ—¶é—´è½´é¡¹ç›®çš„æ­£ç¡®çŠ¶æ€
- âœ… **ä¾èµ–æ£€æŸ¥**ï¼šè‡ªåŠ¨éªŒè¯åª’ä½“é¡¹ç›®ä¾èµ–å…³ç³»
- âœ… **é”™è¯¯æ ‡è®°**ï¼šç¼ºå¤±æ–‡ä»¶è‡ªåŠ¨æ ‡è®°ä¸ºé”™è¯¯çŠ¶æ€
- âœ… **å®æ—¶åŒæ­¥**ï¼šåŠ è½½åç»§ç»­ä¿æŒçŠ¶æ€åŒæ­¥

## å“åº”å¼Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†

### 1. å“åº”å¼Spriteç®¡ç†å™¨

```typescript
/**
 * å“åº”å¼Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
 * åŸºäºæ•°æ®é©±åŠ¨çš„Spriteç®¡ç†ï¼Œä¸å“åº”å¼æ—¶é—´è½´é¡¹ç›®æ•°æ®é…åˆ
 */
export class SpriteLifecycleManager {
  private avCanvas: AVCanvas
  private spriteRegistry = new Map<string, Raw<CustomSprite>>() // spriteId -> spriteæ˜ å°„

  constructor(avCanvas: AVCanvas) {
    this.avCanvas = avCanvas
  }

  /**
   * åˆ›å»ºå¹¶æ·»åŠ  Sprite åˆ° AVCanvas
   * è¿”å›spriteIdä¾›æ—¶é—´è½´é¡¹ç›®æ•°æ®å¼•ç”¨
   */
  async createAndAddSprite(
    mediaData: UnifiedMediaItemData,
    timelineData: UnifiedTimelineItemData,
    context?: ReadyContext
  ): Promise<string> {
    const { mediaType, webav } = mediaData

    if (!webav) {
      throw new Error('åª’ä½“é¡¹ç›®WebAVå¯¹è±¡æœªå°±ç»ª')
    }

    // ç”Ÿæˆå”¯ä¸€çš„spriteId
    const spriteId = generateUUID4()

    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ Sprite
    if (timelineData.spriteId && this.spriteRegistry.has(timelineData.spriteId)) {
      console.warn(`æ—¶é—´è½´é¡¹ç›® ${timelineData.id} çš„ Sprite å·²å­˜åœ¨ï¼Œå…ˆç§»é™¤æ—§çš„`)
      await this.removeSprite(timelineData.spriteId)
    }

    let sprite: Raw<CustomSprite>

    // æ ¹æ®åª’ä½“ç±»å‹åˆ›å»ºå¯¹åº”çš„ Sprite
    switch (mediaType) {
      case 'video':
        if (!webav.mp4Clip) throw new Error('è§†é¢‘WebAVå¯¹è±¡ç¼ºå¤±')
        sprite = new VideoVisibleSprite(webav.mp4Clip)
        break

      case 'image':
        if (!webav.imgClip) throw new Error('å›¾ç‰‡WebAVå¯¹è±¡ç¼ºå¤±')
        sprite = new ImageVisibleSprite(webav.imgClip)
        break

      case 'audio':
        if (!webav.audioClip) throw new Error('éŸ³é¢‘WebAVå¯¹è±¡ç¼ºå¤±')
        sprite = new AudioVisibleSprite(webav.audioClip)
        break

      default:
        throw new Error(`ä¸æ”¯æŒçš„åª’ä½“ç±»å‹: ${mediaType}`)
    }

    // è®¾ç½® Sprite çš„åŸºç¡€å±æ€§
    await this.setupSpriteProperties(sprite, timelineData)

    // æ·»åŠ åˆ° AVCanvas
    await this.avCanvas.addSprite(sprite)

    // æ³¨å†Œåˆ°ç®¡ç†å™¨
    this.spriteRegistry.set(spriteId, sprite)

    console.log(`âœ… Sprite å·²åˆ›å»ºå¹¶æ·»åŠ åˆ° AVCanvas: ${spriteId} (${mediaType})`)

    return spriteId
  }

  /**
   * ä» AVCanvas ç§»é™¤ Spriteï¼ˆAVCanvas ä¼šè‡ªåŠ¨é”€æ¯ï¼‰
   */
  async removeSprite(spriteId: string): Promise<void> {
    const sprite = this.spriteRegistry.get(spriteId)
    if (!sprite) {
      console.warn(`æœªæ‰¾åˆ° Sprite: ${spriteId}`)
      return
    }

    try {
      // ä» AVCanvas ç§»é™¤ï¼ˆAVCanvas ä¼šè‡ªåŠ¨é”€æ¯ Spriteï¼‰
      await this.avCanvas.removeSprite(sprite)

      // ä»æ³¨å†Œè¡¨ç§»é™¤
      this.spriteRegistry.delete(spriteId)

      console.log(`ğŸ—‘ï¸ Sprite å·²ä» AVCanvas ç§»é™¤: ${spriteId}`)
    } catch (error) {
      console.error(`âŒ Sprite ç§»é™¤å¤±è´¥: ${spriteId}`, error)
      throw error
    }
  }

  /**
   * è®¾ç½®SpriteåŸºç¡€å±æ€§
   */
  private async setupSpriteProperties(
    sprite: Raw<CustomSprite>,
    timelineData: UnifiedTimelineItemData
  ): Promise<void> {
    // è®¾ç½®æ—¶é—´èŒƒå›´
    sprite.setTimeRange({
      timelineStartTime: timelineData.timeRange.timelineStartTime,
      timelineEndTime: timelineData.timeRange.timelineEndTime
    })

    // è®¾ç½®åŸºç¡€å˜æ¢å±æ€§
    const config = timelineData.config
    if (config.transform) {
      sprite.setTransform(config.transform)
    }

    // è®¾ç½®å…¶ä»–å±æ€§...
  }

  /**
   * è·å–Spriteå®ä¾‹ï¼ˆç”¨äºç›´æ¥æ“ä½œï¼‰
   */
  getSprite(spriteId: string): Raw<CustomSprite> | undefined {
    return this.spriteRegistry.get(spriteId)
  }

  /**
   * æ›´æ–°Spriteå±æ€§ï¼ˆå“åº”å¼æ›´æ–°ï¼‰
   */
  async updateSpriteProperties(
    spriteId: string,
    updates: Partial<{
      timeRange: { timelineStartTime: number; timelineEndTime: number }
      transform: TransformData
      opacity: number
    }>
  ): Promise<void> {
    const sprite = this.spriteRegistry.get(spriteId)
    if (!sprite) {
      console.warn(`æœªæ‰¾åˆ° Sprite: ${spriteId}`)
      return
    }

    if (updates.timeRange) {
      sprite.setTimeRange(updates.timeRange)
    }

    if (updates.transform) {
      sprite.setTransform(updates.transform)
    }

    if (updates.opacity !== undefined) {
      sprite.setOpacity(updates.opacity)
    }
  }
}
```

### 2. å“åº”å¼çŠ¶æ€åŒæ­¥ç®¡ç†

```typescript
/**
 * å“åº”å¼æ—¶é—´è½´é¡¹ç›®ä¸åª’ä½“é¡¹ç›®çš„çŠ¶æ€åŒæ­¥ç®¡ç†å™¨
 * åŸºäºVue3çš„watchæœºåˆ¶å®ç°è‡ªåŠ¨çŠ¶æ€åŒæ­¥
 */
export class TimelineMediaSyncManager {
  private timelineItems = new Map<string, UnifiedTimelineItemData>()
  private mediaItems = new Map<string, UnifiedMediaItemData>()
  private watchStopHandles = new Map<string, WatchStopHandle>() // ç”¨äºæ¸…ç†watch

  /**
   * æ³¨å†Œæ—¶é—´è½´é¡¹ç›®ï¼Œå»ºç«‹ä¸åª’ä½“é¡¹ç›®çš„å“åº”å¼å…³è”
   */
  registerTimelineItem(timelineData: UnifiedTimelineItemData) {
    this.timelineItems.set(timelineData.id, timelineData)

    // æ£€æŸ¥å…³è”åª’ä½“é¡¹ç›®çš„çŠ¶æ€
    const mediaData = this.mediaItems.get(timelineData.mediaItemId)
    if (mediaData) {
      // éªŒè¯MediaItemæ˜¯å¦ready
      if (mediaData.mediaStatus !== 'ready') {
        console.warn(`âš ï¸ TimelineItem ${timelineData.id} å…³è”çš„MediaItem ${mediaData.id} å°šæœªready`)
      }
      this.setupMediaStatusSync(timelineData, mediaData)
    } else {
      console.error(`âŒ TimelineItem ${timelineData.id} æ‰¾ä¸åˆ°å…³è”çš„MediaItem ${timelineData.mediaItemId}`)
    }
  }

  /**
   * å»ºç«‹åª’ä½“é¡¹ç›®çŠ¶æ€åˆ°æ—¶é—´è½´é¡¹ç›®çŠ¶æ€çš„å“åº”å¼åŒæ­¥
   */
  private setupMediaStatusSync(
    timelineData: UnifiedTimelineItemData,
    mediaData: UnifiedMediaItemData
  ) {
    // ä½¿ç”¨Vue3çš„watchå»ºç«‹å“åº”å¼åŒæ­¥
    const stopHandle = watch(
      () => mediaData.mediaStatus,
      async (newStatus, oldStatus) => {
        const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

        if (timelineData.timelineStatus !== targetTimelineStatus) {
          // åˆ›å»ºæ—¶é—´è½´è½¬æ¢ä¸Šä¸‹æ–‡
          const timelineContext = this.createTimelineContext(mediaData)

          // è§¦å‘æ—¶é—´è½´é¡¹ç›®çŠ¶æ€è½¬æ¢ï¼ˆè‡ªåŠ¨è§¦å‘UIæ›´æ–°ï¼‰
          await transitionTimelineStatus(timelineData, targetTimelineStatus, timelineContext)

          console.log(`ğŸ”„ çŠ¶æ€åŒæ­¥: MediaItem(${newStatus}) â†’ TimelineItem(${targetTimelineStatus})`)
        }
      },
      { immediate: true } // ç«‹å³æ‰§è¡Œä¸€æ¬¡åŒæ­¥å½“å‰çŠ¶æ€
    )

    // ä¿å­˜åœæ­¢å¥æŸ„ï¼Œç”¨äºæ¸…ç†
    this.watchStopHandles.set(timelineData.id, stopHandle)
  }

  /**
   * åˆ›å»ºæ—¶é—´è½´ä¸Šä¸‹æ–‡ä»åª’ä½“æ•°æ®
   */
  private createTimelineContext(mediaData: UnifiedMediaItemData): TimelineStatusContext | undefined {
    switch (mediaData.mediaStatus) {
      case 'pending':
        return TIMELINE_CONTEXT_TEMPLATES.downloadStart()

      case 'asyncprocessing':
        // æ ¹æ®æ•°æ®æºçŠ¶æ€åˆ›å»ºä¸åŒçš„ä¸Šä¸‹æ–‡
        if (mediaData.source.status === 'acquiring') {
          return TIMELINE_CONTEXT_TEMPLATES.downloadProgress(
            mediaData.source.progress,
            mediaData.source.downloadSpeed
          )
        }
        return TIMELINE_CONTEXT_TEMPLATES.parseStart()

      case 'webavdecoding':
        return TIMELINE_CONTEXT_TEMPLATES.parseStart()

      case 'ready':
        return TIMELINE_CONTEXT_TEMPLATES.ready({
          duration: mediaData.duration,
          format: mediaData.format || 'unknown'
        })

      case 'error':
        return TIMELINE_CONTEXT_TEMPLATES.error(
          'MEDIA_ERROR',
          mediaData.source.errorMessage || 'åª’ä½“å¤„ç†å¤±è´¥'
        )

      default:
        return undefined
    }
  }

  /**
   * å“åº”å¼æ—¶é—´è½´é¡¹ç›®å·¥å‚æ–¹æ³•
   * ç¡®ä¿åªæœ‰readyçŠ¶æ€çš„MediaItemæ‰èƒ½ç›´æ¥åˆ›å»ºreadyçš„TimelineItem
   */
  createTimelineItem(
    mediaItemId: string,
    trackId: string,
    timeRange: { timelineStartTime: number; timelineEndTime: number },
    config: BasicTimelineConfig
  ): UnifiedTimelineItemData | null {
    const mediaData = this.mediaItems.get(mediaItemId)

    if (!mediaData) {
      console.error(`âŒ æ‰¾ä¸åˆ°MediaItem: ${mediaItemId}`)
      return null
    }

    // åˆ›å»ºå“åº”å¼TimelineItemæ•°æ®
    const timelineData = createTimelineItemData({
      mediaItemId,
      trackId,
      timeRange,
      config,
      mediaType: mediaData.mediaType
    })

    // æ ¹æ®MediaItemçŠ¶æ€è®¾ç½®åˆå§‹çŠ¶æ€
    const initialStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaData.mediaStatus]
    const initialContext = this.createTimelineContext(mediaData)

    // åŒæ­¥è®¾ç½®åˆå§‹çŠ¶æ€ï¼ˆä¸éœ€è¦awaitï¼Œå› ä¸ºæ˜¯åŒæ­¥æ“ä½œï¼‰
    timelineData.timelineStatus = initialStatus
    timelineData.statusContext = initialContext

    // æ³¨å†Œåˆ°ç®¡ç†å™¨ï¼ˆå»ºç«‹å“åº”å¼åŒæ­¥ï¼‰
    this.registerTimelineItem(timelineData)

    console.log(`âœ… åˆ›å»ºæ—¶é—´è½´é¡¹ç›®: ${timelineData.id}, åˆå§‹çŠ¶æ€: ${initialStatus}`)

    return timelineData
  }

  /**
   * æ³¨å†Œåª’ä½“é¡¹ç›®
   */
  registerMediaItem(mediaData: UnifiedMediaItemData) {
    this.mediaItems.set(mediaData.id, mediaData)
  }

  /**
   * æ¸…ç†æ—¶é—´è½´é¡¹ç›®ï¼ˆåœæ­¢å“åº”å¼ç›‘å¬ï¼‰
   */
  unregisterTimelineItem(timelineId: string) {
    // åœæ­¢watchç›‘å¬
    const stopHandle = this.watchStopHandles.get(timelineId)
    if (stopHandle) {
      stopHandle()
      this.watchStopHandles.delete(timelineId)
    }

    // ä»æ³¨å†Œè¡¨ç§»é™¤
    this.timelineItems.delete(timelineId)

    console.log(`ğŸ—‘ï¸ æ¸…ç†æ—¶é—´è½´é¡¹ç›®: ${timelineId}`)
  }
}
```

## Vueç»„ä»¶ä¸­çš„ä½¿ç”¨ç¤ºä¾‹

### 1. æ—¶é—´è½´é¡¹ç›®ç»„ä»¶

```vue
<template>
  <div class="timeline-item" :class="statusClass">
    <!-- åŸºç¡€ä¿¡æ¯æ˜¾ç¤º -->
    <div class="item-header">
      <span class="item-name">{{ timelineData.config.name }}</span>
      <span class="item-status">{{ statusText }}</span>
    </div>

    <!-- è¿›åº¦æ˜¾ç¤º -->
    <div v-if="showProgress" class="progress-bar">
      <div
        class="progress-fill"
        :style="{ width: `${progressPercent}%` }"
      ></div>
      <span class="progress-text">{{ progressText }}</span>
    </div>

    <!-- é”™è¯¯ä¿¡æ¯æ˜¾ç¤º -->
    <div v-if="timelineData.timelineStatus === 'error'" class="error-info">
      <span class="error-message">{{ errorMessage }}</span>
      <button v-if="canRetry" @click="handleRetry">é‡è¯•</button>
    </div>

    <!-- Spriteæ§åˆ¶ -->
    <div v-if="timelineData.spriteId" class="sprite-controls">
      <button @click="updateOpacity(0.5)">åŠé€æ˜</button>
      <button @click="updateOpacity(1.0)">ä¸é€æ˜</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, inject } from 'vue'
import type { UnifiedTimelineItemData } from '@/unified/timeline'
import { TimelineContextUtils } from '@/unified/timeline/utils'

// æ³¨å…¥ä¾èµ–
const spriteManager = inject<SpriteLifecycleManager>('spriteManager')!

// Props
interface Props {
  timelineData: UnifiedTimelineItemData
}
const props = defineProps<Props>()

// è®¡ç®—å±æ€§ - è‡ªåŠ¨å“åº”æ•°æ®å˜åŒ–
const statusClass = computed(() => {
  return `status-${props.timelineData.timelineStatus}`
})

const statusText = computed(() => {
  const context = props.timelineData.statusContext
  if (!context) return 'æœªçŸ¥çŠ¶æ€'

  switch (context.stage) {
    case 'downloading': return 'ä¸‹è½½ä¸­...'
    case 'parsing': return 'è§£æä¸­...'
    case 'ready': return 'å°±ç»ª'
    case 'error': return 'é”™è¯¯'
    default: return context.message || 'å¤„ç†ä¸­...'
  }
})

const showProgress = computed(() => {
  const context = props.timelineData.statusContext
  return context && TimelineContextUtils.hasProgress(context)
})

const progressPercent = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasProgress(context)) return 0
  return context.progress.percent
})

const progressText = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasProgress(context)) return ''

  if (context.stage === 'downloading' && 'downloadSpeed' in context) {
    return `${context.progress.percent}% (${context.downloadSpeed})`
  }

  return `${context.progress.percent}%`
})

const errorMessage = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasError(context)) return ''
  return context.error.message
})

const canRetry = computed(() => {
  const context = props.timelineData.statusContext
  if (!context || !TimelineContextUtils.hasError(context)) return false
  return context.error.recoverable
})

// æ–¹æ³•
async function handleRetry() {
  // é‡æ–°å¼€å§‹å¤„ç†æµç¨‹
  await startDownload(props.timelineData)
}

async function updateOpacity(opacity: number) {
  if (!props.timelineData.spriteId) return

  await spriteManager.updateSpriteProperties(props.timelineData.spriteId, {
    opacity
  })
}
</script>
```

### 2. æ—¶é—´è½´ç®¡ç†ç»„ä»¶

```vue
<template>
  <div class="timeline-manager">
    <div class="timeline-tracks">
      <div
        v-for="track in tracks"
        :key="track.id"
        class="track"
      >
        <div class="track-header">{{ track.name }}</div>
        <div class="track-items">
          <TimelineItemComponent
            v-for="item in getTrackItems(track.id)"
            :key="item.id"
            :timeline-data="item"
            @update="handleItemUpdate"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, provide, onMounted, onUnmounted } from 'vue'
import type { UnifiedTimelineItemData } from '@/unified/timeline'
import { TimelineMediaSyncManager, SpriteLifecycleManager } from '@/unified/timeline'

// å“åº”å¼æ•°æ®
const timelineItems = ref<UnifiedTimelineItemData[]>([])
const tracks = ref([
  { id: 'video-1', name: 'è§†é¢‘è½¨é“ 1' },
  { id: 'audio-1', name: 'éŸ³é¢‘è½¨é“ 1' }
])

// ç®¡ç†å™¨å®ä¾‹
const syncManager = new TimelineMediaSyncManager()
const spriteManager = new SpriteLifecycleManager(avCanvas)

// æä¾›ç»™å­ç»„ä»¶
provide('syncManager', syncManager)
provide('spriteManager', spriteManager)

// è®¡ç®—å±æ€§
const getTrackItems = computed(() => (trackId: string) => {
  return timelineItems.value.filter(item => item.trackId === trackId)
})

// æ–¹æ³•
function handleItemUpdate(itemData: UnifiedTimelineItemData) {
  // å“åº”å¼æ•°æ®è‡ªåŠ¨æ›´æ–°UIï¼Œæ— éœ€æ‰‹åŠ¨å¤„ç†
  console.log('æ—¶é—´è½´é¡¹ç›®å·²æ›´æ–°:', itemData.id)
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // åˆå§‹åŒ–æ—¶é—´è½´é¡¹ç›®
  loadTimelineItems()
})

onUnmounted(() => {
  // æ¸…ç†æ‰€æœ‰watchç›‘å¬
  timelineItems.value.forEach(item => {
    syncManager.unregisterTimelineItem(item.id)
  })
})

async function loadTimelineItems() {
  // ä»é¡¹ç›®é…ç½®åŠ è½½æ—¶é—´è½´é¡¹ç›®
  const items = await loadProjectTimelineItems(projectConfig)
  timelineItems.value = items
}
</script>
```

## å“åº”å¼é‡æ„çš„ä¼˜åŠ¿æ€»ç»“

### 1. æ¶æ„ä¸€è‡´æ€§
- **ç»Ÿä¸€æ¨¡å¼**ï¼šæ•°æ®æºã€åª’ä½“é¡¹ç›®ã€æ—¶é—´è½´é¡¹ç›®éƒ½é‡‡ç”¨"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"
- **å“åº”å¼æ”¯æŒ**ï¼šæ‰€æœ‰çŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘Vueç»„ä»¶æ›´æ–°
- **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„TypeScriptç±»å‹æ£€æŸ¥å’Œæ™ºèƒ½æç¤º

### 2. å¼€å‘ä½“éªŒæå‡
- **è‡ªåŠ¨æ›´æ–°**ï¼šæ— éœ€æ‰‹åŠ¨è°ƒç”¨UIæ›´æ–°æ–¹æ³•
- **è°ƒè¯•ä¾¿åˆ©**ï¼šVue DevToolså¯ä»¥ç›´æ¥æŸ¥çœ‹æ‰€æœ‰çŠ¶æ€å˜åŒ–
- **ä»£ç ç®€æ´**ï¼šæ¶ˆé™¤äº†å¤§é‡çš„å›è°ƒå’Œæ‰‹åŠ¨æ›´æ–°ä»£ç 

### 3. ç»´æŠ¤æ€§æ”¹å–„
- **èŒè´£æ¸…æ™°**ï¼šæ•°æ®ã€è¡Œä¸ºã€UIå®Œå…¨åˆ†ç¦»
- **æ˜“äºæµ‹è¯•**ï¼šçº¯å‡½æ•°æ˜“äºå•å…ƒæµ‹è¯•
- **æ‰©å±•ç®€å•**ï¼šæ·»åŠ æ–°åŠŸèƒ½åªéœ€è¦æ·»åŠ æ–°çš„è¡Œä¸ºå‡½æ•°

### 4. æ€§èƒ½ä¼˜åŒ–
- **ç²¾ç¡®æ›´æ–°**ï¼šVue3çš„å“åº”å¼ç³»ç»Ÿåªæ›´æ–°å˜åŒ–çš„éƒ¨åˆ†
- **å†…å­˜ç®¡ç†**ï¼šè‡ªåŠ¨æ¸…ç†ä¸å†ä½¿ç”¨çš„watchç›‘å¬
- **æ‰¹é‡æ›´æ–°**ï¼šVue3è‡ªåŠ¨æ‰¹é‡å¤„ç†çŠ¶æ€æ›´æ–°

## å®ç°å»ºè®®

### 1. è¿ç§»ç­–ç•¥
1. **åˆ›å»ºæ–°æ¶æ„**ï¼šå®ç°å“åº”å¼æ•°æ®æ¥å£å’Œè¡Œä¸ºå‡½æ•°
2. **å¹¶è¡Œå¼€å‘**ï¼šæ–°ç»„ä»¶ä½¿ç”¨æ–°æ¶æ„ï¼Œæ—§ç»„ä»¶ä¿æŒä¸å˜
3. **æ¸è¿›å¼æ›¿æ¢**ï¼šé€ä¸ªç»„ä»¶ä»ç±»æ¨¡å¼è¿ç§»åˆ°æ•°æ®+å‡½æ•°æ¨¡å¼
4. **æ¸…ç†æ—§ä»£ç **ï¼šç§»é™¤ç±»å®šä¹‰å’Œå›è°ƒæœºåˆ¶

### 2. æµ‹è¯•é‡ç‚¹
- **å“åº”å¼æ›´æ–°æµ‹è¯•**ï¼šéªŒè¯çŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘UIæ›´æ–°
- **çŠ¶æ€åŒæ­¥æµ‹è¯•**ï¼šéªŒè¯åª’ä½“é¡¹ç›®ä¸æ—¶é—´è½´é¡¹ç›®çŠ¶æ€åŒæ­¥
- **Spriteç”Ÿå‘½å‘¨æœŸæµ‹è¯•**ï¼šéªŒè¯Spriteçš„åˆ›å»ºã€æ›´æ–°ã€é”€æ¯
- **å†…å­˜æ³„æ¼æµ‹è¯•**ï¼šéªŒè¯watchç›‘å¬çš„æ­£ç¡®æ¸…ç†

---

*æ–‡æ¡£æ›´æ–°æ—¶é—´ï¼š2025-01-27*
*åŸºäºå“åº”å¼é‡æ„ç‰ˆæœ¬ï¼šv2.0*
*å…³è”æ–‡æ¡£ï¼š16-Vue3å“åº”å¼é‡æ„æ–¹æ¡ˆ-æ ¸å¿ƒæ•°æ®ä¸è¡Œä¸ºåˆ†ç¦».md, 10-ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®è®¾è®¡-ç±»å‹è®¾è®¡.md*
