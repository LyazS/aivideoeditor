# ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®è®¾è®¡ - ä½¿ç”¨ç¤ºä¾‹ï¼ˆå“åº”å¼é‡æ„ç‰ˆï¼‰

## æ¦‚è¿°

åŸºäº"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"çš„é‡æ„æ–¹æ¡ˆï¼Œç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®é‡‡ç”¨ä¸æ•°æ®æºã€åª’ä½“é¡¹ç›®ä¸€è‡´çš„å“åº”å¼æ¶æ„æ¨¡å¼ï¼Œ**å®Œå…¨ç§»é™¤å¤æ‚çš„ä¸Šä¸‹æ–‡æ¨¡æ¿ç³»ç»Ÿ**ï¼Œæ”¹ä¸ºç›´æ¥åŸºäºå…³è”åª’ä½“é¡¹ç›®çŠ¶æ€è®¡ç®—UIæ˜¾ç¤ºä¿¡æ¯ã€‚

## é‡æ„èƒŒæ™¯

### æ¶æ„ä¸€è‡´æ€§é—®é¢˜
å½“å‰ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®ä½¿ç”¨ç±»æ¨¡å¼ï¼Œä¸å·²é‡æ„çš„æ•°æ®æºã€åª’ä½“é¡¹ç›®çš„"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"æ¨¡å¼ä¸ä¸€è‡´ï¼š
- æ•°æ®æºå’Œåª’ä½“é¡¹ç›®ï¼šå·²é‡‡ç”¨å“åº”å¼æ•°æ®å¯¹è±¡ + æ— çŠ¶æ€å‡½æ•°
- æ—¶é—´è½´é¡¹ç›®ï¼šä»ä½¿ç”¨ç±»å®ä¾‹ï¼Œå­˜åœ¨å“åº”å¼æ”¯æŒé—®é¢˜

### è§£å†³æ–¹æ¡ˆ
é‡‡ç”¨ç»Ÿä¸€çš„"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"æ¨¡å¼ï¼š
- **æ ¸å¿ƒæ•°æ®**ï¼šçº¯ç²¹çš„å“åº”å¼çŠ¶æ€å¯¹è±¡ï¼Œä½¿ç”¨ `reactive()` åŒ…è£…
- **è¡Œä¸ºå‡½æ•°**ï¼šæ— çŠ¶æ€çš„çº¯å‡½æ•°ï¼Œæ“ä½œæ•°æ®å¯¹è±¡
- **çŠ¶æ€æ˜¾ç¤º**ï¼šç›´æ¥åŸºäºå…³è”åª’ä½“é¡¹ç›®çŠ¶æ€è®¡ç®—ï¼Œæ— éœ€å¤æ‚ä¸Šä¸‹æ–‡æ¨¡æ¿

## å“åº”å¼æ•°æ®ç»“æ„è®¾è®¡

### 1. ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®æ•°æ®æ¥å£

```typescript
import { reactive } from 'vue'
import type { MediaType } from '@/types'

/**
 * ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®æ•°æ®æ¥å£ - çº¯å“åº”å¼çŠ¶æ€å¯¹è±¡
 *
 * è®¾è®¡ç†å¿µï¼š
 * - ç§»é™¤å¤æ‚çš„ statusContextï¼ŒçŠ¶æ€æ˜¾ç¤ºç›´æ¥åŸºäºå…³è”åª’ä½“é¡¹ç›®è®¡ç®—
 * - ä¿æŒæ•°æ®ç»“æ„ç®€æ´ï¼Œä¸“æ³¨äºæ—¶é—´è½´é¡¹ç›®çš„æ ¸å¿ƒå±æ€§
 * - é€šè¿‡ mediaItemId å…³è”åª’ä½“é¡¹ç›®ï¼Œå®ç°çŠ¶æ€åŒæ­¥
 */
export interface UnifiedTimelineItemData {
  // ==================== æ ¸å¿ƒå±æ€§ ====================
  readonly id: string
  mediaItemId: string // å…³è”çš„ç»Ÿä¸€åª’ä½“é¡¹ç›®ID
  trackId?: string

  // ==================== çŠ¶æ€ç®¡ç† ====================
  timelineStatus: TimelineItemStatus // ä»…3çŠ¶æ€ï¼šready|loading|error

  // ==================== åª’ä½“ä¿¡æ¯ ====================
  mediaType: MediaType | 'unknown' // ä»å…³è”çš„åª’ä½“é¡¹ç›®åŒæ­¥

  // ==================== æ—¶é—´èŒƒå›´ ====================
  timeRange: {
    timelineStartTime: number // æ—¶é—´è½´å¼€å§‹æ—¶é—´ï¼ˆå¸§æ•°ï¼‰
    timelineEndTime: number   // æ—¶é—´è½´ç»“æŸæ—¶é—´ï¼ˆå¸§æ•°ï¼‰
  }

  // ==================== åŸºç¡€é…ç½® ====================
  config: BasicTimelineConfig // é™æ€é…ç½®ä¿¡æ¯

  // ==================== Spriteå¼•ç”¨ ====================
  spriteId?: string // Sprite IDï¼Œç”±SpriteLifecycleManagerç®¡ç†
}

/**
 * æ—¶é—´è½´é¡¹ç›®çŠ¶æ€æšä¸¾ - ç®€åŒ–ä¸º3ä¸ªæ ¸å¿ƒçŠ¶æ€
 */
export type TimelineItemStatus = 'loading' | 'ready' | 'error'

/**
 * åª’ä½“çŠ¶æ€åˆ°æ—¶é—´è½´çŠ¶æ€çš„æ˜ å°„è¡¨
 */
export const MEDIA_TO_TIMELINE_STATUS_MAP = {
  'pending': 'loading',           // ç­‰å¾…å¼€å§‹ â†’ åŠ è½½ä¸­
  'asyncprocessing': 'loading',   // å¼‚æ­¥å¤„ç†ä¸­ â†’ åŠ è½½ä¸­
  'webavdecoding': 'loading',     // WebAVè§£æä¸­ â†’ åŠ è½½ä¸­
  'ready': 'ready',               // å°±ç»ª â†’ å°±ç»ª
  'error': 'error',               // é”™è¯¯ â†’ é”™è¯¯
  'cancelled': 'error',           // å·²å–æ¶ˆ â†’ é”™è¯¯
  'missing': 'error'              // æ–‡ä»¶ç¼ºå¤± â†’ é”™è¯¯
} as const
```

## çŠ¶æ€æ˜¾ç¤ºè®¡ç®—ç¤ºä¾‹

### 1. åŸºäºå…³è”åª’ä½“é¡¹ç›®çš„çŠ¶æ€æ˜¾ç¤º

```typescript
import { TimelineStatusDisplayUtils } from '@/unified/timelineitem'
import { useUnifiedStore } from '@/unified/unifiedStore'

/**
 * è·å–æ—¶é—´è½´é¡¹ç›®çš„çŠ¶æ€æ˜¾ç¤ºä¿¡æ¯
 * ç›´æ¥åŸºäºå…³è”çš„åª’ä½“é¡¹ç›®çŠ¶æ€è®¡ç®—ï¼Œæ— éœ€å¤æ‚çš„ä¸Šä¸‹æ–‡æ¨¡æ¿
 */
function getTimelineDisplayInfo(timelineData: UnifiedTimelineItemData): StatusDisplayInfo {
  // 1. è·å–å…³è”çš„åª’ä½“é¡¹ç›®
  const unifiedStore = useUnifiedStore()
  const mediaData = unifiedStore.getMediaItem(timelineData.mediaItemId)

  // 2. ç›´æ¥åŸºäºåª’ä½“é¡¹ç›®çŠ¶æ€è®¡ç®—æ˜¾ç¤ºä¿¡æ¯
  return TimelineStatusDisplayUtils.getStatusDisplayInfo(mediaData)
}

/**
 * ä½¿ç”¨ç¤ºä¾‹ï¼šæ˜¾ç¤ºæ—¶é—´è½´é¡¹ç›®çŠ¶æ€
 */
function displayTimelineStatus(timelineData: UnifiedTimelineItemData) {
  const displayInfo = getTimelineDisplayInfo(timelineData)

  console.log(`çŠ¶æ€æ–‡æœ¬: ${displayInfo.text}`)

  if (displayInfo.hasProgress) {
    const progressText = displayInfo.speed
      ? `${displayInfo.percent}% (${displayInfo.speed})`
      : `${displayInfo.percent}%`
    console.log(`è¿›åº¦: ${progressText}`)
  }

  if (displayInfo.hasError) {
    console.log(`é”™è¯¯: ${displayInfo.errorMessage}`)
    console.log(`å¯é‡è¯•: ${displayInfo.recoverable}`)
  }
}
```

### 2. å“åº”å¼è¡Œä¸ºå‡½æ•°ç¤ºä¾‹

```typescript
import { reactive } from 'vue'
import { generateUUID4 } from '@/utils'

// ==================== å·¥å‚å‡½æ•° ====================

/**
 * åˆ›å»ºå“åº”å¼æ—¶é—´è½´é¡¹ç›®æ•°æ®å¯¹è±¡
 */
export function createTimelineItemData(options: {
  mediaItemId: string
  trackId?: string
  timeRange: { timelineStartTime: number; timelineEndTime: number }
  config: BasicTimelineConfig
  mediaType?: MediaType
}): UnifiedTimelineItemData {
  return reactive({
    id: generateUUID4(),
    mediaItemId: options.mediaItemId,
    trackId: options.trackId,
    timelineStatus: 'loading' as TimelineItemStatus,
    mediaType: options.mediaType || 'unknown',
    timeRange: options.timeRange,
    config: options.config
  })
}

// ==================== çŠ¶æ€è½¬æ¢è¡Œä¸ºå‡½æ•° ====================

/**
 * çŠ¶æ€è½¬æ¢è¡Œä¸ºå‡½æ•° - æ— çŠ¶æ€çº¯å‡½æ•°
 * åŸºäºç®€åŒ–çš„3çŠ¶æ€è½¬æ¢ï¼ŒçŠ¶æ€æ˜¾ç¤ºä¿¡æ¯é€šè¿‡å…³è”åª’ä½“é¡¹ç›®è®¡ç®—
 */
export async function transitionTimelineStatus(
  data: UnifiedTimelineItemData,
  newStatus: TimelineItemStatus
): Promise<void> {
  if (!canTransitionTo(data, newStatus)) {
    throw new Error(`Invalid timeline transition: ${data.timelineStatus} â†’ ${newStatus}`)
  }

  const oldStatus = data.timelineStatus
  data.timelineStatus = newStatus // âœ… è‡ªåŠ¨è§¦å‘å“åº”å¼æ›´æ–°

  // ç²¾çµç”Ÿå‘½å‘¨æœŸç®¡ç† - æ›´æ¸…æ™°çš„3åˆ†æ”¯
  await handleSpriteLifecycle(data, oldStatus, newStatus)

  console.log(`âœ… æ—¶é—´è½´é¡¹ç›®çŠ¶æ€è½¬æ¢: ${oldStatus} â†’ ${newStatus}`)
}

/**
 * Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†å‡½æ•°
 */
async function handleSpriteLifecycle(
  data: UnifiedTimelineItemData,
  oldStatus: TimelineItemStatus,
  newStatus: TimelineItemStatus
): Promise<void> {
  switch (newStatus) {
    case 'ready':
      // åªåœ¨readyæ—¶åˆ›å»ºspriteï¼Œæ‰€æœ‰å‡†å¤‡å·¥ä½œå·²å®Œæˆ
      if (oldStatus !== 'ready') {
        await createSprite(data)
      }
      break

    case 'loading':           // ä¿æŒç°çŠ¶ä¸å˜
    case 'error':            // æ¸…ç†èµ„æº
    default:
      if (oldStatus === 'ready') {
        await destroySprite(data)
      }
  }
}

/**
 * åˆ›å»ºSpriteå‡½æ•°
 */
async function createSprite(data: UnifiedTimelineItemData): Promise<void> {
  // è·å–å…³è”çš„åª’ä½“é¡¹ç›®
  const mediaData = getMediaItemData(data.mediaItemId)
  if (!mediaData) {
    throw new Error('æ— æ³•æ‰¾åˆ°å…³è”çš„åª’ä½“é¡¹ç›®')
  }

  // æ£€æŸ¥åª’ä½“é¡¹ç›®æ˜¯å¦å°±ç»ª
  if (mediaData.mediaStatus !== 'ready') {
    throw new Error('å…³è”çš„åª’ä½“é¡¹ç›®å°šæœªå°±ç»ª')
  }

  // é€šè¿‡ SpriteLifecycleManager åˆ›å»ºå¹¶æ·»åŠ  Sprite
  const spriteId = await SpriteLifecycleManager.createAndAddSprite(
    mediaData,
    data
  )

  data.spriteId = spriteId // âœ… å“åº”å¼æ›´æ–°
}

/**
 * é”€æ¯Spriteå‡½æ•°
 */
async function destroySprite(data: UnifiedTimelineItemData): Promise<void> {
  if (!data.spriteId) {
    return
  }

  // é€šè¿‡ SpriteLifecycleManager ç§»é™¤ Spriteï¼ˆAVCanvas ä¼šè‡ªåŠ¨é”€æ¯ï¼‰
  await SpriteLifecycleManager.removeSprite(data.spriteId)
  data.spriteId = undefined // âœ… å“åº”å¼æ›´æ–°
}

// ==================== æŸ¥è¯¢å‡½æ•° ====================

/**
 * çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°
 */
export function canTransitionTo(
  data: UnifiedTimelineItemData,
  newStatus: TimelineItemStatus
): boolean {
  // 3çŠ¶æ€é—´çš„ç®€å•è§„åˆ™
  const VALID_TIMELINE_TRANSITIONS: Record<TimelineItemStatus, TimelineItemStatus[]> = {
    'loading': ['ready', 'error'],
    'ready': ['loading', 'error'],
    'error': ['loading']
  }

  const allowed = VALID_TIMELINE_TRANSITIONS[data.timelineStatus]
  return allowed?.includes(newStatus) ?? false
}

// ==================== ä¾¿æ·æ“ä½œå‡½æ•° ====================

/**
 * è®¾ç½®ä¸ºåŠ è½½çŠ¶æ€
 */
export function setLoading(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'loading')
}

/**
 * è®¾ç½®ä¸ºå°±ç»ªçŠ¶æ€
 */
export function setReady(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'ready')
}

/**
 * è®¾ç½®é”™è¯¯çŠ¶æ€
 */
export function setError(data: UnifiedTimelineItemData): Promise<void> {
  return transitionTimelineStatus(data, 'error')
}
```

## å“åº”å¼çŠ¶æ€è½¬æ¢æµç¨‹ç¤ºä¾‹

### 1. æœ¬åœ°æ–‡ä»¶å¤„ç†æµç¨‹ï¼ˆå“åº”å¼ç‰ˆæœ¬ï¼‰

```typescript
import { watch } from 'vue'
import { createMediaItemData, startMediaProcessing } from '@/unified/mediaitem'
import { createUserSelectedFileSourceData } from '@/unified/sources'
import { detectMediaType } from '@/utils'

// ç”¨æˆ·æ‹–æ‹½æœ¬åœ°æ–‡ä»¶åˆ°æ—¶é—´è½´
async function handleLocalFileDrop(file: File, trackId: string) {
  // 1. åˆ›å»ºå“åº”å¼åª’ä½“é¡¹ç›®æ•°æ®
  const mediaData = createMediaItemData({
    source: createUserSelectedFileSourceData(file),
    mediaType: detectMediaType(file)
  })

  // 2. åˆ›å»ºå“åº”å¼æ—¶é—´è½´é¡¹ç›®æ•°æ®
  const timelineData = createTimelineItemData({
    mediaItemId: mediaData.id,
    trackId,
    timeRange: { timelineStartTime: 0, timelineEndTime: 300 }, // é»˜è®¤5ç§’
    config: createBasicTimelineConfig(file.name)
  })

  // 3. å¼€å§‹åª’ä½“è§£æï¼ˆè‡ªåŠ¨è§¦å‘UIæ›´æ–°ï¼‰
  await startMediaProcessing(mediaData)

  // 4. ç›‘å¬åª’ä½“çŠ¶æ€å˜åŒ–ï¼Œè‡ªåŠ¨åŒæ­¥åˆ°æ—¶é—´è½´
  watchMediaStatus(mediaData, timelineData)
}

// å“åº”å¼çŠ¶æ€åŒæ­¥
function watchMediaStatus(
  mediaData: UnifiedMediaItemData,
  timelineData: UnifiedTimelineItemData
) {
  watch(() => mediaData.mediaStatus, async (newStatus) => {
    const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

    if (timelineData.timelineStatus !== targetTimelineStatus) {
      await transitionTimelineStatus(timelineData, targetTimelineStatus)
    }
  }, { immediate: true })
}
```

**å“åº”å¼æµç¨‹ç‰¹ç‚¹**ï¼š
- âœ… **è‡ªåŠ¨UIæ›´æ–°**ï¼šæ‰€æœ‰çŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘Vueç»„ä»¶é‡æ–°æ¸²æŸ“
- âœ… **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„TypeScriptç±»å‹æ£€æŸ¥
- âœ… **çŠ¶æ€åŒæ­¥**ï¼šåª’ä½“çŠ¶æ€è‡ªåŠ¨æ˜ å°„åˆ°æ—¶é—´è½´çŠ¶æ€
- âœ… **ç®€åŒ–æ¶æ„**ï¼šç§»é™¤å¤æ‚ä¸Šä¸‹æ–‡æ¨¡æ¿ï¼ŒçŠ¶æ€æ˜¾ç¤ºç›´æ¥åŸºäºåª’ä½“é¡¹ç›®è®¡ç®—

### 2. è¿œç¨‹æ–‡ä»¶ä¸‹è½½æµç¨‹ï¼ˆå“åº”å¼ç‰ˆæœ¬ï¼‰

```typescript
import { createRemoteFileSourceData } from '@/unified/sources'
import { extractFilename } from '@/utils'

// è¾“å…¥è¿œç¨‹URLåˆ›å»ºæ—¶é—´è½´é¡¹ç›®
async function handleRemoteUrlAdd(url: string, trackId: string) {
  // 1. åˆ›å»ºå“åº”å¼æ•°æ®å¯¹è±¡
  const mediaData = createMediaItemData({
    source: createRemoteFileSourceData(url),
    mediaType: 'unknown'
  })

  const timelineData = createTimelineItemData({
    mediaItemId: mediaData.id,
    trackId,
    timeRange: { timelineStartTime: 0, timelineEndTime: 300 },
    config: createBasicTimelineConfig(extractFilename(url))
  })

  // 2. å¼€å§‹åª’ä½“å¤„ç†ï¼ˆçŠ¶æ€å˜åŒ–è‡ªåŠ¨åæ˜ åˆ°UIï¼‰
  await startMediaProcessing(mediaData)

  // 3. å»ºç«‹çŠ¶æ€åŒæ­¥ï¼ˆè‡ªåŠ¨æ›´æ–°è¿›åº¦æ¡å’ŒçŠ¶æ€æ˜¾ç¤ºï¼‰
  watchMediaStatus(mediaData, timelineData)
}
```

**å“åº”å¼æµç¨‹ç‰¹ç‚¹**ï¼š
- âœ… **å®æ—¶è¿›åº¦**ï¼šä¸‹è½½è¿›åº¦è‡ªåŠ¨æ›´æ–°åˆ°UIç»„ä»¶
- âœ… **çŠ¶æ€é©±åŠ¨**ï¼šåŸºäºçŠ¶æ€å˜åŒ–è‡ªåŠ¨æ‰§è¡Œåç»­æ“ä½œ
- âœ… **é”™è¯¯å¤„ç†**ï¼šç½‘ç»œé”™è¯¯è‡ªåŠ¨åæ˜ åˆ°æ—¶é—´è½´çŠ¶æ€
- âœ… **ç®€åŒ–é€»è¾‘**ï¼šæ— éœ€æ‰‹åŠ¨ç®¡ç†ä¸‹è½½è¿›åº¦ä¸Šä¸‹æ–‡

### 3. é¡¹ç›®åŠ è½½æµç¨‹ï¼ˆå“åº”å¼ç‰ˆæœ¬ï¼‰

```typescript
// åŠ è½½é¡¹ç›®æ—¶æ¢å¤æ—¶é—´è½´é¡¹ç›®
async function loadProjectTimelineItems(projectConfig: ProjectConfig) {
  const timelineItems: UnifiedTimelineItemData[] = []

  for (const itemConfig of projectConfig.timeline.timelineItems) {
    // 1. åˆ›å»ºå“åº”å¼æ—¶é—´è½´æ•°æ®
    const timelineData = createTimelineItemData({
      mediaItemId: itemConfig.mediaItemId,
      trackId: itemConfig.trackId,
      timeRange: itemConfig.timeRange,
      config: itemConfig.config
    })

    // 2. æ£€æŸ¥å…³è”åª’ä½“é¡¹ç›®çŠ¶æ€
    const mediaData = getMediaItemData(itemConfig.mediaItemId)

    if (mediaData) {
      // åª’ä½“é¡¹ç›®å­˜åœ¨ï¼ŒåŒæ­¥çŠ¶æ€
      const timelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaData.mediaStatus]
      await transitionTimelineStatus(timelineData, timelineStatus)

      // å»ºç«‹çŠ¶æ€åŒæ­¥
      watchMediaStatus(mediaData, timelineData)
    } else {
      // åª’ä½“é¡¹ç›®ä¸å­˜åœ¨ï¼Œæ ‡è®°ä¸ºé”™è¯¯
      await setError(timelineData)
    }

    timelineItems.push(timelineData)
  }

  return timelineItems
}
```

**å“åº”å¼æµç¨‹ç‰¹ç‚¹**ï¼š
- âœ… **çŠ¶æ€æ¢å¤**ï¼šè‡ªåŠ¨æ¢å¤æ—¶é—´è½´é¡¹ç›®çš„æ­£ç¡®çŠ¶æ€
- âœ… **ä¾èµ–æ£€æŸ¥**ï¼šè‡ªåŠ¨éªŒè¯åª’ä½“é¡¹ç›®ä¾èµ–å…³ç³»
- âœ… **é”™è¯¯æ ‡è®°**ï¼šç¼ºå¤±æ–‡ä»¶è‡ªåŠ¨æ ‡è®°ä¸ºé”™è¯¯çŠ¶æ€
- âœ… **å®æ—¶åŒæ­¥**ï¼šåŠ è½½åç»§ç»­ä¿æŒçŠ¶æ€åŒæ­¥

## å“åº”å¼Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†

### 1. å“åº”å¼Spriteç®¡ç†å™¨

```typescript
import type { Raw } from 'vue'
import type { AVCanvas } from '@webav/av-canvas'
import { VideoVisibleSprite, ImageVisibleSprite, AudioVisibleSprite } from '@/utils/sprites'
import { generateUUID4 } from '@/utils'

/**
 * å“åº”å¼Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
 * åŸºäºæ•°æ®é©±åŠ¨çš„Spriteç®¡ç†ï¼Œä¸å“åº”å¼æ—¶é—´è½´é¡¹ç›®æ•°æ®é…åˆ
 */
export class SpriteLifecycleManager {
  private avCanvas: AVCanvas
  private spriteRegistry = new Map<string, Raw<CustomSprite>>() // spriteId -> spriteæ˜ å°„

  constructor(avCanvas: AVCanvas) {
    this.avCanvas = avCanvas
  }

  /**
   * åˆ›å»ºå¹¶æ·»åŠ  Sprite åˆ° AVCanvas
   * è¿”å›spriteIdä¾›æ—¶é—´è½´é¡¹ç›®æ•°æ®å¼•ç”¨
   */
  async createAndAddSprite(
    mediaData: UnifiedMediaItemData,
    timelineData: UnifiedTimelineItemData
  ): Promise<string> {
    const { mediaType, webav } = mediaData

    if (!webav) {
      throw new Error('åª’ä½“é¡¹ç›®WebAVå¯¹è±¡æœªå°±ç»ª')
    }

    // ç”Ÿæˆå”¯ä¸€çš„spriteId
    const spriteId = generateUUID4()

    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ Sprite
    if (timelineData.spriteId && this.spriteRegistry.has(timelineData.spriteId)) {
      console.warn(`æ—¶é—´è½´é¡¹ç›® ${timelineData.id} çš„ Sprite å·²å­˜åœ¨ï¼Œå…ˆç§»é™¤æ—§çš„`)
      await this.removeSprite(timelineData.spriteId)
    }

    let sprite: Raw<CustomSprite>

    // æ ¹æ®åª’ä½“ç±»å‹åˆ›å»ºå¯¹åº”çš„ Sprite
    switch (mediaType) {
      case 'video':
        if (!webav.mp4Clip) throw new Error('è§†é¢‘WebAVå¯¹è±¡ç¼ºå¤±')
        sprite = new VideoVisibleSprite(webav.mp4Clip)
        break

      case 'image':
        if (!webav.imgClip) throw new Error('å›¾ç‰‡WebAVå¯¹è±¡ç¼ºå¤±')
        sprite = new ImageVisibleSprite(webav.imgClip)
        break

      case 'audio':
        if (!webav.audioClip) throw new Error('éŸ³é¢‘WebAVå¯¹è±¡ç¼ºå¤±')
        sprite = new AudioVisibleSprite(webav.audioClip)
        break

      default:
        throw new Error(`ä¸æ”¯æŒçš„åª’ä½“ç±»å‹: ${mediaType}`)
    }

    // è®¾ç½® Sprite çš„åŸºç¡€å±æ€§
    await this.setupSpriteProperties(sprite, timelineData)

    // æ·»åŠ åˆ° AVCanvas
    await this.avCanvas.addSprite(sprite)

    // æ³¨å†Œåˆ°ç®¡ç†å™¨
    this.spriteRegistry.set(spriteId, sprite)

    console.log(`âœ… Sprite å·²åˆ›å»ºå¹¶æ·»åŠ åˆ° AVCanvas: ${spriteId} (${mediaType})`)

    return spriteId
  }

  /**
   * ä» AVCanvas ç§»é™¤ Spriteï¼ˆAVCanvas ä¼šè‡ªåŠ¨é”€æ¯ï¼‰
   */
  async removeSprite(spriteId: string): Promise<void> {
    const sprite = this.spriteRegistry.get(spriteId)
    if (!sprite) {
      console.warn(`æœªæ‰¾åˆ° Sprite: ${spriteId}`)
      return
    }

    try {
      // ä» AVCanvas ç§»é™¤ï¼ˆAVCanvas ä¼šè‡ªåŠ¨é”€æ¯ Spriteï¼‰
      await this.avCanvas.removeSprite(sprite)

      // ä»æ³¨å†Œè¡¨ç§»é™¤
      this.spriteRegistry.delete(spriteId)

      console.log(`ğŸ—‘ï¸ Sprite å·²ä» AVCanvas ç§»é™¤: ${spriteId}`)
    } catch (error) {
      console.error(`âŒ Sprite ç§»é™¤å¤±è´¥: ${spriteId}`, error)
      throw error
    }
  }

  /**
   * è®¾ç½®SpriteåŸºç¡€å±æ€§
   */
  private async setupSpriteProperties(
    sprite: Raw<CustomSprite>,
    timelineData: UnifiedTimelineItemData
  ): Promise<void> {
    // è®¾ç½®æ—¶é—´èŒƒå›´
    sprite.setTimeRange({
      timelineStartTime: timelineData.timeRange.timelineStartTime,
      timelineEndTime: timelineData.timeRange.timelineEndTime
    })

    // è®¾ç½®åŸºç¡€å˜æ¢å±æ€§
    const config = timelineData.config
    if (config.transform) {
      sprite.setTransform(config.transform)
    }

    // è®¾ç½®å…¶ä»–å±æ€§...
  }

  /**
   * è·å–Spriteå®ä¾‹ï¼ˆç”¨äºç›´æ¥æ“ä½œï¼‰
   */
  getSprite(spriteId: string): Raw<CustomSprite> | undefined {
    return this.spriteRegistry.get(spriteId)
  }

  /**
   * æ›´æ–°Spriteå±æ€§ï¼ˆå“åº”å¼æ›´æ–°ï¼‰
   */
  async updateSpriteProperties(
    spriteId: string,
    updates: Partial<{
      timeRange: { timelineStartTime: number; timelineEndTime: number }
      transform: TransformData
      opacity: number
    }>
  ): Promise<void> {
    const sprite = this.spriteRegistry.get(spriteId)
    if (!sprite) {
      console.warn(`æœªæ‰¾åˆ° Sprite: ${spriteId}`)
      return
    }

    if (updates.timeRange) {
      sprite.setTimeRange(updates.timeRange)
    }

    if (updates.transform) {
      sprite.setTransform(updates.transform)
    }

    if (updates.opacity !== undefined) {
      sprite.setOpacity(updates.opacity)
    }
  }
}
```

### 2. å“åº”å¼çŠ¶æ€åŒæ­¥ç®¡ç†

```typescript
import { watch, type WatchStopHandle } from 'vue'

/**
 * å“åº”å¼æ—¶é—´è½´é¡¹ç›®ä¸åª’ä½“é¡¹ç›®çš„çŠ¶æ€åŒæ­¥ç®¡ç†å™¨
 * åŸºäºVue3çš„watchæœºåˆ¶å®ç°è‡ªåŠ¨çŠ¶æ€åŒæ­¥
 */
export class TimelineMediaSyncManager {
  private timelineItems = new Map<string, UnifiedTimelineItemData>()
  private mediaItems = new Map<string, UnifiedMediaItemData>()
  private watchStopHandles = new Map<string, WatchStopHandle>() // ç”¨äºæ¸…ç†watch

  /**
   * æ³¨å†Œæ—¶é—´è½´é¡¹ç›®ï¼Œå»ºç«‹ä¸åª’ä½“é¡¹ç›®çš„å“åº”å¼å…³è”
   */
  registerTimelineItem(timelineData: UnifiedTimelineItemData) {
    this.timelineItems.set(timelineData.id, timelineData)

    // æ£€æŸ¥å…³è”åª’ä½“é¡¹ç›®çš„çŠ¶æ€
    const mediaData = this.mediaItems.get(timelineData.mediaItemId)
    if (mediaData) {
      this.setupMediaStatusSync(timelineData, mediaData)
    } else {
      console.error(`âŒ TimelineItem ${timelineData.id} æ‰¾ä¸åˆ°å…³è”çš„MediaItem ${timelineData.mediaItemId}`)
    }
  }

  /**
   * å»ºç«‹åª’ä½“é¡¹ç›®çŠ¶æ€åˆ°æ—¶é—´è½´é¡¹ç›®çŠ¶æ€çš„å“åº”å¼åŒæ­¥
   */
  private setupMediaStatusSync(
    timelineData: UnifiedTimelineItemData,
    mediaData: UnifiedMediaItemData
  ) {
    // ä½¿ç”¨Vue3çš„watchå»ºç«‹å“åº”å¼åŒæ­¥
    const stopHandle = watch(
      () => mediaData.mediaStatus,
      async (newStatus) => {
        const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

        if (timelineData.timelineStatus !== targetTimelineStatus) {
          // è§¦å‘æ—¶é—´è½´é¡¹ç›®çŠ¶æ€è½¬æ¢ï¼ˆè‡ªåŠ¨è§¦å‘UIæ›´æ–°ï¼‰
          await transitionTimelineStatus(timelineData, targetTimelineStatus)

          console.log(`ğŸ”„ çŠ¶æ€åŒæ­¥: MediaItem(${newStatus}) â†’ TimelineItem(${targetTimelineStatus})`)
        }
      },
      { immediate: true } // ç«‹å³æ‰§è¡Œä¸€æ¬¡åŒæ­¥å½“å‰çŠ¶æ€
    )

    // ä¿å­˜åœæ­¢å¥æŸ„ï¼Œç”¨äºæ¸…ç†
    this.watchStopHandles.set(timelineData.id, stopHandle)
  }

  /**
   * å“åº”å¼æ—¶é—´è½´é¡¹ç›®å·¥å‚æ–¹æ³•
   * ç¡®ä¿åªæœ‰readyçŠ¶æ€çš„MediaItemæ‰èƒ½ç›´æ¥åˆ›å»ºreadyçš„TimelineItem
   */
  createTimelineItem(
    mediaItemId: string,
    trackId: string,
    timeRange: { timelineStartTime: number; timelineEndTime: number },
    config: BasicTimelineConfig
  ): UnifiedTimelineItemData | null {
    const mediaData = this.mediaItems.get(mediaItemId)

    if (!mediaData) {
      console.error(`âŒ æ‰¾ä¸åˆ°MediaItem: ${mediaItemId}`)
      return null
    }

    // åˆ›å»ºå“åº”å¼TimelineItemæ•°æ®
    const timelineData = createTimelineItemData({
      mediaItemId,
      trackId,
      timeRange,
      config,
      mediaType: mediaData.mediaType
    })

    // æ ¹æ®MediaItemçŠ¶æ€è®¾ç½®åˆå§‹çŠ¶æ€
    const initialStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaData.mediaStatus]

    // åŒæ­¥è®¾ç½®åˆå§‹çŠ¶æ€ï¼ˆä¸éœ€è¦awaitï¼Œå› ä¸ºæ˜¯åŒæ­¥æ“ä½œï¼‰
    timelineData.timelineStatus = initialStatus

    // æ³¨å†Œåˆ°ç®¡ç†å™¨ï¼ˆå»ºç«‹å“åº”å¼åŒæ­¥ï¼‰
    this.registerTimelineItem(timelineData)

    console.log(`âœ… åˆ›å»ºæ—¶é—´è½´é¡¹ç›®: ${timelineData.id}, åˆå§‹çŠ¶æ€: ${initialStatus}`)

    return timelineData
  }

  /**
   * æ³¨å†Œåª’ä½“é¡¹ç›®
   */
  registerMediaItem(mediaData: UnifiedMediaItemData) {
    this.mediaItems.set(mediaData.id, mediaData)
  }

  /**
   * æ¸…ç†æ—¶é—´è½´é¡¹ç›®ï¼ˆåœæ­¢å“åº”å¼ç›‘å¬ï¼‰
   */
  unregisterTimelineItem(timelineId: string) {
    // åœæ­¢watchç›‘å¬
    const stopHandle = this.watchStopHandles.get(timelineId)
    if (stopHandle) {
      stopHandle()
      this.watchStopHandles.delete(timelineId)
    }

    // ä»æ³¨å†Œè¡¨ç§»é™¤
    this.timelineItems.delete(timelineId)

    console.log(`ğŸ—‘ï¸ æ¸…ç†æ—¶é—´è½´é¡¹ç›®: ${timelineId}`)
  }
}
```

## Vueç»„ä»¶ä¸­çš„ä½¿ç”¨ç¤ºä¾‹

### 1. æ—¶é—´è½´é¡¹ç›®ç»„ä»¶

```vue
<template>
  <div class="timeline-item" :class="statusClass">
    <!-- åŸºç¡€ä¿¡æ¯æ˜¾ç¤º -->
    <div class="item-header">
      <span class="item-name">{{ timelineData.config.name }}</span>
      <span class="item-status">{{ statusInfo.text }}</span>
    </div>

    <!-- è¿›åº¦æ˜¾ç¤º -->
    <div v-if="statusInfo.hasProgress" class="progress-bar">
      <div
        class="progress-fill"
        :style="{ width: `${statusInfo.percent}%` }"
      ></div>
      <span class="progress-text">{{ progressText }}</span>
    </div>

    <!-- é”™è¯¯ä¿¡æ¯æ˜¾ç¤º -->
    <div v-if="statusInfo.hasError" class="error-info">
      <span class="error-message">{{ statusInfo.errorMessage }}</span>
      <button v-if="statusInfo.recoverable" @click="handleRetry">é‡è¯•</button>
    </div>

    <!-- Spriteæ§åˆ¶ -->
    <div v-if="timelineData.spriteId" class="sprite-controls">
      <button @click="updateOpacity(0.5)">åŠé€æ˜</button>
      <button @click="updateOpacity(1.0)">ä¸é€æ˜</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, inject } from 'vue'
import type { UnifiedTimelineItemData } from '@/unified/timelineitem'
import { TimelineStatusDisplayUtils } from '@/unified/timelineitem'
import { useUnifiedStore } from '@/unified/unifiedStore'
import { setLoading } from '@/unified/timelineitem/behaviors'

// æ³¨å…¥ä¾èµ–
const spriteManager = inject<SpriteLifecycleManager>('spriteManager')!
const unifiedStore = useUnifiedStore()

// Props
interface Props {
  timelineData: UnifiedTimelineItemData
}
const props = defineProps<Props>()

// è®¡ç®—å±æ€§ - è‡ªåŠ¨å“åº”æ•°æ®å˜åŒ–
const statusClass = computed(() => {
  return `status-${props.timelineData.timelineStatus}`
})

// åŸºäºå…³è”åª’ä½“é¡¹ç›®è®¡ç®—çŠ¶æ€æ˜¾ç¤ºä¿¡æ¯
const mediaData = computed(() => unifiedStore.getMediaItem(props.timelineData.mediaItemId))

const statusInfo = computed(() =>
  TimelineStatusDisplayUtils.getStatusDisplayInfo(mediaData.value)
)

const progressText = computed(() => {
  if (!statusInfo.value.hasProgress) return ''

  return statusInfo.value.speed
    ? `${statusInfo.value.percent}% (${statusInfo.value.speed})`
    : `${statusInfo.value.percent}%`
})

// æ–¹æ³•
async function handleRetry() {
  // é‡æ–°å¼€å§‹å¤„ç†æµç¨‹
  await setLoading(props.timelineData)
}

async function updateOpacity(opacity: number) {
  if (!props.timelineData.spriteId) return

  await spriteManager.updateSpriteProperties(props.timelineData.spriteId, {
    opacity
  })
}
</script>
```

### 2. æ—¶é—´è½´ç®¡ç†ç»„ä»¶

```vue
<template>
  <div class="timeline-manager">
    <div class="timeline-tracks">
      <div
        v-for="track in tracks"
        :key="track.id"
        class="track"
      >
        <div class="track-header">{{ track.name }}</div>
        <div class="track-items">
          <TimelineItemComponent
            v-for="item in getTrackItems(track.id)"
            :key="item.id"
            :timeline-data="item"
            @update="handleItemUpdate"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, provide, onMounted, onUnmounted, inject } from 'vue'
import type { UnifiedTimelineItemData } from '@/unified/timelineitem'
import { TimelineMediaSyncManager, SpriteLifecycleManager } from '@/unified/timelineitem'
import type { AVCanvas } from '@webav/av-canvas'

// æ³¨å…¥AVCanvas
const avCanvas = inject<AVCanvas>('avCanvas')!

// å“åº”å¼æ•°æ®
const timelineItems = ref<UnifiedTimelineItemData[]>([])
const tracks = ref([
  { id: 'video-1', name: 'è§†é¢‘è½¨é“ 1' },
  { id: 'audio-1', name: 'éŸ³é¢‘è½¨é“ 1' }
])

// ç®¡ç†å™¨å®ä¾‹
const syncManager = new TimelineMediaSyncManager()
const spriteManager = new SpriteLifecycleManager(avCanvas)

// æä¾›ç»™å­ç»„ä»¶
provide('syncManager', syncManager)
provide('spriteManager', spriteManager)

// è®¡ç®—å±æ€§
const getTrackItems = computed(() => (trackId: string) => {
  return timelineItems.value.filter(item => item.trackId === trackId)
})

// æ–¹æ³•
function handleItemUpdate(itemData: UnifiedTimelineItemData) {
  // å“åº”å¼æ•°æ®è‡ªåŠ¨æ›´æ–°UIï¼Œæ— éœ€æ‰‹åŠ¨å¤„ç†
  console.log('æ—¶é—´è½´é¡¹ç›®å·²æ›´æ–°:', itemData.id)
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // åˆå§‹åŒ–æ—¶é—´è½´é¡¹ç›®
  loadTimelineItems()
})

onUnmounted(() => {
  // æ¸…ç†æ‰€æœ‰watchç›‘å¬
  timelineItems.value.forEach(item => {
    syncManager.unregisterTimelineItem(item.id)
  })
})

async function loadTimelineItems() {
  // ä»é¡¹ç›®é…ç½®åŠ è½½æ—¶é—´è½´é¡¹ç›®
  const items = await loadProjectTimelineItems(projectConfig)
  timelineItems.value = items
}
</script>
```

## å“åº”å¼é‡æ„çš„ä¼˜åŠ¿æ€»ç»“

### 1. æ¶æ„ä¸€è‡´æ€§
- **ç»Ÿä¸€æ¨¡å¼**ï¼šæ•°æ®æºã€åª’ä½“é¡¹ç›®ã€æ—¶é—´è½´é¡¹ç›®éƒ½é‡‡ç”¨"æ ¸å¿ƒæ•°æ® + è¡Œä¸ºåˆ†ç¦»"
- **å“åº”å¼æ”¯æŒ**ï¼šæ‰€æœ‰çŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘Vueç»„ä»¶æ›´æ–°
- **ç®€åŒ–è®¾è®¡**ï¼šç§»é™¤å¤æ‚çš„ä¸Šä¸‹æ–‡æ¨¡æ¿ç³»ç»Ÿï¼ŒçŠ¶æ€æ˜¾ç¤ºç›´æ¥åŸºäºåª’ä½“é¡¹ç›®è®¡ç®—

### 2. å¼€å‘ä½“éªŒæå‡
- **è‡ªåŠ¨æ›´æ–°**ï¼šæ— éœ€æ‰‹åŠ¨è°ƒç”¨UIæ›´æ–°æ–¹æ³•
- **è°ƒè¯•ä¾¿åˆ©**ï¼šVue DevToolså¯ä»¥ç›´æ¥æŸ¥çœ‹æ‰€æœ‰çŠ¶æ€å˜åŒ–
- **ä»£ç ç®€æ´**ï¼šæ¶ˆé™¤äº†å¤æ‚çš„ä¸Šä¸‹æ–‡ç®¡ç†å’Œæ¨¡æ¿ç³»ç»Ÿ

### 3. ç»´æŠ¤æ€§æ”¹å–„
- **èŒè´£æ¸…æ™°**ï¼šæ•°æ®ã€è¡Œä¸ºã€UIå®Œå…¨åˆ†ç¦»
- **æ˜“äºæµ‹è¯•**ï¼šçº¯å‡½æ•°æ˜“äºå•å…ƒæµ‹è¯•
- **çŠ¶æ€ä¸€è‡´æ€§**ï¼šçŠ¶æ€æ˜¾ç¤ºç›´æ¥åŸºäºæ•°æ®æºï¼Œé¿å…ä¸ä¸€è‡´é—®é¢˜

### 4. æ€§èƒ½ä¼˜åŒ–
- **ç²¾ç¡®æ›´æ–°**ï¼šVue3çš„å“åº”å¼ç³»ç»Ÿåªæ›´æ–°å˜åŒ–çš„éƒ¨åˆ†
- **å†…å­˜ç®¡ç†**ï¼šè‡ªåŠ¨æ¸…ç†ä¸å†ä½¿ç”¨çš„watchç›‘å¬
- **å‡å°‘è®¡ç®—**ï¼šç§»é™¤å¤æ‚çš„ä¸Šä¸‹æ–‡è®¡ç®—ï¼Œç›´æ¥ä½¿ç”¨åª’ä½“é¡¹ç›®çŠ¶æ€

## å®ç°å»ºè®®

### 1. è¿ç§»ç­–ç•¥
1. **ç§»é™¤æ—§ç³»ç»Ÿ**ï¼šåˆ é™¤æ‰€æœ‰ statusContext å’Œä¸Šä¸‹æ–‡æ¨¡æ¿ç›¸å…³ä»£ç 
2. **æ›´æ–°ç»„ä»¶**ï¼šæ”¹ä¸ºä½¿ç”¨ TimelineStatusDisplayUtils è®¡ç®—çŠ¶æ€æ˜¾ç¤º
3. **ç®€åŒ–æ¥å£**ï¼šæ—¶é—´è½´é¡¹ç›®æ•°æ®ç»“æ„åªä¿ç•™æ ¸å¿ƒå±æ€§
4. **æµ‹è¯•éªŒè¯**ï¼šç¡®ä¿çŠ¶æ€æ˜¾ç¤ºåŠŸèƒ½æ­£å¸¸å·¥ä½œ

### 2. æµ‹è¯•é‡ç‚¹
- **çŠ¶æ€æ˜¾ç¤ºæµ‹è¯•**ï¼šéªŒè¯åŸºäºåª’ä½“é¡¹ç›®çŠ¶æ€çš„æ˜¾ç¤ºè®¡ç®—
- **å“åº”å¼æ›´æ–°æµ‹è¯•**ï¼šéªŒè¯çŠ¶æ€å˜åŒ–è‡ªåŠ¨è§¦å‘UIæ›´æ–°
- **çŠ¶æ€åŒæ­¥æµ‹è¯•**ï¼šéªŒè¯åª’ä½“é¡¹ç›®ä¸æ—¶é—´è½´é¡¹ç›®çŠ¶æ€åŒæ­¥
- **Spriteç”Ÿå‘½å‘¨æœŸæµ‹è¯•**ï¼šéªŒè¯Spriteçš„åˆ›å»ºã€æ›´æ–°ã€é”€æ¯

---

*æ–‡æ¡£æ›´æ–°æ—¶é—´ï¼š2025-01-27*
*åŸºäºå“åº”å¼é‡æ„ç‰ˆæœ¬ï¼šv2.0 - ç§»é™¤ä¸Šä¸‹æ–‡æ¨¡æ¿ç³»ç»Ÿ*
*å…³è”æ–‡æ¡£ï¼š16-Vue3å“åº”å¼é‡æ„æ–¹æ¡ˆ-æ ¸å¿ƒæ•°æ®ä¸è¡Œä¸ºåˆ†ç¦».md, 10-ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®è®¾è®¡-ç±»å‹è®¾è®¡.md*
