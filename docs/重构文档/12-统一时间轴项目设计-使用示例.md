# 统一时间轴项目设计 - 使用示例

## 类型安全使用示例

### 1. 基本使用示例

```typescript
/**
 * 使用示例
 */
function updateTimelineStatus(context: TimelineStatusContext) {
  switch (context.stage) {
    case 'downloading':
      // TypeScript 知道这里是 DownloadContext
      console.log(`下载进度: ${context.progress.percent}%`)
      if (context.downloadSpeed) {
        console.log(`下载速度: ${context.downloadSpeed}`)
      }
      break

    case 'parsing':
      // TypeScript 知道这里是 ParseContext
      console.log(`解析进度: ${context.progress.percent}%`)
      if (context.currentStep) {
        console.log(`当前步骤: ${context.currentStep}`)
      }
      break

    case 'error':
      // TypeScript 知道这里是 ErrorContext
      console.log(`错误: ${context.error.message}`)
      if (context.error.recoverable) {
        console.log('可以重试')
      }
      break
  }
}
```

### 2. 状态转换实现示例

```typescript
class UnifiedTimelineItemImpl implements UnifiedTimelineItem {
  private _sprite?: Raw<CustomSprite>

  /**
   * 基于3状态 + 类型安全 TimelineStatusContext 的转换
   *
   * 精简实现：无需复杂的before/after状态处理
   */
  async transitionTo(newStatus: TimelineItemStatus, context?: TimelineStatusContext): Promise<void> {
    if (!this.canTransitionTo(newStatus)) {
      throw new Error(`Invalid timeline transition: ${this.timelineStatus} → ${newStatus}`)
    }

    const oldStatus = this.timelineStatus
    this.timelineStatus = newStatus
    this.statusContext = context // 统一存储所有差异信息

    // 精灵生命周期管理 - 更清晰的3分支
    await this.handleSpriteLifecycle(oldStatus, newStatus)
    this.updateUIState() // 统一更新UI

    // 触发钩子时传递完整的上下文
    this.onStatusChanged?.(oldStatus, newStatus, context)
  }

  private async handleSpriteLifecycle(oldStatus: TimelineItemStatus, newStatus: TimelineItemStatus): Promise<void> {
    switch (newStatus) {
      case 'ready':
        // 只在ready时创建sprite，所有准备工作已完成
        if (oldStatus !== 'ready') {
          await this.createSprite()
        }
        break

      case 'loading':           // 保持现状不变
      case 'error':            // 清理资源
      default:
        if (oldStatus === 'ready') {
          await this.destroySprite()
        }
    }
  }

  private async createSprite(): Promise<Raw<CustomSprite>> {
    // 类型安全的上下文检查
    if (!this.statusContext || !TimelineContextUtils.isReady(this.statusContext)) {
      throw new Error('缺少就绪状态的媒体元数据')
    }

    // 获取关联的媒体项目
    const mediaItem = this.getAssociatedMediaItem() // 需要实现获取媒体项目的方法
    if (!mediaItem) {
      throw new Error('无法找到关联的媒体项目')
    }

    // 通过 SpriteLifecycleManager 创建并添加 Sprite
    const sprite = await SpriteLifecycleManager.createAndAddSprite(
      mediaItem,
      this,
      this.statusContext as ReadyContext
    )

    this._sprite = sprite
    return sprite
  }

  private async destroySprite(): Promise<void> {
    if (!this._sprite) {
      return
    }

    // 通过 SpriteLifecycleManager 移除 Sprite（AVCanvas 会自动销毁）
    await SpriteLifecycleManager.removeSprite(this.id)
    this._sprite = undefined
  }

  private updateUIState(): void {
    // 统一UI更新逻辑，利用类型安全的上下文
    if (!this.statusContext) return

    // 类型安全的状态处理
    if (TimelineContextUtils.hasProgress(this.statusContext)) {
      // TypeScript 知道这里有 progress 属性
      this.updateProgressUI(this.statusContext.progress.percent, this.statusContext.message)
    } else if (TimelineContextUtils.hasError(this.statusContext)) {
      // TypeScript 知道这里有 error 属性
      this.updateErrorUI(this.statusContext.error.message, this.statusContext.error.recoverable)
    } else if (TimelineContextUtils.isReady(this.statusContext)) {
      // TypeScript 知道这里是 ReadyContext
      this.updateReadyUI(this.statusContext.metadata)
    }
  }

  canTransitionTo(newStatus: TimelineItemStatus): boolean {
    // 3状态间的简单规则
    const allowed = VALID_TIMELINE_TRANSITIONS[this.timelineStatus]
    return allowed?.includes(newStatus) ?? false
  }

  // 便捷方法：使用预定义模板创建上下文
  startDownload(): void {
    this.transitionTo('loading', TIMELINE_CONTEXT_TEMPLATES.downloadStart())
  }

  updateDownloadProgress(percent: number, speed?: string): void {
    this.transitionTo('loading', TIMELINE_CONTEXT_TEMPLATES.downloadProgress(percent, speed))
  }

  startParsing(): void {
    this.transitionTo('loading', TIMELINE_CONTEXT_TEMPLATES.parseStart())
  }

  setReady(metadata?: ReadyContext['metadata']): void {
    this.transitionTo('ready', TIMELINE_CONTEXT_TEMPLATES.ready(metadata))
  }

  setError(code: string, message: string, recoverable = true): void {
    this.transitionTo('error', TIMELINE_CONTEXT_TEMPLATES.error(code, message, recoverable))
  }
}
```

## 状态转换流程示例

### 1. 本地文件处理流程（3状态精简版）

```
用户拖拽本地文件 → 创建UnifiedMediaItem(pending)
├─ MediaItem状态: pending → webavdecoding → ready
├─ 在媒体库中显示: loading状态（解析中...）
├─ WebAV解析完成 → MediaItem变为ready（有duration等元数据）
└─ 用户从媒体库拖拽到时间轴 → 创建UnifiedTimelineItem(ready)
   └─ 直接创建sprite，因为MediaItem已经ready
```

**正确的流程特点**：
- ✅ **分离关注点**：媒体解析 vs 时间轴使用
- ✅ **数据完整性**：只有ready的MediaItem才能创建TimelineItem
- ✅ **用户体验**：媒体库显示解析进度，时间轴只接受ready的媒体
- ✅ **避免错误**：防止没有duration的媒体被添加到时间轴

### 2. 远程文件下载流程（3状态精简版）

```
输入远程URL → 创建UnifiedMediaItem(pending)
├─ MediaItem状态: pending → asyncprocessing → webavdecoding → ready
├─ 同时创建UnifiedTimelineItem(loading)
├─ TimelineItem监听MediaItem状态变化
├─ StatusContext: {stage:'downloading', progress:{percent:0, speed:'25KB/s'}}
├─ 下载完成 → StatusContext: {stage:'parsing', message:'正在解析...'}
└─ MediaItem变为ready → TimelineItem变为ready → 创建Sprite
```

**正确的流程特点**：
- ✅ **并行处理**：MediaItem处理下载和解析，TimelineItem显示状态
- ✅ **状态同步**：TimelineItem自动跟随MediaItem的状态变化
- ✅ **进度展示**：通过StatusContext显示下载进度和解析状态
- ✅ **统一管理**：所有异步操作都在MediaItem层面处理

### 3. 项目加载流程（3状态精简版）

```
加载项目配置 → 读取TimelineItem配置 → 查找关联的MediaItem
├─ MediaItem存在且ready？
   ├─ 是：直接创建UnifiedTimelineItem(ready) → 创建Sprite
   └─ 否：创建UnifiedTimelineItem(loading) → 等待MediaItem ready
├─ 源文件存在？
   ├─ 是：创建/恢复UnifiedMediaItem → 解析 → ready
   └─ 否：TimelineItem变为error(StatusContext.stage='file-missing')
```

**正确的流程特点**：
- ✅ **依赖检查**：先确保MediaItem存在且ready
- ✅ **文件验证**：检查源文件是否存在
- ✅ **状态恢复**：根据MediaItem状态决定TimelineItem初始状态
- ✅ **错误处理**：文件缺失时提供重新选择文件的选项

## Sprite生命周期自动化示例

### 1. 状态驱动的Sprite管理

```typescript
/**
 * Sprite生命周期管理器使用示例
 */
class SpriteLifecycleManager {
  private avCanvas: AVCanvas
  private spriteRegistry = new Map<string, Raw<CustomSprite>>() // 跟踪已创建的 Sprite

  constructor(avCanvas: AVCanvas) {
    this.avCanvas = avCanvas
  }

  /**
   * 创建并添加 Sprite 到 AVCanvas
   */
  async createAndAddSprite(
    mediaItem: UnifiedMediaItem,
    timelineItem: UnifiedTimelineItem,
    context?: MediaReadyContext
  ): Promise<Raw<CustomSprite>> {
    const { mediaType, webav } = mediaItem

    if (!webav) {
      throw new Error('媒体项目WebAV对象未就绪')
    }

    // 检查是否已存在 Sprite
    const existingSprite = this.spriteRegistry.get(timelineItem.id)
    if (existingSprite) {
      console.warn(`时间轴项目 ${timelineItem.id} 的 Sprite 已存在，先移除旧的`)
      await this.removeSprite(timelineItem.id)
    }

    let sprite: Raw<CustomSprite>

    // 根据媒体类型创建对应的 Sprite
    switch (mediaType) {
      case 'video':
        if (!webav.mp4Clip) throw new Error('视频WebAV对象缺失')
        sprite = new VideoVisibleSprite(webav.mp4Clip)
        break

      case 'image':
        if (!webav.imgClip) throw new Error('图片WebAV对象缺失')
        sprite = new ImageVisibleSprite(webav.imgClip)
        break

      case 'audio':
        if (!webav.audioClip) throw new Error('音频WebAV对象缺失')
        sprite = new AudioVisibleSprite(webav.audioClip)
        break

      default:
        throw new Error(`不支持的媒体类型: ${mediaType}`)
    }

    // 设置 Sprite 的基础属性
    await this.setupSpriteProperties(sprite, timelineItem)

    // 添加到 AVCanvas
    await this.avCanvas.addSprite(sprite)

    // 注册到管理器
    this.spriteRegistry.set(timelineItem.id, sprite)

    console.log(`✅ Sprite 已创建并添加到 AVCanvas: ${timelineItem.id} (${mediaType})`)

    return sprite
  }

  /**
   * 从 AVCanvas 移除 Sprite（AVCanvas 会自动销毁）
   */
  async removeSprite(timelineItemId: string): Promise<void> {
    const sprite = this.spriteRegistry.get(timelineItemId)
    if (!sprite) {
      console.warn(`未找到时间轴项目 ${timelineItemId} 的 Sprite`)
      return
    }

    try {
      // 从 AVCanvas 移除（AVCanvas 会自动销毁 Sprite）
      await this.avCanvas.removeSprite(sprite)

      // 从注册表移除
      this.spriteRegistry.delete(timelineItemId)

      console.log(`🗑️ Sprite 已从 AVCanvas 移除: ${timelineItemId}`)
    } catch (error) {
      console.error(`❌ Sprite 移除失败: ${timelineItemId}`, error)
      throw error
    }
  }
}
```

### 2. 自动化状态同步示例

```typescript
/**
 * 时间轴项目与媒体项目的状态同步管理器
 */
class TimelineMediaSyncManager {
  private timelineItems = new Map<string, UnifiedTimelineItem>()
  private mediaItems = new Map<string, UnifiedMediaItem>()

  /**
   * 注册时间轴项目，建立与媒体项目的关联
   */
  registerTimelineItem(timelineItem: UnifiedTimelineItem) {
    this.timelineItems.set(timelineItem.id, timelineItem)

    // 检查关联媒体项目的状态
    const mediaItem = this.mediaItems.get(timelineItem.mediaItemId)
    if (mediaItem) {
      // 验证MediaItem是否ready
      if (mediaItem.mediaStatus !== 'ready') {
        console.warn(`⚠️ TimelineItem ${timelineItem.id} 关联的MediaItem ${mediaItem.id} 尚未ready`)
      }
      this.setupMediaStatusSync(timelineItem, mediaItem)
    } else {
      console.error(`❌ TimelineItem ${timelineItem.id} 找不到关联的MediaItem ${timelineItem.mediaItemId}`)
    }
  }

  /**
   * 建立媒体项目状态到时间轴项目状态的同步
   */
  private setupMediaStatusSync(timelineItem: UnifiedTimelineItem, mediaItem: UnifiedMediaItem) {
    // 监听媒体项目状态变化
    mediaItem.onStatusChanged = (oldStatus, newStatus, context) => {
      const targetTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[newStatus]

      if (timelineItem.timelineStatus !== targetTimelineStatus) {
        // 创建时间轴转换上下文
        const timelineContext = this.createTimelineContext(mediaItem, context)

        // 触发时间轴项目状态转换
        timelineItem.transitionTo(targetTimelineStatus, timelineContext)
      }
    }

    // 立即同步当前状态
    const currentTimelineStatus = MEDIA_TO_TIMELINE_STATUS_MAP[mediaItem.mediaStatus]
    if (timelineItem.timelineStatus !== currentTimelineStatus) {
      timelineItem.transitionTo(currentTimelineStatus)
    }
  }

  /**
   * 创建时间轴项目的工厂方法
   *
   * 确保只有ready状态的MediaItem才能创建TimelineItem
   */
  createTimelineItem(
    mediaItemId: string,
    trackId: string,
    timeRange: { timelineStartTime: number; timelineEndTime: number },
    config: BasicTimelineConfig
  ): UnifiedTimelineItem | null {
    const mediaItem = this.mediaItems.get(mediaItemId)

    if (!mediaItem) {
      console.error(`❌ 找不到MediaItem: ${mediaItemId}`)
      return null
    }

    if (mediaItem.mediaStatus !== 'ready') {
      console.error(`❌ MediaItem ${mediaItemId} 尚未ready，当前状态: ${mediaItem.mediaStatus}`)
      return null
    }

    if (!mediaItem.duration || mediaItem.duration <= 0) {
      console.error(`❌ MediaItem ${mediaItemId} 缺少有效的duration: ${mediaItem.duration}`)
      return null
    }

    // 创建TimelineItem
    const timelineItem = new UnifiedTimelineItemImpl({
      id: generateId(),
      mediaItemId,
      trackId,
      timelineStatus: 'ready', // 因为MediaItem已经ready
      statusContext: TIMELINE_CONTEXT_TEMPLATES.ready({
        duration: mediaItem.duration,
        format: mediaItem.format || 'unknown'
      }),
      mediaType: mediaItem.mediaType,
      timeRange,
      config
    })

    // 注册到管理器
    this.registerTimelineItem(timelineItem)

    return timelineItem
  }
}
```

## 实现建议

### 1. 开发顺序
1. **实现基础接口**：UnifiedTimelineItem接口和状态枚举
2. **实现状态机逻辑**：状态转换规则和验证
3. **实现Sprite管理器**：自动化的Sprite生命周期管理
4. **实现状态同步**：媒体项目与时间轴项目的状态同步
5. **集成测试**：端到端测试各种状态转换场景

### 2. 迁移策略
1. **并行开发**：新系统与旧系统并行开发，逐步替换
2. **数据迁移**：提供旧数据格式到新格式的转换工具
3. **向后兼容**：保持API兼容性，平滑过渡
4. **渐进式替换**：按模块逐步替换，降低风险

### 3. 测试重点
- **状态转换测试**：所有合法和非法状态转换的测试
- **Sprite生命周期测试**：创建、更新、销毁的完整测试
- **错误场景测试**：各种异常情况的处理测试
- **性能测试**：大量时间轴项目的性能表现测试

---

*文档创建时间：2025-01-18*
*基于重构文档版本：v1.0*
*关联文档：10-统一时间轴项目设计-类型设计-核心接口.md, 10-统一时间轴项目设计-扩展类型.md*
