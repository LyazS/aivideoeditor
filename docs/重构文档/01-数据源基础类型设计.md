# 数据源基础类型设计

## 概述

数据源是媒体项目获取文件的抽象层，负责处理不同来源的文件获取逻辑。本文档定义了统一的数据源基础类型系统。

## 设计理念

### 1. 职责分离
- **数据源实例**：管理自身状态、提供数据访问接口
- **数据源管理器**：专注任务调度、并发控制、资源管理
- **媒体实例**：处理业务逻辑、状态转换

### 2. 场景区分
根据文件来源的不同特点，设计不同的数据源类型：
- **用户选择文件**：有活跃的File对象，需要验证有效性
- **工程文件路径**：只有路径信息，需要重新定位文件
- **远程文件**：需要下载，支持进度跟踪和并发控制

### 3. 状态映射
数据源的内部状态会映射到媒体项目的抽象状态：
```typescript
// 数据源状态 → 媒体状态映射
DataSource.internalStatus → UnifiedMediaItem.mediaStatus
├── 'pending'     → 'pending'
├── 'acquiring'   → 'asyncprocessing' ✅ 关键映射
├── 'acquired'    → 'webavdecoding' (开始解析文件)
├── 'error'       → 'error'
├── 'cancelled'   → 'cancelled'
└── 'missing'     → 'missing' (仅工程文件)
```

## 基础数据源抽象类

```typescript
/**
 * 数据源基础抽象类 - 统一管理通用逻辑
 *
 * 注意：此抽象类同时作为类型定义使用，无需额外的接口
 * 所有具体数据源都必须继承此类，确保接口一致性
 */
abstract class BaseDataSource {
  protected file: File | null = null
  protected url: string | null = null
  protected status: DataSourceStatus = 'pending'
  protected progress: number = 0
  protected errorMessage?: string
  protected taskId?: string

  constructor(
    protected onUpdate?: (source: BaseDataSource) => void
  ) {}

  // ==================== 通用访问方法 ====================
  abstract getType(): string

  getFile(): File | null {
    return this.file
  }

  getUrl(): string | null {
    return this.url
  }

  getStatus(): DataSourceStatus {
    return this.status
  }

  getProgress(): number {
    return this.progress
  }

  getError(): string | undefined {
    return this.errorMessage
  }

  getTaskId(): string | undefined {
    return this.taskId
  }

  // ==================== 通用操作方法 ====================
  startAcquisition(): void {
    this.taskId = generateTaskId()
    this.executeAcquisition()
  }

  cancel(): void {
    if (this.taskId) {
      this.getManager().cancelAcquisition(this.taskId)
    }
  }

  retry(): void {
    this.reset()
    this.startAcquisition()
  }

  // ==================== 抽象方法 ====================
  /**
   * 获取对应的管理器实例
   */
  protected abstract getManager(): DataSourceManager<BaseDataSource>

  /**
   * 执行具体的获取逻辑
   */
  protected abstract executeAcquisition(): void

  // ==================== 状态管理方法 ====================
  protected setAcquiring(): void {
    this.status = 'acquiring'
    this.progress = 0
    this.errorMessage = undefined
    this.notifyUpdate()
  }

  protected setAcquired(file: File, url: string): void {
    this.file = file
    this.url = url
    this.status = 'acquired'
    this.progress = 100
    this.notifyUpdate()
  }

  protected setError(message: string): void {
    this.status = 'error'
    this.errorMessage = message
    this.notifyUpdate()
  }

  protected setCancelled(): void {
    this.status = 'cancelled'
    this.notifyUpdate()
  }

  protected updateProgress(progress: number): void {
    this.progress = Math.max(0, Math.min(100, progress))
    this.notifyUpdate()
  }

  protected reset(): void {
    this.status = 'pending'
    this.progress = 0
    this.errorMessage = undefined
    this.taskId = undefined
  }

  private notifyUpdate(): void {
    this.onUpdate?.(this)
  }
}

/**
 * 数据源状态类型
 */
type DataSourceStatus =
  | 'pending'     // 等待开始
  | 'acquiring'   // 获取中
  | 'acquired'    // 已获取
  | 'error'       // 错误
  | 'cancelled'   // 已取消
  | 'missing'     // 缺失（适用于所有数据源类型）

/**
 * 数据源状态到媒体状态的映射表
 */
const DATA_SOURCE_TO_MEDIA_STATUS_MAP = {
  'pending': 'pending',
  'acquiring': 'asyncprocessing',
  'acquired': 'webavdecoding',
  'error': 'error',
  'cancelled': 'cancelled',
  'missing': 'missing'
} as const
```

## 设计优势

### 1. 统一接口
- 所有数据源都继承自同一个基类
- 提供一致的状态管理和操作方法
- 简化上层业务逻辑的处理

### 2. 状态管理完善
- 统一的状态转换机制
- 详细的进度和错误信息
- 支持取消和重试操作

### 3. 扩展性强
- 抽象方法定义清晰的扩展点
- 新增数据源类型只需实现必要的抽象方法
- 保持向后兼容性

### 4. 类型安全
- TypeScript 提供完整的类型检查
- 明确的状态类型定义
- 避免运行时类型错误
