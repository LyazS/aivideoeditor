# é‡æ„æ“ä½œè®°å½•ç³»ç»Ÿè®¾è®¡ - ä½¿ç”¨ç¤ºä¾‹

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›é‡æ„æ“ä½œè®°å½•ç³»ç»Ÿçš„å…·ä½“å®ç°ç¤ºä¾‹å’Œä½¿ç”¨æ–¹æ³•ï¼Œå±•ç¤ºå¦‚ä½•åŸºäºUnifiedCommandæ¥å£å®ç°å„ç§æ“ä½œå‘½ä»¤ï¼Œä»¥åŠå¦‚ä½•åœ¨å®é™…åº”ç”¨ä¸­ä½¿ç”¨è¿™äº›å‘½ä»¤ã€‚

## æ—¶é—´è½´é¡¹ç›®æ“ä½œå‘½ä»¤å®ç°

### 1. åˆ›å»ºæ—¶é—´è½´é¡¹ç›®å‘½ä»¤

```typescript
/**
 * åˆ›å»ºæ—¶é—´è½´é¡¹ç›®å‘½ä»¤
 */
export class CreateTimelineItemCommand extends UnifiedTimelineCommand {
  private createdItemId?: string
  
  constructor(
    private mediaItemId: string,
    private trackId: string,
    private timeRange: { timelineStartTime: number; timelineEndTime: number },
    private config: BasicTimelineConfig,
    timelineModule: UnifiedTimelineModule,
    spriteManager: SpriteLifecycleManager
  ) {
    super(
      'timeline.create',
      [], // IDå°†åœ¨æ‰§è¡Œæ—¶ç”Ÿæˆ
      `åˆ›å»ºæ—¶é—´è½´é¡¹ç›®: ${config.name}`,
      timelineModule,
      spriteManager
    )
  }
  
  async execute(): Promise<CommandResult> {
    try {
      // åˆ›å»ºç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®
      const timelineItem = await this.timelineModule.createTimelineItem({
        mediaItemId: this.mediaItemId,
        trackId: this.trackId,
        timeRange: this.timeRange,
        config: this.config
      })

      this.createdItemId = timelineItem.id
      this.targetInfo.ids = [timelineItem.id]

      // åˆ›å»ºsprite
      await this.spriteManager.createSprite(timelineItem)

      this.stateTransition.afterState = this.createStateSnapshot()

      return {
        success: true,
        affectedItems: [timelineItem.id],
        stateChanges: this.stateTransition.afterState
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'åˆ›å»ºæ—¶é—´è½´é¡¹ç›®å¤±è´¥'
      }
    }
  }
  
  async undo(): Promise<CommandResult> {
    try {
      if (this.createdItemId) {
        // åˆ é™¤spriteï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const timelineItem = this.timelineModule.getTimelineItem(this.createdItemId)
        if (timelineItem?.sprite) {
          await this.spriteManager.destroySprite(timelineItem)
        }
        
        // åˆ é™¤æ—¶é—´è½´é¡¹ç›®
        await this.timelineModule.removeTimelineItem(this.createdItemId)
      }
      
      return {
        success: true,
        affectedItems: this.targetInfo.ids
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ’¤é”€åˆ›å»ºæ—¶é—´è½´é¡¹ç›®å¤±è´¥'
      }
    }
  }
}
```

### 2. åˆ†å‰²æ—¶é—´è½´é¡¹ç›®å‘½ä»¤

```typescript
/**
 * åˆ†å‰²æ—¶é—´è½´é¡¹ç›®å‘½ä»¤
 */
export class SplitTimelineItemCommand extends UnifiedTimelineCommand {
  private firstItemId?: string
  private secondItemId?: string
  
  constructor(
    originalItemId: string,
    private splitTimeFrames: number,
    timelineModule: UnifiedTimelineModule,
    spriteManager: SpriteLifecycleManager
  ) {
    super(
      'timeline.split',
      [originalItemId],
      `åˆ†å‰²æ—¶é—´è½´é¡¹ç›® (åœ¨ ${splitTimeFrames} å¸§)`,
      timelineModule,
      spriteManager
    )
  }
  
  async execute(): Promise<CommandResult> {
    try {
      const originalItem = this.timelineModule.getTimelineItem(this.targetInfo.ids[0])
      if (!originalItem) {
        throw new Error('åŸå§‹æ—¶é—´è½´é¡¹ç›®ä¸å­˜åœ¨')
      }
      
      // æ‰§è¡Œåˆ†å‰²æ“ä½œ
      const { firstItem, secondItem } = await this.timelineModule.splitTimelineItem(
        originalItem,
        this.splitTimeFrames
      )
      
      this.firstItemId = firstItem.id
      this.secondItemId = secondItem.id
      
      // æ›´æ–°ç›®æ ‡IDåˆ—è¡¨
      this.targetInfo.ids = [this.firstItemId, this.secondItemId]
      
      this.stateTransition.afterState = this.createStateSnapshot()
      
      return {
        success: true,
        affectedItems: [this.firstItemId, this.secondItemId],
        stateChanges: this.stateTransition.afterState
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'åˆ†å‰²æ—¶é—´è½´é¡¹ç›®å¤±è´¥'
      }
    }
  }
  
  async undo(): Promise<CommandResult> {
    try {
      // åˆ é™¤åˆ†å‰²åçš„é¡¹ç›®
      if (this.firstItemId) {
        await this.timelineModule.removeTimelineItem(this.firstItemId)
      }
      if (this.secondItemId) {
        await this.timelineModule.removeTimelineItem(this.secondItemId)
      }
      
      // ä»çŠ¶æ€å¿«ç…§é‡å»ºåŸå§‹é¡¹ç›®
      const beforeSnapshot = this.stateTransition.beforeState.timelineItems?.[this.targetInfo.ids[0]]
      if (beforeSnapshot) {
        await this.timelineModule.restoreTimelineItemFromSnapshot(beforeSnapshot)
      }
      
      return {
        success: true,
        affectedItems: this.targetInfo.ids
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ’¤é”€åˆ†å‰²å¤±è´¥'
      }
    }
  }
}
```

## æ‰¹é‡æ“ä½œå®ç°

### 3. æ‰¹é‡å‘½ä»¤å®Œæ•´å®ç°

```typescript
/**
 * ç»Ÿä¸€æ‰¹é‡å‘½ä»¤å®Œæ•´å®ç°
 */
export class UnifiedBatchCommand implements UnifiedCommand {
  // ... åŸºç¡€å±æ€§ï¼ˆè§ç±»å‹è®¾è®¡æ–‡æ¡£ï¼‰
  
  async execute(): Promise<CommandResult> {
    const results: CommandResult[] = []
    this.executedCommands = []
    
    try {
      // ä¾æ¬¡æ‰§è¡Œæ‰€æœ‰å­å‘½ä»¤
      for (const command of this.subCommands) {
        const result = await command.execute()
        results.push(result)
        
        if (result.success) {
          this.executedCommands.push(command)
        } else {
          // å¦‚æœæŸä¸ªå‘½ä»¤å¤±è´¥ï¼Œå›æ»šå·²æ‰§è¡Œçš„å‘½ä»¤
          await this.rollbackExecutedCommands()
          throw new Error(`æ‰¹é‡æ“ä½œå¤±è´¥: ${result.error}`)
        }
      }
      
      // åˆ›å»ºåˆå¹¶çš„åç½®çŠ¶æ€å¿«ç…§
      this.stateTransition.afterState = this.createMergedAfterStateSnapshot()
      
      return {
        success: true,
        affectedItems: this.targetInfo.ids,
        stateChanges: this.stateTransition.afterState
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ‰¹é‡æ“ä½œå¤±è´¥'
      }
    }
  }
  
  async undo(): Promise<CommandResult> {
    try {
      // é€†åºæ’¤é”€æ‰€æœ‰å·²æ‰§è¡Œçš„å‘½ä»¤
      for (let i = this.executedCommands.length - 1; i >= 0; i--) {
        const result = await this.executedCommands[i].undo()
        if (!result.success) {
          throw new Error(`æ‰¹é‡æ’¤é”€å¤±è´¥: ${result.error}`)
        }
      }
      
      return {
        success: true,
        affectedItems: this.targetInfo.ids
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ‰¹é‡æ’¤é”€å¤±è´¥'
      }
    }
  }
  
  private async rollbackExecutedCommands(): Promise<void> {
    for (let i = this.executedCommands.length - 1; i >= 0; i--) {
      try {
        await this.executedCommands[i].undo()
      } catch (error) {
        console.error('å›æ»šå‘½ä»¤å¤±è´¥:', error)
      }
    }
    this.executedCommands = []
  }
  
  private createMergedAfterStateSnapshot(): StateSnapshot {
    const merged: StateSnapshot = {
      timelineItems: {},
      tracks: {},
      selection: undefined
    }

    for (const cmd of this.executedCommands) {
      const snapshot = cmd.stateTransition.afterState
      if (snapshot) {
        if (snapshot.timelineItems) {
          Object.assign(merged.timelineItems!, snapshot.timelineItems)
        }
        if (snapshot.tracks) {
          Object.assign(merged.tracks!, snapshot.tracks)
        }
        if (snapshot.selection) {
          merged.selection = snapshot.selection
        }
      }
    }

    return merged
  }
}
```

## å†å²ç®¡ç†å™¨å®ç°

### 4. é‡æ„å†å²ç®¡ç†å™¨å®Œæ•´å®ç°

```typescript
/**
 * é‡æ„åçš„ç»Ÿä¸€å†å²ç®¡ç†å™¨å®Œæ•´å®ç°
 */
export class UnifiedHistoryManager {
  private commands: UnifiedCommand[] = []
  private currentIndex = -1
  private maxHistorySize = 100

  constructor(
    private notificationManager: NotificationManager,
    private commandMerger: CommandMerger = new CommandMerger()
  ) {}

  /**
   * æ‰§è¡Œå‘½ä»¤å¹¶æ·»åŠ åˆ°å†å²è®°å½•
   */
  async executeCommand(command: UnifiedCommand): Promise<void> {
    try {
      const result = await command.execute()

      if (!result.success) {
        throw new Error(result.error || 'å‘½ä»¤æ‰§è¡Œå¤±è´¥')
      }

      // å°è¯•ä¸æœ€åä¸€ä¸ªå‘½ä»¤åˆå¹¶
      if (this.canMergeWithLast(command)) {
        const lastCommand = this.commands[this.currentIndex]
        const mergedCommand = CommandMerger.merge(lastCommand, command)
        this.commands[this.currentIndex] = mergedCommand

        console.log(`ğŸ”„ å‘½ä»¤å·²åˆå¹¶: ${mergedCommand.description}`)
      } else {
        // æ¸…é™¤å½“å‰ä½ç½®ä¹‹åçš„æ‰€æœ‰å‘½ä»¤
        if (this.currentIndex < this.commands.length - 1) {
          this.commands.splice(this.currentIndex + 1)
        }

        // æ·»åŠ æ–°å‘½ä»¤åˆ°å†å²è®°å½•
        this.commands.push(command)
        this.currentIndex++

        // é™åˆ¶å†å²è®°å½•å¤§å°
        this.limitHistorySize()

        console.log(`âœ… å‘½ä»¤å·²æ‰§è¡Œ: ${command.description}`)
      }

      // æ˜¾ç¤ºæˆåŠŸé€šçŸ¥
      this.notificationManager.showSuccess(
        'æ“ä½œå®Œæˆ',
        command.description
      )
    } catch (error) {
      console.error(`âŒ å‘½ä»¤æ‰§è¡Œå¤±è´¥: ${command.description}`, error)

      this.notificationManager.showError(
        'æ“ä½œå¤±è´¥',
        `${command.description}æ‰§è¡Œå¤±è´¥ã€‚${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      )

      throw error
    }
  }

  /**
   * æ’¤é”€ä¸Šä¸€ä¸ªå‘½ä»¤
   */
  async undo(): Promise<boolean> {
    if (!this.canUndo()) {
      this.notificationManager.showWarning('æ— æ³•æ’¤é”€', 'æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ')
      return false
    }

    try {
      const command = this.commands[this.currentIndex]
      const result = await command.undo()

      if (!result.success) {
        throw new Error(result.error || 'æ’¤é”€å¤±è´¥')
      }

      this.currentIndex--

      console.log(`â†©ï¸ å·²æ’¤é”€: ${command.description}`)
      this.notificationManager.showSuccess('æ’¤é”€æˆåŠŸ', `å·²æ’¤é”€: ${command.description}`)

      return true
    } catch (error) {
      console.error('âŒ æ’¤é”€æ“ä½œå¤±è´¥', error)

      this.notificationManager.showError(
        'æ’¤é”€å¤±è´¥',
        `æ’¤é”€æ“ä½œæ—¶å‘ç”Ÿé”™è¯¯ã€‚${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      )

      return false
    }
  }

  /**
   * é‡åšä¸‹ä¸€ä¸ªå‘½ä»¤
   */
  async redo(): Promise<boolean> {
    if (!this.canRedo()) {
      this.notificationManager.showWarning('æ— æ³•é‡åš', 'æ²¡æœ‰å¯é‡åšçš„æ“ä½œ')
      return false
    }

    try {
      this.currentIndex++
      const command = this.commands[this.currentIndex]
      const result = await command.execute()

      if (!result.success) {
        this.currentIndex-- // å›æ»šç´¢å¼•
        throw new Error(result.error || 'é‡åšå¤±è´¥')
      }

      console.log(`â†ªï¸ å·²é‡åš: ${command.description}`)
      this.notificationManager.showSuccess('é‡åšæˆåŠŸ', `å·²é‡åš: ${command.description}`)

      return true
    } catch (error) {
      console.error('âŒ é‡åšæ“ä½œå¤±è´¥', error)

      this.notificationManager.showError(
        'é‡åšå¤±è´¥',
        `é‡åšæ“ä½œæ—¶å‘ç”Ÿé”™è¯¯ã€‚${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      )

      return false
    }
  }

  private canMergeWithLast(command: UnifiedCommand): boolean {
    if (this.currentIndex < 0) return false

    const lastCommand = this.commands[this.currentIndex]
    return CommandMerger.canMerge(lastCommand, command)
  }

  private limitHistorySize(): void {
    if (this.commands.length > this.maxHistorySize) {
      const removeCount = this.commands.length - this.maxHistorySize
      this.commands.splice(0, removeCount)
      this.currentIndex -= removeCount
    }
  }
}
```

## å®é™…ä½¿ç”¨ç¤ºä¾‹

### 5. æ‰¹é‡åˆ é™¤æ—¶é—´è½´é¡¹ç›®

```typescript
// ç¤ºä¾‹ï¼šæ‰¹é‡åˆ é™¤æ—¶é—´è½´é¡¹ç›®
async function batchDeleteTimelineItems(
  itemIds: string[],
  historyManager: UnifiedHistoryManager,
  timelineModule: UnifiedTimelineModule,
  spriteManager: SpriteLifecycleManager
) {
  // åˆ›å»ºåˆ é™¤å‘½ä»¤åˆ—è¡¨
  const deleteCommands = itemIds.map(id =>
    new DeleteTimelineItemCommand(id, timelineModule, spriteManager)
  )

  // åˆ›å»ºæ‰¹é‡å‘½ä»¤
  const batchCommand = new UnifiedBatchCommand(
    `æ‰¹é‡åˆ é™¤ ${itemIds.length} ä¸ªæ—¶é—´è½´é¡¹ç›®`,
    deleteCommands
  )

  // æ‰§è¡Œæ‰¹é‡åˆ é™¤
  await historyManager.executeCommand(batchCommand)
}

// åˆ é™¤æ—¶é—´è½´é¡¹ç›®å‘½ä»¤å®ç°
class DeleteTimelineItemCommand extends UnifiedTimelineCommand {
  constructor(
    itemId: string,
    timelineModule: UnifiedTimelineModule,
    spriteManager: SpriteLifecycleManager
  ) {
    super(
      'timeline.delete',
      [itemId],
      `åˆ é™¤æ—¶é—´è½´é¡¹ç›®: ${itemId}`,
      timelineModule,
      spriteManager
    )
  }

  async execute(): Promise<CommandResult> {
    try {
      const item = this.timelineModule.getTimelineItem(this.targetInfo.ids[0])
      if (!item) {
        throw new Error('æ—¶é—´è½´é¡¹ç›®ä¸å­˜åœ¨')
      }

      // åˆ é™¤sprite
      if (item.sprite) {
        await this.spriteManager.destroySprite(item)
      }

      // åˆ é™¤æ—¶é—´è½´é¡¹ç›®
      await this.timelineModule.removeTimelineItem(item.id)

      this.stateTransition.afterState = this.createStateSnapshot()

      return {
        success: true,
        affectedItems: [item.id]
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'åˆ é™¤æ—¶é—´è½´é¡¹ç›®å¤±è´¥'
      }
    }
  }

  async undo(): Promise<CommandResult> {
    try {
      // ä»çŠ¶æ€å¿«ç…§æ¢å¤æ—¶é—´è½´é¡¹ç›®
      const beforeSnapshot = this.stateTransition.beforeState.timelineItems?.[this.targetInfo.ids[0]]
      if (beforeSnapshot) {
        const restoredItem = await this.timelineModule.restoreTimelineItemFromSnapshot(beforeSnapshot)

        // å¦‚æœåŸæ¥æœ‰spriteï¼Œé‡æ–°åˆ›å»º
        if (beforeSnapshot.hasSprite) {
          await this.spriteManager.createSprite(restoredItem)
        }
      }

      return {
        success: true,
        affectedItems: this.targetInfo.ids
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ’¤é”€åˆ é™¤å¤±è´¥'
      }
    }
  }
}
```

### 6. æ™ºèƒ½å±æ€§æ›´æ–°ï¼ˆæ”¯æŒå‘½ä»¤åˆå¹¶ï¼‰

```typescript
// ç¤ºä¾‹ï¼šæ™ºèƒ½å±æ€§æ›´æ–°ï¼ˆæ”¯æŒå‘½ä»¤åˆå¹¶ï¼‰
async function updateTimelineItemProperty(
  itemId: string,
  property: string,
  value: any,
  historyManager: UnifiedHistoryManager,
  timelineModule: UnifiedTimelineModule
) {
  const updateCommand = new UpdateTimelineItemPropertyCommand(
    itemId,
    property,
    value,
    timelineModule
  )

  // æ‰§è¡Œæ›´æ–°ï¼ˆå¦‚æœæ˜¯è¿ç»­çš„ç›¸åŒå±æ€§æ›´æ–°ï¼Œä¼šè‡ªåŠ¨åˆå¹¶ï¼‰
  await historyManager.executeCommand(updateCommand)
}

// å±æ€§æ›´æ–°å‘½ä»¤å®ç°ï¼ˆæ”¯æŒåˆå¹¶ï¼‰
class UpdateTimelineItemPropertyCommand extends UnifiedTimelineCommand {
  constructor(
    itemId: string,
    private property: string,
    private newValue: any,
    timelineModule: UnifiedTimelineModule
  ) {
    super(
      'property.update',
      [itemId],
      `æ›´æ–°å±æ€§ ${property}: ${newValue}`,
      timelineModule,
      undefined!,
      undefined!
    )
  }

  async execute(): Promise<CommandResult> {
    try {
      const item = this.timelineModule.getTimelineItem(this.targetInfo.ids[0])
      if (!item) {
        throw new Error('æ—¶é—´è½´é¡¹ç›®ä¸å­˜åœ¨')
      }

      // æ›´æ–°å±æ€§
      (item.config.mediaConfig as any)[this.property] = this.newValue

      // æ›´æ–°spriteï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      if (item.sprite) {
        await this.spriteManager.updateSprite(item)
      }

      this.stateTransition.afterState = this.createStateSnapshot()

      return {
        success: true,
        affectedItems: [item.id]
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ›´æ–°å±æ€§å¤±è´¥'
      }
    }
  }

  async undo(): Promise<CommandResult> {
    try {
      // ä»çŠ¶æ€å¿«ç…§æ¢å¤å±æ€§å€¼
      const beforeSnapshot = this.stateTransition.beforeState.timelineItems?.[this.targetInfo.ids[0]]
      if (beforeSnapshot) {
        const item = this.timelineModule.getTimelineItem(this.targetInfo.ids[0])
        if (item) {
          (item.config.mediaConfig as any)[this.property] = (beforeSnapshot.config.mediaConfig as any)[this.property]

          // æ›´æ–°sprite
          if (item.sprite) {
            await this.spriteManager.updateSprite(item)
          }
        }
      }

      return {
        success: true,
        affectedItems: this.targetInfo.ids
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ’¤é”€å±æ€§æ›´æ–°å¤±è´¥'
      }
    }
  }

  // æ”¯æŒå‘½ä»¤åˆå¹¶
  canMergeWith(other: UnifiedCommand): boolean {
    if (!(other instanceof UpdateTimelineItemPropertyCommand)) return false
    if (this.targetInfo.ids[0] !== other.targetInfo.ids[0]) return false
    if (this.property !== other.property) return false

    // æ—¶é—´çª—å£æ£€æŸ¥ï¼ˆ1ç§’å†…çš„ç›¸åŒå±æ€§æ›´æ–°å¯ä»¥åˆå¹¶ï¼‰
    const timeDiff = Math.abs(other.timestamp - this.timestamp)
    return timeDiff <= 1000
  }

  mergeWith(other: UnifiedCommand): UnifiedCommand {
    if (!(other instanceof UpdateTimelineItemPropertyCommand)) {
      throw new Error('æ— æ³•åˆå¹¶ä¸åŒç±»å‹çš„å‘½ä»¤')
    }

    // åˆ›å»ºåˆå¹¶åçš„å‘½ä»¤ï¼Œä¿ç•™ç¬¬ä¸€ä¸ªå‘½ä»¤çš„beforeStateå’Œæœ€åä¸€ä¸ªå‘½ä»¤çš„newValue
    const mergedCommand = new UpdateTimelineItemPropertyCommand(
      this.targetInfo.ids[0],
      this.property,
      other.newValue,
      this.timelineModule
    )

    // ä¿ç•™åŸå§‹çš„beforeState
    mergedCommand.stateTransition.beforeState = this.stateTransition.beforeState
    mergedCommand.description = `æ›´æ–°å±æ€§ ${this.property}: ${this.newValue} â†’ ${other.newValue}`

    return mergedCommand
  }
}
```

## å®ç°è·¯å¾„

1. **å®ç°åŸºç¡€å‘½ä»¤ç±»**ï¼šUnifiedTimelineCommand
2. **å®ç°å…·ä½“æ“ä½œå‘½ä»¤**ï¼šåˆ›å»ºã€åˆ é™¤ã€æ›´æ–°ç­‰å„ç§æ—¶é—´è½´æ“ä½œ
3. **å®ç°æ‰¹é‡æ“ä½œ**ï¼šUnifiedBatchCommandå’Œç›¸å…³é€»è¾‘
4. **å®ç°å†å²ç®¡ç†å™¨**ï¼šUnifiedHistoryManagerå’Œå‘½ä»¤åˆå¹¶
5. **é›†æˆåˆ°åº”ç”¨**ï¼šåœ¨UIç»„ä»¶ä¸­ä½¿ç”¨æ–°çš„å‘½ä»¤ç³»ç»Ÿ
6. **æµ‹è¯•å’Œä¼˜åŒ–**ï¼šç¡®ä¿åŠŸèƒ½æ­£ç¡®æ€§å’Œæ€§èƒ½

---

*æ–‡æ¡£åˆ›å»ºæ—¶é—´ï¼š2025-01-19*
*åŸºäºé‡æ„æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*
*å…³è”æ–‡æ¡£ï¼š13-é‡æ„æ“ä½œè®°å½•ç³»ç»Ÿè®¾è®¡-ç±»å‹è®¾è®¡.md*
