# 数据源扩展管理器类型设计

## 概述

基于DataSourceManager基础抽象类，实现具体的管理器类型，包括用户选择文件管理器、工程文件管理器和远程文件管理器。

## 具体管理器实现

### 1. 用户选择文件管理器

```typescript
/**
 * 用户选择文件管理器 - 处理用户选择的文件验证
 */
class UserSelectedFileManager extends DataSourceManager<UserSelectedFileSource> {
  private static instance: UserSelectedFileManager

  static getInstance(): UserSelectedFileManager {
    if (!this.instance) {
      this.instance = new UserSelectedFileManager()
    }
    return this.instance
  }

  private constructor() {
    super()
    this.maxConcurrentTasks = 10 // 文件验证可以并发较多
  }

  getManagerType(): string {
    return 'user-selected'
  }

  protected async executeTask(task: AcquisitionTask<UserSelectedFileSource>): Promise<void> {
    const source = task.source
    const file = source.getSelectedFile()

    try {
      // 验证文件有效性
      await this.validateFile(file, task.abortController?.signal)
      
      // 创建对象URL
      const url = URL.createObjectURL(file)
      
      // 设置为已获取状态
      source.setAcquired(file, url)
      
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('任务已取消')
      }
      throw error
    }
  }

  /**
   * 验证文件有效性
   */
  private async validateFile(file: File, signal?: AbortSignal): Promise<void> {
    // 检查文件大小
    if (file.size === 0) {
      throw new Error('文件为空')
    }

    if (file.size > 10 * 1024 * 1024 * 1024) { // 10GB限制
      throw new Error('文件过大，超过10GB限制')
    }

    // 检查文件类型
    const supportedTypes = [
      'video/', 'audio/', 'image/',
      'application/octet-stream' // 允许未知类型
    ]

    const isSupported = supportedTypes.some(type => 
      file.type.startsWith(type) || file.type === type
    )

    if (!isSupported && file.type !== '') {
      throw new Error(`不支持的文件类型: ${file.type}`)
    }

    // 检查文件扩展名
    const fileName = file.name.toLowerCase()
    const supportedExtensions = [
      '.mp4', '.avi', '.mov', '.mkv', '.webm', '.flv',
      '.mp3', '.wav', '.flac', '.aac', '.ogg',
      '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'
    ]

    const hasValidExtension = supportedExtensions.some(ext => 
      fileName.endsWith(ext)
    )

    if (!hasValidExtension) {
      const ext = fileName.split('.').pop() || '无扩展名'
      throw new Error(`不支持的文件扩展名: .${ext}`)
    }

    // 检查是否被取消
    if (signal?.aborted) {
      throw new Error('验证已取消')
    }

    // 简单的文件头检查（可选）
    await this.validateFileHeader(file, signal)
  }

  /**
   * 验证文件头
   */
  private async validateFileHeader(file: File, signal?: AbortSignal): Promise<void> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      
      reader.onload = () => {
        if (signal?.aborted) {
          reject(new Error('验证已取消'))
          return
        }
        
        const buffer = reader.result as ArrayBuffer
        const bytes = new Uint8Array(buffer)
        
        // 检查常见的文件头
        if (this.isValidFileHeader(bytes)) {
          resolve()
        } else {
          reject(new Error('文件格式可能已损坏'))
        }
      }
      
      reader.onerror = () => {
        reject(new Error('无法读取文件'))
      }
      
      // 只读取前16字节用于文件头检查
      const blob = file.slice(0, 16)
      reader.readAsArrayBuffer(blob)
    })
  }

  /**
   * 检查文件头是否有效
   */
  private isValidFileHeader(bytes: Uint8Array): boolean {
    // MP4文件头
    if (bytes.length >= 8) {
      const mp4Signatures = [
        [0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70], // ftyp
        [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70]  // ftyp
      ]
      
      for (const sig of mp4Signatures) {
        if (this.matchesSignature(bytes, sig, 4)) {
          return true
        }
      }
    }

    // JPEG文件头
    if (bytes.length >= 2 && bytes[0] === 0xFF && bytes[1] === 0xD8) {
      return true
    }

    // PNG文件头
    if (bytes.length >= 8) {
      const pngSig = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
      if (this.matchesSignature(bytes, pngSig, 0)) {
        return true
      }
    }

    // 其他格式或无法识别的格式也允许通过
    return true
  }

  private matchesSignature(bytes: Uint8Array, signature: number[], offset: number): boolean {
    if (bytes.length < offset + signature.length) {
      return false
    }
    
    for (let i = 0; i < signature.length; i++) {
      if (bytes[offset + i] !== signature[i]) {
        return false
      }
    }
    
    return true
  }

  protected getMaxRetries(source: UserSelectedFileSource): number {
    return 1 // 文件验证通常不需要重试
  }
}
```

### 2. 工程文件管理器

```typescript
/**
 * 工程文件管理器 - 处理工程文件路径的文件定位
 */
class ProjectFileManager extends DataSourceManager<ProjectFileSource> {
  private static instance: ProjectFileManager

  static getInstance(): ProjectFileManager {
    if (!this.instance) {
      this.instance = new ProjectFileManager()
    }
    return this.instance
  }

  private constructor() {
    super()
    this.maxConcurrentTasks = 5
  }

  getManagerType(): string {
    return 'project-file'
  }

  protected async executeTask(task: AcquisitionTask<ProjectFileSource>): Promise<void> {
    const source = task.source
    const fileInfo = source.getFileInfo()

    try {
      // 尝试通过文件路径定位文件
      const file = await this.locateFile(fileInfo, task.abortController?.signal)
      
      if (file) {
        const url = URL.createObjectURL(file)
        source.setAcquired(file, url)
      } else {
        // 文件不存在，标记为missing
        source.setMissing(`文件不存在: ${fileInfo.filePath}`)
      }
      
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('任务已取消')
      }
      
      // 文件访问错误也标记为missing
      source.setMissing(`无法访问文件: ${error instanceof Error ? error.message : String(error)}`)
    }
  }

  /**
   * 定位文件
   */
  private async locateFile(
    fileInfo: {
      filePath: string
      fileName: string
      fileSize?: number
      lastModified?: number
    },
    signal?: AbortSignal
  ): Promise<File | null> {
    
    // 在浏览器环境中，无法直接访问文件系统路径
    // 这里模拟文件定位逻辑，实际实现可能需要：
    // 1. 通过File System Access API（如果支持）
    // 2. 提示用户重新选择文件
    // 3. 从缓存中查找
    
    if (signal?.aborted) {
      throw new Error('定位已取消')
    }

    // 检查是否在缓存中
    const cachedFile = await this.getCachedFile(fileInfo)
    if (cachedFile) {
      return cachedFile
    }

    // 尝试通过File System Access API（如果支持）
    if ('showOpenFilePicker' in window) {
      try {
        return await this.locateFileWithSystemAccess(fileInfo, signal)
      } catch (error) {
        console.warn('File System Access API failed:', error)
      }
    }

    // 无法自动定位，返回null（将标记为missing）
    return null
  }

  /**
   * 从缓存获取文件
   */
  private async getCachedFile(fileInfo: any): Promise<File | null> {
    // 实现文件缓存逻辑
    // 可以使用IndexedDB存储文件引用
    return null
  }

  /**
   * 使用File System Access API定位文件
   */
  private async locateFileWithSystemAccess(
    fileInfo: any, 
    signal?: AbortSignal
  ): Promise<File | null> {
    try {
      // 这是一个示例实现，实际使用时需要用户授权
      const [fileHandle] = await (window as any).showOpenFilePicker({
        types: [{
          description: 'Media files',
          accept: {
            'video/*': ['.mp4', '.avi', '.mov'],
            'audio/*': ['.mp3', '.wav', '.flac'],
            'image/*': ['.jpg', '.png', '.gif']
          }
        }]
      })

      if (signal?.aborted) {
        throw new Error('定位已取消')
      }

      const file = await fileHandle.getFile()
      
      // 验证文件是否匹配
      if (this.validateFileMatch(file, fileInfo)) {
        return file
      }
      
      return null
    } catch (error) {
      console.error('File System Access API error:', error)
      return null
    }
  }

  /**
   * 验证文件是否匹配
   */
  private validateFileMatch(file: File, fileInfo: any): boolean {
    // 检查文件名
    if (file.name !== fileInfo.fileName) {
      return false
    }

    // 检查文件大小（允许一定误差）
    if (fileInfo.fileSize && Math.abs(file.size - fileInfo.fileSize) > 1024) {
      return false
    }

    // 检查修改时间（允许一定误差）
    if (fileInfo.lastModified && Math.abs(file.lastModified - fileInfo.lastModified) > 1000) {
      return false
    }

    return true
  }

  protected getMaxRetries(source: ProjectFileSource): number {
    return 0 // 工程文件定位不需要重试
  }
}
```

### 3. 远程文件管理器

```typescript
/**
 * 远程文件管理器 - 处理网络文件下载
 */
class RemoteFileManager extends DataSourceManager<RemoteFileSource> {
  private static instance: RemoteFileManager

  static getInstance(): RemoteFileManager {
    if (!this.instance) {
      this.instance = new RemoteFileManager()
    }
    return this.instance
  }

  private constructor() {
    super()
    this.maxConcurrentTasks = 3 // 限制并发下载数
  }

  getManagerType(): string {
    return 'remote'
  }

  protected async executeTask(task: AcquisitionTask<RemoteFileSource>): Promise<void> {
    const source = task.source
    const url = source.getRemoteUrl()
    const config = source.getConfig()

    try {
      source.setDownloadStarted()
      
      const file = await this.downloadFile(
        url, 
        config, 
        task.abortController?.signal,
        (progress, stats) => {
          source.updateDownloadProgress(progress, stats)
        }
      )
      
      const objectUrl = URL.createObjectURL(file)
      source.setAcquired(file, objectUrl)
      
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('下载已取消')
      }
      throw error
    }
  }

  /**
   * 下载文件
   */
  private async downloadFile(
    url: string,
    config: RemoteFileConfig,
    signal?: AbortSignal,
    onProgress?: (progress: number, stats?: any) => void
  ): Promise<File> {
    
    const timeout = config.timeout || 30000
    const headers = config.headers || {}

    const response = await fetch(url, {
      headers,
      signal,
      // 其他fetch选项
    })

    if (!response.ok) {
      throw new Error(`下载失败: ${response.status} ${response.statusText}`)
    }

    const contentLength = response.headers.get('content-length')
    const totalBytes = contentLength ? parseInt(contentLength, 10) : 0

    if (!response.body) {
      throw new Error('响应体为空')
    }

    const reader = response.body.getReader()
    const chunks: Uint8Array[] = []
    let downloadedBytes = 0
    let startTime = Date.now()

    try {
      while (true) {
        if (signal?.aborted) {
          throw new Error('下载已取消')
        }

        const { done, value } = await reader.read()
        
        if (done) break

        chunks.push(value)
        downloadedBytes += value.length

        // 计算进度和速度
        const progress = totalBytes > 0 ? (downloadedBytes / totalBytes) * 100 : 0
        const elapsed = Date.now() - startTime
        const speed = elapsed > 0 ? this.formatSpeed(downloadedBytes / (elapsed / 1000)) : undefined

        onProgress?.(progress, {
          downloadedBytes,
          totalBytes,
          downloadSpeed: speed
        })
      }
    } finally {
      reader.releaseLock()
    }

    // 合并所有chunks
    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0)
    const result = new Uint8Array(totalLength)
    let offset = 0

    for (const chunk of chunks) {
      result.set(chunk, offset)
      offset += chunk.length
    }

    // 创建File对象
    const fileName = this.extractFileName(url) || 'download'
    const mimeType = response.headers.get('content-type') || 'application/octet-stream'
    
    return new File([result], fileName, { type: mimeType })
  }

  /**
   * 提取文件名
   */
  private extractFileName(url: string): string {
    try {
      const urlObj = new URL(url)
      const pathname = urlObj.pathname
      const fileName = pathname.split('/').pop() || 'download'
      
      // 移除查询参数
      return fileName.split('?')[0]
    } catch {
      return 'download'
    }
  }

  /**
   * 格式化下载速度
   */
  private formatSpeed(bytesPerSecond: number): string {
    if (bytesPerSecond < 1024) {
      return `${bytesPerSecond.toFixed(0)} B/s`
    } else if (bytesPerSecond < 1024 * 1024) {
      return `${(bytesPerSecond / 1024).toFixed(1)} KB/s`
    } else {
      return `${(bytesPerSecond / (1024 * 1024)).toFixed(1)} MB/s`
    }
  }

  protected getMaxRetries(source: RemoteFileSource): number {
    return source.getConfig().retryCount || 3
  }

  protected getRetryDelay(retryCount: number): number {
    // 使用配置的重试延迟或默认值
    return 2000 * Math.pow(2, retryCount) // 2s, 4s, 8s...
  }
}
```

## 管理器注册

```typescript
// 注册所有管理器
const registry = DataSourceManagerRegistry.getInstance()

registry.register('user-selected', UserSelectedFileManager.getInstance())
registry.register('project-file', ProjectFileManager.getInstance())
registry.register('remote', RemoteFileManager.getInstance())
```

## 设计特点

### 1. 场景特化
- **用户选择文件管理器**：专注文件验证和格式检查
- **工程文件管理器**：处理文件缺失和重新定位
- **远程文件管理器**：支持下载进度和并发控制

### 2. 错误处理
- 每种管理器都有特定的错误处理逻辑
- 支持不同的重试策略
- 详细的错误信息记录

### 3. 性能优化
- 合理的并发控制设置
- 内存使用优化
- 支持任务取消和资源释放

### 4. 扩展性
- 易于添加新的管理器类型
- 支持插件化注册
- 配置灵活可调
