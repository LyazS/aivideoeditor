# 媒体类型统一设计 - 类型设计

## 概述

当前项目中存在 `LocalMediaItem` 和 `AsyncProcessingMediaItem` 两套并行的媒体类型系统，导致架构复杂、代码重复、维护困难。本方案提出**统一异步源**的设计思路，将"本地"和"异步"从**类型区分**改为**状态区分**，所有媒体项目都统一采用异步处理模式。

### 核心理念：统一异步源 (Unified Async Source)

**所有媒体项目都是异步源**，无论是用户选择的本地文件、工程加载的文件路径，还是远程下载的文件，都通过统一的异步状态机进行处理：

- **本地文件**：瞬间完成获取阶段，但仍走完整的异步流程
- **远程文件**：正常的异步下载和处理流程  
- **工程文件**：检查存在性后走异步流程
- **云盘文件**：同步后走异步流程

j这种设计彻底消除了类型层面的复杂性，提供了真正统一的架构。

## 当前问题分析

### 1. 概念模型混乱
```typescript
// ❌ 当前设计：两种类型
LocalMediaItem vs AsyncProcessingMediaItem

// 问题：本质上都是"媒体项目"，不应该在类型层面区分
```

### 2. 架构复杂度过高
- 两套并行的类型系统
- 两套状态管理API
- 两套UI渲染逻辑
- 复杂的类型守卫和转换逻辑

## 统一设计方案

### 1. 核心思路：统一异步源架构

**重新理解"状态"vs"类型"**：
- "本地"和"异步"是**状态**，不是**类型**
- **所有媒体都是异步源**：统一为一种媒体类型，所有文件都走异步处理流程
- **差异体现在处理速度**：本地文件瞬间完成获取，远程文件需要下载时间
- **统一的状态转换**：所有媒体都经过相同的状态转换路径
- 属性分层：核心属性 + 状态相关属性 + 可选属性

**统一异步源的优势**：
- ✅ **架构完全统一**：消除所有类型层面的分支逻辑
- ✅ **代码高度复用**：一套代码处理所有媒体类型
- ✅ **扩展性极强**：新增数据源类型无需修改核心逻辑
- ✅ **UI逻辑统一**：所有媒体使用相同的状态显示组件
- ✅ **测试简化**：单一流程易于测试和维护

### 2. 双重状态设计思路

**核心洞察**：数据源状态和媒体处理状态是两个不同层面的概念
- **数据源状态**：负责"获取文件"（下载、同步、传输等）
- **媒体状态**：负责"处理文件"（解析、就绪、错误等）

**设计优势**：
- 职责分离清晰：数据源管理获取逻辑，媒体项目管理处理逻辑
- 扩展性强：未来可支持云盘、FTP、数据库等多种数据源
- UI逻辑简化：UI只需关心抽象的媒体状态

## 状态定义

### 1. 媒体处理状态（抽象层）

```typescript
type MediaStatus =
  | 'pending'         // 等待开始处理
  | 'asyncprocessing' // 异步获取中（抽象状态，对应各种数据源的获取阶段）
  | 'webavdecoding'   // WebAV解析中
  | 'ready'           // 就绪
  | 'error'           // 错误
  | 'cancelled'       // 取消
  | 'missing'         // 缺失（加载工程时本地文件不存在）
```

### 2. 数据源状态映射

数据源的内部状态会映射到媒体处理状态：

```typescript
// 数据源状态 → 媒体状态映射
DataSource.internalStatus → UnifiedMediaItem.mediaStatus
├── 'pending'     → 'pending'
├── 'acquiring'   → 'asyncprocessing' ✅ 关键映射
├── 'acquired'    → 'webavdecoding' (开始解析文件)
├── 'error'       → 'error'
└── 'cancelled'   → 'cancelled'

// 🔄 统一异步源：所有文件都走异步流程
// 本地文件：瞬间完成获取阶段
UserSelectedFileSource → 'acquiring'(瞬间完成) → 'acquired' → 'webavdecoding'
// 远程文件：正常异步获取
RemoteFileSource → 'acquiring'(下载过程) → 'acquired' → 'webavdecoding'
// 工程文件：检查后异步处理
ProjectFileSource → 'acquiring'(检查存在性) → 'acquired' → 'webavdecoding'
```

> **注意**：具体的数据源类型定义请参考 [数据源类型设计文档](./数据源类型设计.md)

## 统一媒体项目接口

```typescript
// 导入数据源类型定义
import type { DataSource } from './数据源扩展类型设计'

/**
 * 统一的媒体项目接口 - 采用状态机模式
 */
export interface UnifiedMediaItem {
  // ==================== 核心属性 ====================
  id: string
  mediaType: MediaType | 'unknown'
  mediaStatus: MediaStatus // 独立状态字段，不是计算属性

  // ==================== 数据源（包含获取状态） ====================
  source: DataSource // 使用统一的数据源联合类型

  // ==================== WebAV对象（状态相关） ====================
  webav?: {
    mp4Clip?: Raw<MP4Clip>
    imgClip?: Raw<ImgClip>
    audioClip?: Raw<AudioClip>
    thumbnailUrl?: string
  }

  // ==================== 元数据（状态相关） ====================
  duration?: number // ready状态才有确切值

  // ==================== 状态机方法 ====================
  /**
   * 状态转换方法 - 由数据源管理器调用
   * @param newStatus 目标状态
   * @param context 转换上下文（可选）- 用于传递状态转换的附加信息
   */
  transitionTo(newStatus: MediaStatus, context?: TransitionContext): void

  /**
   * 检查是否可以转换到指定状态
   * @param newStatus 目标状态
   */
  canTransitionTo(newStatus: MediaStatus): boolean

  /**
   * 状态转换钩子 - 用于副作用处理
   * @param oldStatus 原状态
   * @param newStatus 新状态
   * @param context 转换上下文 - 包含状态转换的详细信息
   */
  onStatusChanged?(oldStatus: MediaStatus, newStatus: MediaStatus, context?: TransitionContext): void
}
```

## 转换上下文设计

转换上下文（TransitionContext）是状态转换时传递附加信息的机制，让状态机能够在保持简洁的同时支持复杂的业务场景。

### 1. 基础上下文结构

```typescript
// 基础上下文 - 所有转换都包含的通用信息
interface BaseTransitionContext {
  timestamp: number         // 转换时间戳
  source: string           // 触发转换的来源
  reason: string           // 转换原因
  metadata?: Record<string, any> // 其他元数据
}
```

### 2. 具体上下文类型

```typescript
// 开始异步处理的上下文
interface AsyncProcessingContext extends BaseTransitionContext {
  type: 'async_processing'
  initialProgress?: number  // 初始进度
  estimatedDuration?: number // 预估总耗时
}

// 进度更新上下文（同状态转换，用于进度通知）
interface ProgressUpdateContext extends BaseTransitionContext {
  type: 'progress_update'
  progress: number          // 当前进度 (0-100)
  progressMessage: string   // 进度描述
  estimatedTime?: number    // 预估剩余时间(ms)
  downloadSpeed?: string    // 下载速度
  downloadedBytes?: number  // 已下载字节数
  totalBytes?: number       // 总字节数
}

// 下载完成转换上下文
interface DownloadCompletedContext extends BaseTransitionContext {
  type: 'download_completed'
  downloadedFile: File      // 已下载的文件对象
  downloadedUrl: string     // 本地blob URL
  fileSize: number          // 文件大小
  downloadDuration: number  // 下载耗时(ms)
  averageSpeed?: string     // 平均下载速度
}

// WebAV解析完成上下文
interface ParseCompletedContext extends BaseTransitionContext {
  type: 'parse_completed'
  parsedMetadata: {         // 解析得到的元数据
    duration: number
    resolution?: string
    format: string
    bitrate?: number
    codecInfo?: {
      video?: string
      audio?: string
    }
  }
  thumbnailGenerated: boolean // 是否生成了缩略图
  webavObjects: any          // WebAV解析结果
  parseTime: number          // 解析耗时(ms)
}

// 错误转换上下文
interface ErrorContext extends BaseTransitionContext {
  type: 'error'
  errorMessage: string      // 错误描述
  errorCode: string         // 错误代码
  errorDetails?: any        // 详细错误信息
  retryable: boolean        // 是否可重试
  retryCount?: number       // 重试次数
  lastAttemptTime?: number  // 上次尝试时间
}

// 取消转换上下文
interface CancelledContext extends BaseTransitionContext {
  type: 'cancelled'
  cancelReason: string      // 取消原因
  partialProgress?: number  // 取消时的进度
  canResume?: boolean       // 是否可恢复
}

// 重试转换上下文
interface RetryContext extends BaseTransitionContext {
  type: 'retry'
  retryCount: number        // 重试次数
  previousError?: string    // 上次错误信息
  retryDelay?: number       // 重试延迟(ms)
}

// 文件缺失上下文
interface MissingContext extends BaseTransitionContext {
  type: 'missing'
  originalPath?: string     // 原始文件路径
  lastModified?: number     // 文件最后修改时间
  expectedSize?: number     // 预期文件大小
}

// 联合类型定义
type TransitionContext =
  | AsyncProcessingContext
  | ProgressUpdateContext
  | DownloadCompletedContext
  | ParseCompletedContext
  | ErrorContext
  | CancelledContext
  | RetryContext
  | MissingContext
```

### 3. 联合类型设计优势

1. **类型安全**
   - 每种转换场景都有明确的上下文结构
   - TypeScript 可以提供精确的类型检查和代码提示
   - 避免传递不相关的上下文信息

2. **语义清晰**
   - 通过 `type` 字段明确标识上下文类型
   - 不同场景的上下文字段有明确的业务含义
   - 便于理解和维护

3. **扩展性强**
   - 新增转换场景时只需添加新的上下文类型
   - 不影响现有的上下文结构
   - 支持渐进式功能增强

4. **可调试性好**
   - 每个上下文都包含完整的转换信息
   - 便于日志记录和问题排查
   - 支持详细的状态转换追踪

## 状态转换规则

```typescript
/**
 * 合法的状态转换映射表
 */
const VALID_TRANSITIONS: Record<MediaStatus, MediaStatus[]> = {
  'pending': ['asyncprocessing', 'webavdecoding', 'error', 'missing'],
  'asyncprocessing': ['webavdecoding', 'error', 'cancelled'],
  'webavdecoding': ['ready', 'error'],
  'ready': ['error'], // 运行时可能出错
  'error': ['pending'], // 支持重试
  'cancelled': ['pending'], // 支持重新开始
  'missing': ['pending', 'error'] // 重新选择文件或确认错误
}

/**
 * 状态转换实现示例
 */
class UnifiedMediaItemImpl implements UnifiedMediaItem {
  // ... 其他属性

  transitionTo(newStatus: MediaStatus, context?: TransitionContext): void {
    if (!this.canTransitionTo(newStatus)) {
      throw new Error(`Invalid transition from ${this.mediaStatus} to ${newStatus}`)
    }

    const oldStatus = this.mediaStatus
    this.mediaStatus = newStatus

    // 触发状态变化钩子，传递完整的转换上下文
    this.onStatusChanged?.(oldStatus, newStatus, context)
  }

  canTransitionTo(newStatus: MediaStatus): boolean {
    return VALID_TRANSITIONS[this.mediaStatus]?.includes(newStatus) ?? false
  }
}
```

## 各状态字段约束

### 1. pending状态
```typescript
{
  id: string ✅
  mediaType: 'unknown' ✅ // 还未检测
  source: DataSource ✅ // 任何数据源类型
  source.getStatus(): 'pending' ✅
  webav: undefined ❌
  duration: undefined ❌
}
```

### 2. asyncprocessing状态（统一异步源 - 所有数据源都经过此状态）
```typescript
{
  id: string ✅
  mediaType: 'unknown' ✅ // 仍未检测到实际类型
  source: DataSource ✅ // 数据源正在获取中
  source.getStatus(): 'acquiring' ✅
  source.getProgress(): 0-99 ✅
  webav: undefined ❌
  duration: undefined ❌
}
```

### 3. webavdecoding状态
```typescript
{
  id: string ✅
  mediaType: 'unknown' ✅ // 正在检测中
  source: DataSource ✅ // 数据源已获取完成
  source.getStatus(): 'acquired' ✅
  webav: undefined ❌ // 或部分创建
  duration: undefined ❌
}
```

### 4. ready状态
```typescript
{
  id: string ✅
  mediaType: MediaType ✅ // 已检测到确切类型
  source: DataSource ✅ // 数据源已获取完成
  source.getStatus(): 'acquired' ✅
  webav: {
    mp4Clip?: Raw<MP4Clip> ✅ // 根据类型
    imgClip?: Raw<ImgClip> ✅
    audioClip?: Raw<AudioClip> ✅
    thumbnailUrl?: string ✅
  }
  duration: number ✅ // 确切值
}
```

### 5. error/cancelled状态
```typescript
{
  id: string ✅
  mediaType: 'unknown' | MediaType ✅ // 可能已检测或未检测
  source: DataSource ✅
  source.getStatus(): 'error' | 'cancelled' ✅
  source.getError(): string ✅ // 错误信息
  webav: undefined ❌
  duration: undefined | number // 可能有预估值
}
```

### 6. missing状态（项目加载时）
```typescript
{
  id: string ✅
  mediaType: MediaType ✅ // 从项目配置中已知
  source: DataSource ✅ // 数据源可能无效
  webav: undefined ❌
  duration: number ✅ // 从项目配置恢复
}
```

## 设计优势总结

### 1. 统一异步源架构
- **完全统一**：所有媒体项目都是异步源，消除类型分支
- **数据源层**：专注文件获取（下载、同步、传输、验证）
- **媒体层**：专注文件处理（解析、就绪、错误）
- **职责分离**：各层管理自己的状态和逻辑
- **处理差异化**：通过获取速度区分，而非类型区分

### 2. 扩展性强
- 数据源类型可独立扩展，无需修改媒体类型核心逻辑
- 新的数据源只需实现统一的状态映射接口
- 支持云盘、FTP、数据库等多种数据源类型

> 详细的数据源扩展设计请参考 [数据源类型设计文档](./数据源类型设计.md)
