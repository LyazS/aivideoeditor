# 数据源扩展类型使用示例

## 概述

本文档提供各种数据源类型的具体使用示例，展示如何在不同场景下创建和使用数据源。

## 1. 用户选择文件场景

### 基本使用

```typescript
// 用户通过文件选择器选择文件
const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement
fileInput.addEventListener('change', (e) => {
  const selectedFile = (e.target as HTMLInputElement).files?.[0]
  if (!selectedFile) return

  // 创建用户选择文件数据源
  const source = new UserSelectedFileSource(selectedFile, (source) => {
    console.log(`文件状态: ${source.getStatus()}`)
    console.log(`进度: ${source.getProgress()}%`)
    
    switch (source.getStatus()) {
      case 'acquiring':
        console.log('正在验证文件...')
        break
      case 'acquired':
        console.log('文件验证成功，可以开始解析')
        console.log(`文件URL: ${source.getUrl()}`)
        break
      case 'error':
        console.error(`文件验证失败: ${source.getError()}`)
        break
    }
  })

  // 开始获取文件
  source.startAcquisition()
})
```

### 拖拽文件场景

```typescript
const dropZone = document.getElementById('drop-zone')

dropZone.addEventListener('drop', (e) => {
  e.preventDefault()
  const files = Array.from(e.dataTransfer.files)
  
  files.forEach(file => {
    const source = new UserSelectedFileSource(file, (source) => {
      updateFileStatus(file.name, source.getStatus(), source.getProgress())
    })
    
    source.startAcquisition()
  })
})

function updateFileStatus(fileName: string, status: string, progress: number) {
  const statusElement = document.getElementById(`status-${fileName}`)
  if (statusElement) {
    statusElement.textContent = `${fileName}: ${status} (${progress}%)`
  }
}
```

## 2. 工程文件场景

### 工程加载

```typescript
// 从工程配置加载媒体项目
const projectFiles = [
  {
    filePath: 'C:/Users/xxx/video1.mp4',
    fileName: 'video1.mp4',
    fileSize: 1024000,
    lastModified: 1640995200000
  },
  {
    filePath: 'C:/Users/xxx/audio1.mp3',
    fileName: 'audio1.mp3',
    fileSize: 512000,
    lastModified: 1640995300000
  }
]

projectFiles.forEach(fileInfo => {
  const source = new ProjectFileSource(fileInfo, (source) => {
    console.log(`${fileInfo.fileName} 状态: ${source.getStatus()}`)
    
    if (source.getStatus() === 'missing') {
      console.log(`文件缺失: ${fileInfo.filePath}`)
      // 显示文件重新定位对话框
      showFileRelocateDialog(source)
    } else if (source.getStatus() === 'acquired') {
      console.log(`文件找到: ${fileInfo.fileName}`)
    }
  })
  
  source.startAcquisition()
})
```

### 文件重新定位

```typescript
function showFileRelocateDialog(source: ProjectFileSource) {
  const fileInfo = source.getFileInfo()
  
  // 创建文件选择对话框
  const input = document.createElement('input')
  input.type = 'file'
  input.accept = getAcceptType(fileInfo.fileName)
  
  input.addEventListener('change', (e) => {
    const newFile = (e.target as HTMLInputElement).files?.[0]
    if (newFile) {
      // 验证文件是否匹配
      if (validateFileMatch(newFile, fileInfo)) {
        source.relocateFile(newFile)
        console.log(`文件重新定位成功: ${fileInfo.fileName}`)
      } else {
        console.error('选择的文件与原文件不匹配')
      }
    }
  })
  
  input.click()
}

function validateFileMatch(newFile: File, originalInfo: any): boolean {
  // 检查文件名
  if (newFile.name !== originalInfo.fileName) {
    return confirm(`文件名不匹配，是否继续？\n原文件: ${originalInfo.fileName}\n新文件: ${newFile.name}`)
  }
  
  // 检查文件大小（允许一定误差）
  if (originalInfo.fileSize && Math.abs(newFile.size - originalInfo.fileSize) > 1024) {
    return confirm(`文件大小不匹配，是否继续？\n原大小: ${originalInfo.fileSize}\n新大小: ${newFile.size}`)
  }
  
  return true
}
```

## 3. 远程文件场景

### 基本下载

```typescript
// 下载远程文件
const remoteUrl = 'https://example.com/video.mp4'
const config: RemoteFileConfig = {
  headers: { 
    'Authorization': 'Bearer your-token',
    'User-Agent': 'VideoEditor/1.0'
  },
  timeout: 30000,
  retryCount: 3,
  retryDelay: 1000
}

const source = new RemoteFileSource(remoteUrl, config, (source) => {
  const status = source.getStatus()
  const progress = source.getProgress()
  
  console.log(`下载状态: ${status}, 进度: ${progress}%`)
  
  if (source.getType() === 'remote') {
    const remoteSource = source as RemoteFileSource
    const stats = remoteSource.getDownloadStats()
    
    if (stats.downloadSpeed) {
      console.log(`下载速度: ${stats.downloadSpeed}`)
    }
    
    if (stats.totalBytes > 0) {
      console.log(`已下载: ${formatBytes(stats.downloadedBytes)} / ${formatBytes(stats.totalBytes)}`)
    }
  }
  
  switch (status) {
    case 'acquiring':
      updateDownloadUI('downloading', progress)
      break
    case 'acquired':
      updateDownloadUI('completed', 100)
      console.log('下载完成，开始解析文件')
      break
    case 'error':
      updateDownloadUI('error', 0)
      console.error(`下载失败: ${source.getError()}`)
      break
  }
})

source.startAcquisition()
```

### 批量下载管理

```typescript
class BatchDownloadManager {
  private downloads: Map<string, RemoteFileSource> = new Map()
  private maxConcurrent = 3
  private currentDownloads = 0
  private queue: string[] = []

  addDownload(url: string, config?: RemoteFileConfig) {
    const source = new RemoteFileSource(url, config, (source) => {
      this.handleDownloadUpdate(url, source)
    })
    
    this.downloads.set(url, source)
    this.queue.push(url)
    this.processQueue()
  }

  private processQueue() {
    while (this.currentDownloads < this.maxConcurrent && this.queue.length > 0) {
      const url = this.queue.shift()!
      const source = this.downloads.get(url)!
      
      this.currentDownloads++
      source.startAcquisition()
    }
  }

  private handleDownloadUpdate(url: string, source: RemoteFileSource) {
    const status = source.getStatus()
    
    if (status === 'acquired' || status === 'error' || status === 'cancelled') {
      this.currentDownloads--
      this.processQueue() // 处理队列中的下一个下载
    }
    
    // 更新UI
    this.updateDownloadProgress(url, source)
  }

  private updateDownloadProgress(url: string, source: RemoteFileSource) {
    const element = document.getElementById(`download-${this.getUrlId(url)}`)
    if (element) {
      const stats = source.getDownloadStats()
      element.innerHTML = `
        <div>URL: ${url}</div>
        <div>状态: ${source.getStatus()}</div>
        <div>进度: ${source.getProgress()}%</div>
        <div>速度: ${stats.downloadSpeed || 'N/A'}</div>
      `
    }
  }

  cancelDownload(url: string) {
    const source = this.downloads.get(url)
    if (source) {
      source.cancel()
    }
  }

  retryDownload(url: string) {
    const source = this.downloads.get(url)
    if (source) {
      source.retry()
    }
  }

  private getUrlId(url: string): string {
    return btoa(url).replace(/[^a-zA-Z0-9]/g, '')
  }
}

// 使用示例
const batchManager = new BatchDownloadManager()

const urls = [
  'https://example.com/video1.mp4',
  'https://example.com/video2.mp4',
  'https://example.com/audio1.mp3'
]

urls.forEach(url => {
  batchManager.addDownload(url, {
    timeout: 30000,
    retryCount: 2
  })
})
```

## 4. 混合场景使用

### 媒体项目创建

```typescript
function createMediaFromSource(source: DataSource): Promise<UnifiedMediaItem> {
  return new Promise((resolve, reject) => {
    const mediaItem = new UnifiedMediaItem(source, {
      onSourceUpdate: (source) => {
        console.log(`数据源更新: ${source.getType()} - ${source.getStatus()}`)
      },
      onStatusChange: (item) => {
        console.log(`媒体状态: ${item.getMediaStatus()}`)
        
        if (item.getMediaStatus() === 'ready') {
          resolve(item)
        } else if (item.getMediaStatus() === 'error') {
          reject(new Error(item.getError() || '未知错误'))
        }
      }
    })
    
    mediaItem.startAcquisition()
  })
}

// 使用示例
async function loadMultipleMedia() {
  const sources = [
    new UserSelectedFileSource(selectedFile),
    new ProjectFileSource(projectFileInfo),
    new RemoteFileSource('https://example.com/video.mp4')
  ]
  
  try {
    const mediaItems = await Promise.all(
      sources.map(source => createMediaFromSource(source))
    )
    
    console.log(`成功加载 ${mediaItems.length} 个媒体项目`)
    return mediaItems
  } catch (error) {
    console.error('加载媒体项目失败:', error)
    throw error
  }
}
```

