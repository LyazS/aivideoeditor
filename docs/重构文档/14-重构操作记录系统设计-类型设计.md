# é‡æ„æ“ä½œè®°å½•ç³»ç»Ÿè®¾è®¡ - ç±»å‹æ¥å£è®¾è®¡

## æ¦‚è¿°

åŸºäºAIè§†é¢‘ç¼–è¾‘å™¨çš„é‡æ„æ¶æ„ï¼ˆç»Ÿä¸€åª’ä½“ç±»å‹å’Œæ—¶é—´è½´é¡¹ç›®è®¾è®¡ï¼‰ï¼Œæœ¬æ–‡æ¡£è®¾è®¡äº†æ–°çš„æ“ä½œè®°å½•ç³»ç»Ÿçš„æ ¸å¿ƒç±»å‹æ¥å£ï¼Œä»¥æ”¯æŒUnifiedMediaItemå’ŒUnifiedTimelineItemçš„æ’¤é”€/é‡åšæ“ä½œã€‚æ–°ç³»ç»Ÿå°†ä¸é‡æ„åçš„çŠ¶æ€é©±åŠ¨æ¶æ„å®Œç¾é›†æˆï¼Œæä¾›ç±»å‹å®‰å…¨ã€æ‰©å±•æ€§å¼ºçš„æ“ä½œè®°å½•èƒ½åŠ›ã€‚

## å½“å‰æ“ä½œè®°å½•ç³»ç»Ÿåˆ†æ

### 1. ç°æœ‰ç³»ç»Ÿä¼˜åŠ¿

- **å‘½ä»¤æ¨¡å¼å®ç°**ï¼šæ¸…æ™°çš„SimpleCommandæ¥å£ï¼Œæ”¯æŒexecute/undoæ“ä½œ
- **æ‰¹é‡æ“ä½œæ”¯æŒ**ï¼šBaseBatchCommandå’ŒBatchBuilderæä¾›æ‰¹é‡æ“ä½œèƒ½åŠ›
- **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
- **å†å²ç®¡ç†**ï¼šSimpleHistoryManageræä¾›æ’¤é”€/é‡åšæ ˆç®¡ç†
- **é€šçŸ¥é›†æˆ**ï¼šä¸NotificationManageré›†æˆï¼Œæä¾›ç”¨æˆ·åé¦ˆ

### 2. ç°æœ‰ç³»ç»Ÿé—®é¢˜

- **åŒé‡ç±»å‹å¤æ‚æ€§**ï¼šéœ€è¦å¤„ç†LocalTimelineItemå’ŒAsyncProcessingTimelineItemä¸¤å¥—ç±»å‹
- **çŠ¶æ€ç®¡ç†åˆ†æ•£**ï¼šæ“ä½œè®°å½•ä¸çŠ¶æ€ç®¡ç†é€»è¾‘è€¦åˆ
- **é‡å»ºé€»è¾‘å¤æ‚**ï¼š"ä»æºå¤´é‡å»º"åŸåˆ™å¯¼è‡´å¤æ‚çš„æ•°æ®ä¿å­˜å’Œæ¢å¤é€»è¾‘
- **æ‰©å±•æ€§é™åˆ¶**ï¼šéš¾ä»¥æ”¯æŒæ–°çš„åª’ä½“ç±»å‹å’Œæ•°æ®æº

## é‡æ„æ“ä½œè®°å½•ç³»ç»Ÿè®¾è®¡

### 1. æ ¸å¿ƒè®¾è®¡ç†å¿µ

**çŠ¶æ€é©±åŠ¨çš„æ“ä½œè®°å½•**ï¼š
- æ“ä½œè®°å½•ä¸å†ç›´æ¥æ“ä½œæ•°æ®ï¼Œè€Œæ˜¯è§¦å‘çŠ¶æ€è½¬æ¢
- åˆ©ç”¨é‡æ„åçš„çŠ¶æ€æœºæ¨¡å¼ï¼Œç¡®ä¿æ“ä½œçš„ä¸€è‡´æ€§å’Œå¯é¢„æµ‹æ€§
- é€šè¿‡TransitionContextè®°å½•æ“ä½œä¸Šä¸‹æ–‡ï¼Œæ”¯æŒç²¾ç¡®çš„æ’¤é”€/é‡åš

**ç»Ÿä¸€çš„æ“ä½œæ¥å£**ï¼š
- åŸºäºUnifiedMediaItemå’ŒUnifiedTimelineItemçš„ç»Ÿä¸€æ“ä½œæ¥å£
- æ¶ˆé™¤åŒé‡ç±»å‹ç³»ç»Ÿå¸¦æ¥çš„å¤æ‚æ€§
- æ”¯æŒæ•°æ®æºæ— å…³çš„æ“ä½œè®°å½•

### 2. æ–°çš„å‘½ä»¤æ¥å£è®¾è®¡

```typescript
/**
 * é‡æ„åçš„ç»Ÿä¸€å‘½ä»¤æ¥å£
 * åŸºäºçŠ¶æ€è½¬æ¢çš„æ“ä½œè®°å½•ï¼Œæ”¯æŒä¸°å¯Œçš„ä¸Šä¸‹æ–‡ä¿¡æ¯
 */
export interface UnifiedCommand {
  // åŸºç¡€å±æ€§
  id: string
  description: string
  timestamp: number
  
  // æ“ä½œç±»å‹æ ‡è¯†
  operationType: OperationType
  
  // ç›®æ ‡å¯¹è±¡ä¿¡æ¯
  targetInfo: CommandTargetInfo
  
  // çŠ¶æ€è½¬æ¢ä¿¡æ¯
  stateTransition: StateTransitionInfo
  
  // æ‰§è¡Œå’Œæ’¤é”€æ–¹æ³•
  execute(): Promise<CommandResult>
  undo(): Promise<CommandResult>
  
  // å¯é€‰çš„éªŒè¯æ–¹æ³•
  canExecute?(): boolean
  canUndo?(): boolean
  
  // æ“ä½œåˆå¹¶æ”¯æŒï¼ˆç”¨äºä¼˜åŒ–å†å²è®°å½•ï¼‰
  canMergeWith?(other: UnifiedCommand): boolean
  mergeWith?(other: UnifiedCommand): UnifiedCommand
}

/**
 * æ“ä½œç±»å‹æšä¸¾
 */
export type OperationType =
  // æ—¶é—´è½´é¡¹ç›®æ“ä½œ
  | 'timeline.create' | 'timeline.delete' | 'timeline.move' | 'timeline.split' | 'timeline.duplicate'
  // å±æ€§æ“ä½œ
  | 'property.update' | 'property.batch_update'
  // å…³é”®å¸§æ“ä½œ
  | 'keyframe.create' | 'keyframe.delete' | 'keyframe.update' | 'keyframe.clear'
  // è½¨é“æ“ä½œ
  | 'track.create' | 'track.delete' | 'track.reorder'
  // é€‰æ‹©æ“ä½œ
  | 'selection.change'
  // æ‰¹é‡æ“ä½œ
  | 'batch.operation'

/**
 * å‘½ä»¤ç›®æ ‡ä¿¡æ¯
 */
export interface CommandTargetInfo {
  type: 'timeline' | 'track' | 'selection' | 'batch'
  ids: string[] // ç›®æ ‡å¯¹è±¡IDåˆ—è¡¨
  metadata?: Record<string, any> // é¢å¤–çš„ç›®æ ‡ä¿¡æ¯
}

/**
 * çŠ¶æ€è½¬æ¢ä¿¡æ¯
 */
export interface StateTransitionInfo {
  // å‰ç½®çŠ¶æ€å¿«ç…§
  beforeState: StateSnapshot
  // åç½®çŠ¶æ€å¿«ç…§ï¼ˆæ‰§è¡Œåå¡«å……ï¼‰
  afterState?: StateSnapshot
  // è½¬æ¢ä¸Šä¸‹æ–‡
  transitionContext?: TransitionContext
}

/**
 * çŠ¶æ€å¿«ç…§
 */
export interface StateSnapshot {
  // æ—¶é—´è½´é¡¹ç›®çŠ¶æ€å¿«ç…§
  timelineItems?: Record<string, TimelineItemSnapshot>
  // è½¨é“çŠ¶æ€å¿«ç…§
  tracks?: Record<string, TrackSnapshot>
  // é€‰æ‹©çŠ¶æ€å¿«ç…§
  selection?: SelectionSnapshot
}

/**
 * å‘½ä»¤æ‰§è¡Œç»“æœ
 */
export interface CommandResult {
  success: boolean
  error?: string
  affectedItems?: string[]
  stateChanges?: StateSnapshot
}

/**
 * æ—¶é—´è½´é¡¹ç›®çŠ¶æ€å¿«ç…§
 */
export interface TimelineItemSnapshot {
  id: string
  mediaItemId: string
  trackId?: string
  timelineStatus: TimelineItemStatus
  statusContext?: TimelineStatusContext
  timeRange: {
    timelineStartTime: number
    timelineEndTime: number
  }
  config: any // åºåˆ—åŒ–çš„é…ç½®
  hasSprite: boolean
}

/**
 * è½¨é“çŠ¶æ€å¿«ç…§
 */
export interface TrackSnapshot {
  id: string
  name: string
  type: TrackType
  isVisible: boolean
  isMuted: boolean
  height: number
  order: number
}

/**
 * é€‰æ‹©çŠ¶æ€å¿«ç…§
 */
export interface SelectionSnapshot {
  selectedTimelineItemIds: string[]
  selectedTrackIds: string[]
  focusedItemId?: string
}



/**
 * ç»Ÿä¸€æ—¶é—´è½´æ¨¡å—æ¥å£
 */
export interface UnifiedTimelineModule {
  getTimelineItem(id: string): UnifiedTimelineItem | undefined
  createTimelineItem(config: TimelineItemConfig): Promise<UnifiedTimelineItem>
  removeTimelineItem(id: string): Promise<void>
  splitTimelineItem(item: UnifiedTimelineItem, splitTime: number): Promise<{
    firstItem: UnifiedTimelineItem
    secondItem: UnifiedTimelineItem
  }>
  restoreTimelineItemFromSnapshot(snapshot: TimelineItemSnapshot): Promise<UnifiedTimelineItem>
  getAllTimelineItems(): UnifiedTimelineItem[]
}

/**
 * Spriteç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨æ¥å£
 */
export interface SpriteLifecycleManager {
  createSprite(timelineItem: UnifiedTimelineItem): Promise<void>
  destroySprite(timelineItem: UnifiedTimelineItem): Promise<void>
  updateSprite(timelineItem: UnifiedTimelineItem): Promise<void>
}

/**
 * æ—¶é—´è½´é¡¹ç›®åˆ›å»ºé…ç½®
 */
export interface TimelineItemConfig {
  mediaItemId: string
  trackId: string
  timeRange: {
    timelineStartTime: number
    timelineEndTime: number
  }
  config: BasicTimelineConfig
}
```

### 3. æ—¶é—´è½´é¡¹ç›®æ“ä½œå‘½ä»¤åŸºç±»

```typescript
/**
 * ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®æ“ä½œå‘½ä»¤åŸºç±»
 * åŸºäºUnifiedTimelineItemçš„çŠ¶æ€è½¬æ¢å®ç°æ“ä½œè®°å½•
 */
export abstract class UnifiedTimelineCommand implements UnifiedCommand {
  public readonly id: string
  public readonly description: string
  public readonly timestamp: number
  public readonly operationType: OperationType
  public readonly targetInfo: CommandTargetInfo
  public readonly stateTransition: StateTransitionInfo

  constructor(
    operationType: OperationType,
    targetIds: string[],
    description: string,
    protected timelineModule: UnifiedTimelineModule,
    protected spriteManager: SpriteLifecycleManager
  ) {
    this.id = generateCommandId()
    this.description = description
    this.timestamp = Date.now()
    this.operationType = operationType
    this.targetInfo = {
      type: 'timeline',
      ids: targetIds
    }

    this.stateTransition = {
      beforeState: this.createStateSnapshot()
    }
  }

  /**
   * åˆ›å»ºæ—¶é—´è½´çŠ¶æ€å¿«ç…§
   */
  protected createStateSnapshot(): StateSnapshot {
    const timelineItems: Record<string, TimelineItemSnapshot> = {}

    for (const id of this.targetInfo.ids) {
      const item = this.timelineModule.getTimelineItem(id)
      if (item) {
        timelineItems[id] = {
          id: item.id,
          mediaItemId: item.mediaItemId,
          trackId: item.trackId,
          timelineStatus: item.timelineStatus,
          statusContext: item.statusContext,
          timeRange: { ...item.timeRange },
          config: this.serializeConfig(item.config),
          hasSprite: !!item.sprite
        }
      }
    }

    return { timelineItems }
  }

  protected serializeConfig(config: BasicTimelineConfig): any {
    return {
      name: config.name,
      mediaConfig: { ...config.mediaConfig },
      animation: config.animation ? { ...config.animation } : undefined
    }
  }

  abstract execute(): Promise<CommandResult>
  abstract undo(): Promise<CommandResult>
}
```

### 4. æ‰¹é‡æ“ä½œå‘½ä»¤æ¥å£

```typescript
/**
 * ç»Ÿä¸€æ‰¹é‡å‘½ä»¤
 * æ”¯æŒå¤šç§ç±»å‹å‘½ä»¤çš„æ‰¹é‡æ‰§è¡Œï¼Œæä¾›æ™ºèƒ½çš„æ’¤é”€/é‡åš
 */
export class UnifiedBatchCommand implements UnifiedCommand {
  public readonly id: string
  public readonly description: string
  public readonly timestamp: number
  public readonly operationType: OperationType = 'batch.operation'
  public readonly targetInfo: CommandTargetInfo
  public readonly stateTransition: StateTransitionInfo

  private subCommands: UnifiedCommand[] = []
  private executedCommands: UnifiedCommand[] = []

  constructor(
    description: string,
    commands: UnifiedCommand[]
  ) {
    this.id = generateCommandId()
    this.description = description
    this.timestamp = Date.now()
    this.subCommands = [...commands]

    // æ”¶é›†æ‰€æœ‰ç›®æ ‡ä¿¡æ¯
    this.targetInfo = this.collectTargetInfo()

    // åˆ›å»ºåˆå¹¶çš„çŠ¶æ€å¿«ç…§
    this.stateTransition = {
      beforeState: this.createMergedStateSnapshot()
    }
  }

  private collectTargetInfo(): CommandTargetInfo {
    const allIds = new Set<string>()
    const types = new Set<string>()

    for (const cmd of this.subCommands) {
      cmd.targetInfo.ids.forEach(id => allIds.add(id))
      types.add(cmd.targetInfo.type)
    }

    return {
      type: types.size === 1 ? Array.from(types)[0] as any : 'batch',
      ids: Array.from(allIds)
    }
  }

  private createMergedStateSnapshot(): StateSnapshot {
    const merged: StateSnapshot = {
      timelineItems: {},
      tracks: {},
      selection: undefined
    }

    for (const cmd of this.subCommands) {
      const snapshot = cmd.stateTransition.beforeState

      // åˆå¹¶å„ç±»å‹çš„çŠ¶æ€å¿«ç…§
      if (snapshot.timelineItems) {
        Object.assign(merged.timelineItems!, snapshot.timelineItems)
      }
      if (snapshot.tracks) {
        Object.assign(merged.tracks!, snapshot.tracks)
      }
      if (snapshot.selection) {
        merged.selection = snapshot.selection
      }
    }

    return merged
  }

  async execute(): Promise<CommandResult> {
    // å®ç°æ‰¹é‡æ‰§è¡Œé€»è¾‘
    // è¯¦ç»†å®ç°è§ä½¿ç”¨ç¤ºä¾‹æ–‡æ¡£
  }

  async undo(): Promise<CommandResult> {
    // å®ç°æ‰¹é‡æ’¤é”€é€»è¾‘
    // è¯¦ç»†å®ç°è§ä½¿ç”¨ç¤ºä¾‹æ–‡æ¡£
  }

  canExecute(): boolean {
    return this.subCommands.every(cmd => cmd.canExecute?.() !== false)
  }

  canUndo(): boolean {
    return this.executedCommands.every(cmd => cmd.canUndo?.() !== false)
  }

  /**
   * è·å–æ‰¹é‡æ“ä½œæ‘˜è¦
   */
  getBatchSummary(): string {
    return `${this.description} (${this.subCommands.length}ä¸ªæ“ä½œ)`
  }
}
```

### 5. å‘½ä»¤åˆå¹¶å™¨æ¥å£

```typescript
/**
 * å‘½ä»¤åˆå¹¶å™¨
 * æä¾›æ™ºèƒ½çš„å‘½ä»¤åˆå¹¶é€»è¾‘ï¼Œä¼˜åŒ–å†å²è®°å½•
 */
export class CommandMerger {
  /**
   * æ£€æŸ¥ä¸¤ä¸ªå‘½ä»¤æ˜¯å¦å¯ä»¥åˆå¹¶
   */
  static canMerge(cmd1: UnifiedCommand, cmd2: UnifiedCommand): boolean {
    // åŸºç¡€åˆå¹¶æ¡ä»¶
    if (cmd1.operationType !== cmd2.operationType) return false
    if (cmd1.targetInfo.type !== cmd2.targetInfo.type) return false

    // æ—¶é—´çª—å£æ£€æŸ¥ï¼ˆ5ç§’å†…çš„æ“ä½œå¯ä»¥åˆå¹¶ï¼‰
    const timeDiff = Math.abs(cmd2.timestamp - cmd1.timestamp)
    if (timeDiff > 5000) return false

    // ç‰¹å®šæ“ä½œç±»å‹çš„åˆå¹¶é€»è¾‘
    switch (cmd1.operationType) {
      case 'property.update':
        return this.canMergePropertyUpdates(cmd1, cmd2)
      case 'timeline.move':
        return this.canMergeTimelineMoves(cmd1, cmd2)
      default:
        return cmd1.canMergeWith?.(cmd2) || false
    }
  }

  /**
   * åˆå¹¶ä¸¤ä¸ªå‘½ä»¤
   */
  static merge(cmd1: UnifiedCommand, cmd2: UnifiedCommand): UnifiedCommand {
    if (!this.canMerge(cmd1, cmd2)) {
      throw new Error('å‘½ä»¤æ— æ³•åˆå¹¶')
    }

    return cmd1.mergeWith!(cmd2)
  }

  private static canMergePropertyUpdates(cmd1: UnifiedCommand, cmd2: UnifiedCommand): boolean {
    // ç›¸åŒç›®æ ‡çš„å±æ€§æ›´æ–°å¯ä»¥åˆå¹¶
    return cmd1.targetInfo.ids.length === 1 &&
           cmd2.targetInfo.ids.length === 1 &&
           cmd1.targetInfo.ids[0] === cmd2.targetInfo.ids[0]
  }

  private static canMergeTimelineMoves(cmd1: UnifiedCommand, cmd2: UnifiedCommand): boolean {
    // ç›¸åŒé¡¹ç›®çš„è¿ç»­ç§»åŠ¨å¯ä»¥åˆå¹¶
    return cmd1.targetInfo.ids.length === 1 &&
           cmd2.targetInfo.ids.length === 1 &&
           cmd1.targetInfo.ids[0] === cmd2.targetInfo.ids[0]
  }
}
```

### 6. é‡æ„å†å²ç®¡ç†å™¨æ¥å£

```typescript
/**
 * é‡æ„åçš„ç»Ÿä¸€å†å²ç®¡ç†å™¨
 * æ”¯æŒUnifiedCommandæ¥å£å’Œæ™ºèƒ½å‘½ä»¤åˆå¹¶
 */
export class UnifiedHistoryManager {
  private commands: UnifiedCommand[] = []
  private currentIndex = -1
  private maxHistorySize = 100

  constructor(
    private notificationManager: NotificationManager,
    private commandMerger: CommandMerger = new CommandMerger()
  ) {}

  /**
   * æ‰§è¡Œå‘½ä»¤å¹¶æ·»åŠ åˆ°å†å²è®°å½•
   */
  async executeCommand(command: UnifiedCommand): Promise<void> {
    // è¯¦ç»†å®ç°è§ä½¿ç”¨ç¤ºä¾‹æ–‡æ¡£
  }

  /**
   * æ’¤é”€ä¸Šä¸€ä¸ªå‘½ä»¤
   */
  async undo(): Promise<boolean> {
    // è¯¦ç»†å®ç°è§ä½¿ç”¨ç¤ºä¾‹æ–‡æ¡£
  }

  /**
   * é‡åšä¸‹ä¸€ä¸ªå‘½ä»¤
   */
  async redo(): Promise<boolean> {
    // è¯¦ç»†å®ç°è§ä½¿ç”¨ç¤ºä¾‹æ–‡æ¡£
  }

  canUndo(): boolean {
    return this.currentIndex >= 0
  }

  canRedo(): boolean {
    return this.currentIndex < this.commands.length - 1
  }

  clear(): void {
    this.commands = []
    this.currentIndex = -1
    console.log('ğŸ—‘ï¸ å†å²è®°å½•å·²æ¸…ç©º')
  }

  /**
   * è·å–å†å²è®°å½•æ‘˜è¦
   */
  getHistorySummary() {
    return {
      totalCommands: this.commands.length,
      currentIndex: this.currentIndex,
      canUndo: this.canUndo(),
      canRedo: this.canRedo(),
      commands: this.commands.map((cmd, index) => ({
        id: cmd.id,
        description: cmd.description,
        operationType: cmd.operationType,
        timestamp: cmd.timestamp,
        isCurrent: index === this.currentIndex,
        isExecuted: index <= this.currentIndex,
        targetCount: cmd.targetInfo.ids.length
      }))
    }
  }
}
```

## è®¾è®¡ä¼˜åŠ¿

### 1. æ¶æ„ç»Ÿä¸€
- **æ¶ˆé™¤åŒé‡ç±»å‹**ï¼šåŸºäºUnifiedMediaItemå’ŒUnifiedTimelineItemçš„ç»Ÿä¸€æ“ä½œ
- **çŠ¶æ€é©±åŠ¨**ï¼šåˆ©ç”¨é‡æ„åçš„çŠ¶æ€æœºæ¨¡å¼ï¼Œç¡®ä¿æ“ä½œä¸€è‡´æ€§
- **ä¸Šä¸‹æ–‡ä¸°å¯Œ**ï¼šé€šè¿‡TransitionContextæä¾›è¯¦ç»†çš„æ“ä½œä¸Šä¸‹æ–‡

### 2. ç±»å‹å®‰å…¨å’Œå¯ç»´æŠ¤æ€§
- **å®Œæ•´çš„TypeScriptæ”¯æŒ**ï¼šæ‰€æœ‰æ¥å£éƒ½æœ‰ä¸¥æ ¼çš„ç±»å‹å®šä¹‰
- **ç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥**ï¼šç±»å‹ç³»ç»Ÿå¯ä»¥åœ¨ç¼–è¯‘æ—¶æ•è·å¤§éƒ¨åˆ†é”™è¯¯
- **æ™ºèƒ½ä»£ç æç¤º**ï¼šIDEå¯ä»¥æä¾›å‡†ç¡®çš„ä»£ç è¡¥å…¨å’Œæ–‡æ¡£

### 3. æ‰©å±•æ€§å’Œçµæ´»æ€§
- **æ’ä»¶åŒ–å‘½ä»¤ç³»ç»Ÿ**ï¼šæ–°çš„æ“ä½œç±»å‹å¯ä»¥è½»æ¾æ‰©å±•
- **æ•°æ®æºæ— å…³**ï¼šæ”¯æŒä»»æ„ç±»å‹çš„æ•°æ®æºæ“ä½œè®°å½•
- **æ‰¹é‡æ“ä½œæ”¯æŒ**ï¼šç»Ÿä¸€çš„æ‰¹é‡å‘½ä»¤å¤„ç†æœºåˆ¶

---

*æ–‡æ¡£åˆ›å»ºæ—¶é—´ï¼š2025-01-19*
*åŸºäºé‡æ„æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*
*å…³è”æ–‡æ¡£ï¼š07-åª’ä½“ç±»å‹ç»Ÿä¸€è®¾è®¡-ç±»å‹è®¾è®¡.md, 10-ç»Ÿä¸€æ—¶é—´è½´é¡¹ç›®è®¾è®¡-ç±»å‹è®¾è®¡.md*
