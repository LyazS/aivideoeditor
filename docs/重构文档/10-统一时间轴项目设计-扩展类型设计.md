# 统一时间轴项目设计 - 扩展类型设计

## 状态转换上下文设计

### 基础上下文接口

```typescript
interface BaseTimelineTransitionContext {
  timestamp: number
  source: string         // 触发来源
  reason: string         // 转换原因
  mediaItemId: string    // 关联媒体项目ID
}
```

### 具体转换上下文类型

```typescript
// 媒体项目就绪
interface MediaReadyContext extends BaseTimelineTransitionContext {
  type: 'media_ready'
  mediaItem: UnifiedMediaItem
  spriteCreated: boolean
}

// 开始加载
interface LoadingStartedContext extends BaseTimelineTransitionContext {
  type: 'loading_started'
  loadingConfig: LoadingConfig
  loadingPhase: 'pending' | 'downloading' | 'processing' | 'preparing'
}

// Sprite准备完成
interface SpritePreparedContext extends BaseTimelineTransitionContext {
  type: 'sprite_prepared'
  sprite: Raw<CustomSprite>
  webavObjects: any
  preparationTime: number
}

// 错误处理
interface TimelineErrorContext extends BaseTimelineTransitionContext {
  type: 'timeline_error'
  errorMessage: string
  errorCode: string
  errorDetails?: any
  retryable: boolean
}

// 联合类型
export type TimelineTransitionContext =
  | MediaReadyContext
  | LoadingStartedContext
  | SpritePreparedContext
  | TimelineErrorContext
```

## 状态转移规则

### 有效状态转换映射

```typescript
const VALID_TIMELINE_TRANSITIONS: Record<TimelineItemStatus, TimelineItemStatus[]> = {
  'loading': ['ready', 'error'],    // 加载中 → 就绪或错误
  'ready': ['error', 'loading'],    // 就绪 → 错误或重新加载
  'error': ['loading']              // 错误 → 重新加载重试
}
```

### 状态转换验证工具

```typescript
export const isValidTimelineTransition = (
  from: TimelineItemStatus,
  to: TimelineItemStatus
): boolean => {
  return VALID_TIMELINE_TRANSITIONS[from]?.includes(to) ?? false
}

export const getValidTransitions = (
  status: TimelineItemStatus
): TimelineItemStatus[] => {
  return VALID_TIMELINE_TRANSITIONS[status] ?? []
}
```

## 管理器接口设计

### TimelineItemManager核心接口

```typescript
interface TimelineItemManager {
  // 创建时间轴项目
  createTimelineItem(
    mediaItem: UnifiedMediaItem,
    trackId: string,
    initialTimeRange: BaseTimeRange
  ): UnifiedTimelineItem

  // 订阅管理
  subscribeToMediaItem(mediaItem: UnifiedMediaItem, timelineItem: UnifiedTimelineItem): () => void
  
  // 状态映射方法
  mapMediaStatusToTimelineStatus(mediaStatus: MediaStatus): TimelineItemStatus
  mapMediaStatusToLoadingPhase(mediaStatus: MediaStatus): string
  
  // 工具方法
  createStatusDetail(
    mediaStatus: MediaStatus,
    mediaContext: TransitionContext | undefined,
    mediaItem: UnifiedMediaItem
  ): TimelineItemStatusDetail
  
  createTimelineContext(
    mediaStatus: MediaStatus,
    mediaContext: TransitionContext | undefined,
    mediaItem: UnifiedMediaItem
  ): TimelineTransitionContext | undefined
}
```

### SpriteLifecycleManager接口

```typescript
interface SpriteLifecycleManager {
  // 核心方法
  createSpriteForTimelineItem(
    timelineItem: UnifiedTimelineItem,
    mediaItem: UnifiedMediaItem
  ): Promise<Raw<CustomSprite> | null>

  // 媒体类型对应的创建方法
  createVideoSprite(mediaItem: UnifiedMediaItem, timelineItem: UnifiedTimelineItem): Promise<Raw<CustomSprite>>
  createImageSprite(mediaItem: UnifiedMediaItem, timelineItem: UnifiedTimelineItem): Promise<Raw<CustomSprite>>
  createAudioSprite(mediaItem: UnifiedMediaItem, timelineItem: UnifiedTimelineItem): Promise<Raw<CustomSprite>>
  createTextSprite(mediaItem: UnifiedMediaItem, timelineItem: UnifiedTimelineItem): Promise<Raw<CustomSprite>>
}
```

## 实现示例类

### UnifiedTimelineItemImpl

```typescript
class UnifiedTimelineItemImpl implements UnifiedTimelineItem {
  public timelineStatus: TimelineItemStatus
  public statusDetail: TimelineItemStatusDetail
  
  // 其他属性实现...

  transitionTo(
    newStatus: TimelineItemStatus,
    statusDetail: TimelineItemStatusDetail,
    context?: TimelineTransitionContext
  ): void {
    if (!this.canTransitionTo(newStatus)) {
      throw new Error(`无效的状态转换: ${this.timelineStatus} → ${newStatus}`)
    }

    const oldStatus = this.timelineStatus
    this.timelineStatus = newStatus
    this.statusDetail = statusDetail
    
    this.updatePropertiesForStatus(newStatus, statusDetail, context)
    this.onStatusChanged?.(oldStatus, newStatus, statusDetail, context)
  }

  canTransitionTo(newStatus: TimelineItemStatus): boolean {
    return isValidTimelineTransition(this.timelineStatus, newStatus)
  }

  private updatePropertiesForStatus(
    status: TimelineItemStatus,
    statusDetail: TimelineItemStatusDetail,
    context?: TimelineTransitionContext
  ): void {
    switch (status) {
      case 'loading':
        this.sprite = undefined
        if (context?.type === 'loading_started') {
          this.config = context.loadingConfig
        }
        break
        
      case 'ready':
        if (context?.type === 'sprite_prepared') {
          this.sprite = context.sprite
          this.updateConfigForMediaType()
        }
        break
        
      case 'error':
        this.sprite = undefined
        break
    }
  }
}
```

## 状态验证辅助工具

### 状态约束工具

```typescript
export const validateTimelineItemState = (
  item: UnifiedTimelineItem
): ValidationResult => {
  const errors: string[] = []
  
  // 状态一致性检查
  switch (item.timelineStatus) {
    case 'loading':
      if (item.sprite !== undefined) {
        errors.push('loading状态不应有sprite对象')
      }
      if (!isLoadingConfig(item.config)) {
        errors.push('loading状态应使用LoadingConfig')
      }
      break
      
    case 'ready':
      if (item.sprite === undefined) {
        errors.push('ready状态应有sprite对象')
      }
      break
      
    case 'error':
      if (item.sprite !== undefined) {
        errors.push('error状态不应有sprite对象')
      }
      break
  }
  
  return {
    isValid: errors.length === 0,
    errors
  }
}

interface ValidationResult {
  isValid: boolean
  errors: string[]
}
```

## 事件订阅系统

### 事件接口设计

```typescript
interface TimelineChangeEvent {
  type: 'status_changed'
  itemId: string
  oldStatus: TimelineItemStatus
  newStatus: TimelineItemStatus
  statusDetail: TimelineItemStatusDetail
  context?: TimelineTransitionContext
}

interface TimelineItemObserver {
  onTimelineItemChanged(event: TimelineChangeEvent): void
}

// 订阅管理工具
class TimelineEventManager {
  private observers: Map<string, TimelineItemObserver[]> = new Map()
  
  subscribe(itemId: string, observer: TimelineItemObserver): () => void {
    if (!this.observers.has(itemId)) {
      this.observers.set(itemId, [])
    }
    this.observers.get(itemId)!.push(observer)
    
    return () => this.unsubscribe(itemId, observer)
  }
  
  private unsubscribe(itemId: string, observer: TimelineItemObserver): void {
    const list = this.observers.get(itemId)
    if (list) {
      const index = list.indexOf(observer)
      if (index > -1) {
        list.splice(index, 1)
      }
    }
  }
  
  notify(event: TimelineChangeEvent): void {
    const observers = this.observers.get(event.itemId) ?? []
    observers.forEach(observer => observer.onTimelineItemChanged(event))
  }
}
```