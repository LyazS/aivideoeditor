# 代码规范

## 📋 概述

本文档定义了AI视频编辑器项目的编码标准和最佳实践，确保代码质量、可读性和可维护性。

## 🎯 核心原则

1. **一致性**: 保持代码风格的一致性
2. **可读性**: 代码应该易于理解和维护
3. **类型安全**: 充分利用TypeScript的类型系统
4. **性能优先**: 考虑性能影响的编码实践
5. **模块化**: 保持模块的单一职责和低耦合

## 📝 TypeScript规范

### 类型定义

#### ✅ 正确的类型定义
```typescript
// 明确的接口定义
interface MediaItem {
  id: string
  name: string
  duration: number
  mediaType: 'video' | 'image'
  isReady: boolean
}

// 使用泛型
function processItems<T extends { id: string }>(items: T[]): T[] {
  return items.filter(item => item.id !== '')
}

// 联合类型
type EventType = 'play' | 'pause' | 'seek' | 'stop'

// 工具类型
type PartialMediaItem = Partial<MediaItem>
type RequiredFields = Pick<MediaItem, 'id' | 'name'>
```

#### ❌ 避免的做法
```typescript
// 避免使用any类型
function processData(data: any): any {
  return data
}

// 避免隐式any
function handleEvent(event) { // 缺少类型注解
  console.log(event)
}

// 避免过于宽泛的类型
function updateItem(item: object): void { // 应该使用具体接口
  // ...
}
```

### 函数定义

#### ✅ 推荐的函数风格
```typescript
// 使用箭头函数（简短函数）
const formatTime = (seconds: number): string => {
  const minutes = Math.floor(seconds / 60)
  const secs = Math.floor(seconds % 60)
  return `${minutes}:${secs.toString().padStart(2, '0')}`
}

// 使用function声明（复杂函数）
function createTimelineItem(
  mediaItemId: string,
  trackId: number,
  timeRange: TimeRange
): TimelineItem {
  // 复杂的创建逻辑
  return {
    id: generateId(),
    mediaItemId,
    trackId,
    timeRange,
    // ...其他属性
  }
}

// 异步函数
async function loadMediaFile(file: File): Promise<MediaItem> {
  try {
    const mp4Clip = await createMP4Clip(file)
    return createMediaItem(file, mp4Clip)
  } catch (error) {
    throw new Error(`Failed to load media file: ${error.message}`)
  }
}
```

### 变量命名

#### ✅ 推荐的命名规范
```typescript
// 使用camelCase
const currentTime = 0
const isPlaying = false
const selectedItemIds = new Set<string>()

// 常量使用UPPER_SNAKE_CASE
const DEFAULT_FRAME_RATE = 30
const MAX_ZOOM_LEVEL = 10

// 类型使用PascalCase
interface VideoResolution {
  width: number
  height: number
}

// 枚举使用PascalCase
enum PlaybackState {
  Playing = 'playing',
  Paused = 'paused',
  Stopped = 'stopped'
}
```

## 🎨 Vue组件规范

### 组件结构

#### ✅ 推荐的组件结构
```vue
<script setup lang="ts">
// 1. 导入（按类型分组）
import { ref, computed, onMounted, watch } from 'vue'
import { useVideoStore } from '../stores/videoStore'
import ChildComponent from './ChildComponent.vue'

// 2. 类型定义
interface Props {
  title: string
  items: MediaItem[]
  isVisible?: boolean
}

interface Emits {
  itemSelected: [item: MediaItem]
  visibilityChanged: [visible: boolean]
}

// 3. Props和Emits
const props = withDefaults(defineProps<Props>(), {
  isVisible: true
})

const emit = defineEmits<Emits>()

// 4. 组合式函数
const videoStore = useVideoStore()

// 5. 响应式数据
const isLoading = ref(false)
const selectedItem = ref<MediaItem | null>(null)

// 6. 计算属性
const filteredItems = computed(() => {
  return props.items.filter(item => item.isReady)
})

// 7. 方法
const handleItemClick = (item: MediaItem) => {
  selectedItem.value = item
  emit('itemSelected', item)
}

// 8. 监听器
watch(() => props.isVisible, (visible) => {
  emit('visibilityChanged', visible)
})

// 9. 生命周期钩子
onMounted(() => {
  // 初始化逻辑
})
</script>

<template>
  <div class="component-container">
    <header class="component-header">
      <h2 class="component-title">{{ title }}</h2>
    </header>
    
    <main class="component-content">
      <div
        v-for="item in filteredItems"
        :key="item.id"
        class="item"
        :class="{ 'item--selected': selectedItem?.id === item.id }"
        @click="handleItemClick(item)"
      >
        {{ item.name }}
      </div>
    </main>
  </div>
</template>

<style scoped>
.component-container {
  display: flex;
  flex-direction: column;
  background-color: var(--color-bg-primary);
}

.component-header {
  padding: var(--spacing-medium);
  border-bottom: 1px solid var(--color-border);
}

.component-title {
  margin: 0;
  color: var(--color-text-primary);
  font-size: var(--font-size-large);
}

.component-content {
  flex: 1;
  padding: var(--spacing-medium);
}

.item {
  padding: var(--spacing-small);
  cursor: pointer;
  border-radius: var(--border-radius);
  transition: background-color 0.2s ease;
}

.item:hover {
  background-color: var(--color-bg-hover);
}

.item--selected {
  background-color: var(--color-bg-selected);
  color: var(--color-text-selected);
}
</style>
```

### 组件命名

#### ✅ 推荐的命名规范
```typescript
// 组件文件名使用PascalCase
VideoPreviewEngine.vue
MediaLibrary.vue
TimelineItem.vue

// 组件内部使用kebab-case
<template>
  <video-preview-engine>
    <media-library />
    <timeline-item />
  </video-preview-engine>
</template>
```

## 🎨 CSS规范

### 命名规范

#### ✅ 使用BEM命名规范
```css
/* 块（Block） */
.video-clip {
  position: relative;
  background-color: var(--color-bg-secondary);
}

/* 元素（Element） */
.video-clip__header {
  padding: var(--spacing-small);
  border-bottom: 1px solid var(--color-border);
}

.video-clip__content {
  padding: var(--spacing-medium);
}

.video-clip__title {
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-semibold);
}

/* 修饰符（Modifier） */
.video-clip--selected {
  border: 2px solid var(--color-primary);
  box-shadow: 0 0 0 2px var(--color-primary-alpha);
}

.video-clip--disabled {
  opacity: 0.5;
  pointer-events: none;
}

.video-clip__title--large {
  font-size: var(--font-size-large);
}
```

### CSS变量

#### ✅ 使用CSS变量系统
```css
:root {
  /* 颜色系统 */
  --color-primary: #007acc;
  --color-primary-hover: #005a9e;
  --color-primary-alpha: rgba(0, 122, 204, 0.2);
  
  --color-bg-primary: #1e1e1e;
  --color-bg-secondary: #2d2d2d;
  --color-bg-hover: #3e3e3e;
  --color-bg-selected: #094771;
  
  --color-text-primary: #ffffff;
  --color-text-secondary: #cccccc;
  --color-text-muted: #999999;
  
  --color-border: #404040;
  --color-border-hover: #505050;
  
  /* 间距系统 */
  --spacing-xs: 4px;
  --spacing-small: 8px;
  --spacing-medium: 16px;
  --spacing-large: 24px;
  --spacing-xl: 32px;
  
  /* 字体系统 */
  --font-size-small: 12px;
  --font-size-medium: 14px;
  --font-size-large: 16px;
  --font-size-xl: 18px;
  
  --font-weight-normal: 400;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  
  /* 其他 */
  --border-radius: 4px;
  --border-radius-large: 8px;
  --transition-fast: 0.15s ease;
  --transition-normal: 0.2s ease;
  --shadow-small: 0 2px 4px rgba(0, 0, 0, 0.1);
  --shadow-medium: 0 4px 8px rgba(0, 0, 0, 0.15);
}
```

### 响应式设计

#### ✅ 移动端优先的响应式设计
```css
/* 移动端优先 */
.timeline {
  padding: var(--spacing-small);
  font-size: var(--font-size-small);
}

/* 平板端 */
@media (min-width: 768px) {
  .timeline {
    padding: var(--spacing-medium);
    font-size: var(--font-size-medium);
  }
}

/* 桌面端 */
@media (min-width: 1024px) {
  .timeline {
    padding: var(--spacing-large);
    font-size: var(--font-size-large);
  }
}
```

## 🔧 工具函数规范

### 函数组织

#### ✅ 模块化工具函数
```typescript
// timeUtils.ts - 时间相关工具
export function formatTime(seconds: number): string {
  // 实现
}

export function alignTimeToFrame(time: number, frameRate: number): number {
  // 实现
}

// coordinateUtils.ts - 坐标转换工具
export function timeToPixel(
  time: number, 
  zoomLevel: number, 
  scrollOffset: number
): number {
  // 实现
}

export function pixelToTime(
  pixel: number, 
  zoomLevel: number, 
  scrollOffset: number
): number {
  // 实现
}
```

### 错误处理

#### ✅ 统一的错误处理
```typescript
// 自定义错误类型
class WebAVError extends Error {
  constructor(message: string, public code: string) {
    super(message)
    this.name = 'WebAVError'
  }
}

// 错误处理函数
function handleWebAVError(error: unknown): void {
  if (error instanceof WebAVError) {
    console.error(`WebAV错误 [${error.code}]:`, error.message)
    videoStore.setWebAVError(error.message)
  } else if (error instanceof Error) {
    console.error('未知错误:', error.message)
    videoStore.setWebAVError('发生未知错误')
  } else {
    console.error('未知错误:', error)
    videoStore.setWebAVError('发生未知错误')
  }
}

// 异步操作的错误处理
async function safeAsyncOperation<T>(
  operation: () => Promise<T>,
  errorMessage: string
): Promise<T | null> {
  try {
    return await operation()
  } catch (error) {
    console.error(errorMessage, error)
    handleWebAVError(error)
    return null
  }
}
```

## 📚 注释规范

### JSDoc注释

#### ✅ 完整的JSDoc注释
```typescript
/**
 * 创建时间轴项目
 * @param mediaItemId - 媒体项目ID
 * @param trackId - 轨道ID
 * @param timeRange - 时间范围
 * @param options - 可选配置
 * @returns 创建的时间轴项目
 * @throws {Error} 当媒体项目不存在时抛出错误
 * @example
 * ```typescript
 * const item = createTimelineItem('media-1', 'track-1', { start: 0, end: 10 })
 * ```
 */
function createTimelineItem(
  mediaItemId: string,
  trackId: string,
  timeRange: TimeRange,
  options?: CreateItemOptions
): TimelineItem {
  // 实现
}

/**
 * 视频编辑器的主要配置接口
 * @interface
 */
interface EditorConfig {
  /** 视频分辨率 */
  resolution: VideoResolution
  /** 帧率 */
  frameRate: number
  /** 是否启用硬件加速 */
  enableHardwareAcceleration: boolean
}
```

### 代码注释

#### ✅ 有意义的代码注释
```typescript
// 计算视频在画布中的实际显示尺寸
// 考虑画布缩放和视频原始比例
function calculateDisplaySize(
  originalWidth: number,
  originalHeight: number,
  canvasScale: number
): { width: number; height: number } {
  // 保持原始宽高比
  const aspectRatio = originalWidth / originalHeight
  
  // 根据画布缩放调整尺寸
  const scaledWidth = originalWidth * canvasScale
  const scaledHeight = scaledWidth / aspectRatio
  
  return { width: scaledWidth, height: scaledHeight }
}

// TODO: 优化大文件的加载性能
// FIXME: 修复在某些浏览器中的兼容性问题
// NOTE: 这个函数依赖于WebAV的内部实现
```

## 🚀 性能优化规范

### Vue性能优化

#### ✅ 推荐的性能优化
```typescript
// 使用shallowRef避免深度响应式
const webAVObjects = shallowRef(new Map<string, WebAVObject>())

// 使用markRaw避免响应式包装
const mp4Clip = markRaw(await createMP4Clip(file))

// 使用computed缓存计算结果
const expensiveComputation = computed(() => {
  return heavyCalculation(props.data)
})

// 使用v-memo优化列表渲染
const memoizedItems = computed(() => {
  return items.value.map(item => ({
    ...item,
    memoKey: [item.id, item.name, item.isSelected]
  }))
})
```

### WebAV性能优化

#### ✅ WebAV最佳实践
```typescript
// 复用MP4Clip实例而不是重新创建
const clonedClip = await cloneMP4Clip(originalClip)

// 及时清理资源
onUnmounted(() => {
  sprite?.destroy()
  mp4Clip?.destroy()
})

// 避免频繁的WebAV操作
const debouncedSeek = debounce((time: number) => {
  webAVControls.seekTo(time)
}, 100)
```

## 🔗 相关文档

- [架构设计](架构设计.md) - 系统架构设计和技术选型
- [开发环境](开发环境.md) - 开发环境设置和工作流程
- [API文档](API文档.md) - 详细的API接口文档
- [ESLint配置](../../../frontend/eslint.config.ts) - 代码检查配置

---

**提示**：代码规范是团队协作的基础，请严格遵循这些规范，确保代码质量和一致性。
