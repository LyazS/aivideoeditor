# 统一存储模块注册中心重构方案

## 项目背景

在 `frontend/src/unified/unifiedStore.ts` 中存在多个模块相互依赖的循环依赖问题：
- `UnifiedTimelineModule` 需要 `UnifiedConfigModule`, `UnifiedWebavModule`, `UnifiedMediaModule`, `UnifiedTrackModule`
- `UnifiedProjectModule` 需要几乎所有其他模块
- `UnifiedViewportModule` 需要 `totalDurationFrames`（计算属性）

## 解决方案：先创建后注册模式

### 核心思路
1. **无依赖创建**：所有模块先创建实例，不传入任何依赖
2. **注册到中心**：将创建的模块实例注册到统一的注册中心
3. **动态获取依赖**：在方法内部通过注册中心动态获取所需依赖

## 架构设计

### 1. 模块注册中心

```typescript
// frontend/src/unified/modules/ModuleRegistry.ts
export class ModuleRegistry {
  private modules = new Map<string, any>();
  
  // 注册模块
  register<T>(name: string, module: T): void {
    this.modules.set(name, module);
  }
  
  // 获取模块
  get<T>(name: string): T {
    const module = this.modules.get(name);
    if (!module) {
      throw new Error(`Module '${name}' not found in registry`);
    }
    return module as T;
  }
  
  // 获取所有模块（用于调试）
  getAll(): Record<string, any> {
    return Object.fromEntries(this.modules);
  }
  
  // 清空所有模块
  clear(): void {
    this.modules.clear();
  }
}
```

### 2. 模块类型定义

```typescript
// 模块名称常量
export const MODULE_NAMES = {
  CONFIG: 'config',
  MEDIA: 'media',
  TRACK: 'track',
  PLAYBACK: 'playback',
  WEBAV: 'webav',
  TIMELINE: 'timeline',
  VIEWPORT: 'viewport',
  PROJECT: 'project',
  NOTIFICATION: 'notification',
  HISTORY: 'history',
  SELECTION: 'selection',
  AUTOSAVE: 'autosave',
  VIDEOTHUMBNAIL: 'videothumbnail',
  SNAP: 'snap'
} as const;

// 模块类型映射
type ModuleMap = {
  [MODULE_NAMES.CONFIG]: UnifiedConfigModule;
  [MODULE_NAMES.MEDIA]: UnifiedMediaModule;
  [MODULE_NAMES.TRACK]: UnifiedTrackModule;
  [MODULE_NAMES.PLAYBACK]: UnifiedPlaybackModule;
  [MODULE_NAMES.WEBAV]: UnifiedWebavModule;
  [MODULE_NAMES.TIMELINE]: UnifiedTimelineModule;
  [MODULE_NAMES.VIEWPORT]: UnifiedViewportModule;
  [MODULE_NAMES.PROJECT]: UnifiedProjectModule;
  [MODULE_NAMES.NOTIFICATION]: UnifiedNotificationModule;
  [MODULE_NAMES.HISTORY]: UnifiedHistoryModule;
  [MODULE_NAMES.SELECTION]: UnifiedSelectionModule;
  [MODULE_NAMES.AUTOSAVE]: UnifiedAutoSaveModule;
  [MODULE_NAMES.VIDEOTHUMBNAIL]: UnifiedVideoThumbnailModule;
  [MODULE_NAMES.SNAP]: UnifiedSnapModule;
};
```

## 优化的模块设计 - 通用模块访问器模式

为了解决每个模块需要写多个getXxxModule函数的问题，我们采用更简洁的通用模块访问器模式：

### 3. 模块改造示例 - UnifiedConfigModule（基础模块，保持不变）
```typescript
// frontend/src/unified/modules/UnifiedConfigModule.ts
export function createUnifiedConfigModule() {
  // 状态定义
  const projectId = ref('');
  const projectName = ref('');
  // ... 其他状态
  
  // 方法实现
  function setVideoResolution(resolution: VideoResolution) {
    videoResolution.value = resolution;
  }
  
  // 导出接口
  return {
    projectId,
    projectName,
    setVideoResolution
  };
}
```

### 4. 更优的改造示例 - 直接传入注册中心实例
```typescript
// frontend/src/unified/modules/UnifiedTimelineModule.ts
export function createUnifiedTimelineModule(registry: ModuleRegistry) {
  // 状态定义（无外部依赖）
  const timelineItems = ref<UnifiedTimelineItemData<MediaType>[]>([]);
  
  // 通用模块访问器 - 一个函数代替所有getter
  function useModule<T extends keyof ModuleMap>(name: T): ModuleMap[T] {
    return registry.get<ModuleMap[T]>(name);
  }
  
  // 业务方法中使用通用访问器获取依赖
  async function addTimelineItem(item: UnifiedTimelineItemData<MediaType>) {
    // 简洁地获取所需模块
    const webav = useModule(MODULE_NAMES.WEBAV);
    const config = useModule(MODULE_NAMES.CONFIG);
    const track = useModule(MODULE_NAMES.TRACK);
    
    // 检查时间轴项目状态
    if (TimelineItemQueries.isReady(item)) {
      // 设置Sprite属性（使用动态获取的依赖）
      if (item.runtime.sprite) {
        await webav.addSprite(item.runtime.sprite);
        
        // 根据轨道可见性设置
        const trackData = track.tracks.value.find(t => t.id === item.trackId);
        if (trackData && item.runtime.sprite) {
          item.runtime.sprite.visible = trackData.isVisible;
        }
      }
    }
    
    timelineItems.value.push(item);
  }
  
  function updateTimelineItemPosition(
    timelineItemId: string,
    newPositionFrames: number,
    newTrackId?: string
  ) {
    const item = timelineItems.value.find(item => item.id === timelineItemId);
    if (!item) return;
    
    // 简洁地获取所需模块
    const media = useModule(MODULE_NAMES.MEDIA);
    const track = useModule(MODULE_NAMES.TRACK);
    
    // 使用动态获取的依赖
    if (newTrackId !== undefined) {
      const newTrack = track.tracks.value.find(t => t.id === newTrackId);
      if (newTrack && item.runtime.sprite) {
        item.runtime.sprite.visible = newTrack.isVisible;
      }
    }
    
    // 其他逻辑...
  }
  
  // 导出接口
  return {
    timelineItems,
    addTimelineItem,
    updateTimelineItemPosition,
  };
}
```

### 5. 其他模块采用相同模式
其他需要依赖的模块可以采用相同的模式，直接传入注册中心实例：
```typescript
// UnifiedProjectModule.ts
export function createUnifiedProjectModule(registry: ModuleRegistry) {
  // 统一的useModule函数
  function useModule<T extends keyof ModuleMap>(name: T): ModuleMap[T] {
    return registry.get<ModuleMap[T]>(name);
  }
  
  async function saveCurrentProject() {
    // 在需要时获取依赖
    const config = useModule(MODULE_NAMES.CONFIG);
    const timeline = useModule(MODULE_NAMES.TIMELINE);
    const track = useModule(MODULE_NAMES.TRACK);
    const media = useModule(MODULE_NAMES.MEDIA);
    
    // 业务逻辑...
  }
  
  return { saveCurrentProject };
}
```

## 统一存储的改造

### 原版本（复杂依赖链）
```typescript
export const useUnifiedStore = defineStore('unified', () => {
  // 创建配置管理模块
  const unifiedConfigModule = createUnifiedConfigModule();
  
  // 创建播放控制模块
  const unifiedPlaybackModule = createUnifiedPlaybackModule(unifiedConfigModule.frameRate);
  
  // 创建WebAV集成模块
  const unifiedWebavModule = createUnifiedWebavModule({
    currentFrame: unifiedPlaybackModule.currentFrame,
    currentWebAVFrame: unifiedPlaybackModule.currentWebAVFrame,
    isPlaying: unifiedPlaybackModule.isPlaying,
    setCurrentFrame: unifiedPlaybackModule.setCurrentFrame,
    setPlaying: unifiedPlaybackModule.setPlaying,
  });
  
  // 创建统一时间轴管理模块（需要依赖其他模块）
  const unifiedTimelineModule = createUnifiedTimelineModule(
    unifiedConfigModule,
    unifiedWebavModule,
    unifiedMediaModule,
    unifiedTrackModule,
  );
  
  // ... 大量复杂的依赖链
});
```

### 改造版本（清晰的分阶段创建）
```typescript
// frontend/src/unified/unifiedStore.ts
import { ModuleRegistry } from './modules/ModuleRegistry';
import { MODULE_NAMES } from './modules/ModuleRegistry';

export const useUnifiedStore = defineStore('unified', () => {
  // 创建注册中心
  const registry = new ModuleRegistry();
  
  // 阶段1：创建无依赖的基础模块
  const configModule = createUnifiedConfigModule();
  const mediaModule = createUnifiedMediaModule();
  const trackModule = createUnifiedTrackModule();
  const notificationModule = createUnifiedNotificationModule();
  
  // 注册基础模块
  registry.register(MODULE_NAMES.CONFIG, configModule);
  registry.register(MODULE_NAMES.MEDIA, mediaModule);
  registry.register(MODULE_NAMES.TRACK, trackModule);
  registry.register(MODULE_NAMES.NOTIFICATION, notificationModule);
  
  // 阶段2：创建需要基础数据的模块
  const playbackModule = createUnifiedPlaybackModule(configModule.frameRate);
  registry.register(MODULE_NAMES.PLAYBACK, playbackModule);
  
  // 创建WebAV模块
  const webavModule = createUnifiedWebavModule({
    currentFrame: playbackModule.currentFrame,
    currentWebAVFrame: playbackModule.currentWebAVFrame,
    isPlaying: playbackModule.isPlaying,
    setCurrentFrame: playbackModule.setCurrentFrame,
    setPlaying: playbackModule.setPlaying,
  });
  registry.register(MODULE_NAMES.WEBAV, webavModule);
  
  // 阶段3：创建完全无依赖的高级模块（直接传入注册中心）
  const timelineModule = createUnifiedTimelineModule(registry);
  const projectModule = createUnifiedProjectModule(registry);
  const viewportModule = createUnifiedViewportModule();
  
  // 注册高级模块
  registry.register(MODULE_NAMES.TIMELINE, timelineModule);
  registry.register(MODULE_NAMES.PROJECT, projectModule);
  registry.register(MODULE_NAMES.VIEWPORT, viewportModule);
  
  // 继续创建其他模块...
  const historyModule = createUnifiedHistoryModule(notificationModule);
  registry.register(MODULE_NAMES.HISTORY, historyModule);
  
  return {
    // 状态和方法...
    registry // 暴露注册中心供高级使用
  };
});
```

## 优势分析

### 1. **完全消除循环依赖**
- 模块创建不再需要按特定顺序进行
- 所有模块都可以单独创建和测试
- 依赖在运行时动态解析

### 2. **简洁的模块化**
- 每个模块只需要一个通用的 `useModule` 函数
- 无需为每个依赖编写重复的getter函数
- 代码更加简洁易维护

### 3. **更好的类型安全**
- 通过类型映射保证类型安全
- 编译时可以检查模块引用的正确性
- 运行时错误更容易定位和修复

### 4. **更清晰的代码结构**
- 显著减少了样板代码（每个模块多个getter）
- 统一存储的创建逻辑变得清晰
- 依赖关系一目了然

## 重构步骤

### 阶段1：创建基础组件
1. 创建 `ModuleRegistry.ts` 和模块类型定义
2. 修改基础模块（不需要依赖的模块）保持原样

### 阶段2：改造依赖模块
1. 改造 `UnifiedTimelineModule` 采用通用访问器模式
2. 改造 `UnifiedProjectModule` 采用相同模式
3. 改造其他需要依赖的模块

### 阶段3：更新统一存储
1. 重构 `useUnifiedStore` 使用新的创建流程
2. 测试所有功能正常工作
3. 清理临时代码和调试信息

## 注意事项

1. **性能考虑**：动态依赖获取会有轻微的性能开销，但可以通过缓存机制优化
2. **错误处理**：需要完善的错误处理机制，确保模块未注册时能给出清晰的错误信息
3. **测试策略**：需要新的测试策略，确保模块在隔离环境下也能正常工作
4. **兼容性**：保持原有API不变，确保现有代码不需要修改

## 总结

这个重构方案通过"先创建后注册"的模式，使用通用模块访问器，彻底解决了统一存储中的循环依赖问题，同时避免了文档中原方案的大量重复代码问题。虽然增加了系统的复杂度，但带来的模块化和可维护性提升是显著的。建议逐步实施这个重构方案，确保每个阶段的功能完整性。