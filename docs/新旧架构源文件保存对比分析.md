# æ–°æ—§æ¶æ„æºæ–‡ä»¶ä¿å­˜å¯¹æ¯”åˆ†æ

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº†æ—§æ¶æ„å’Œæ–°æ¶æ„åœ¨é¡¹ç›®ä¿å­˜æµç¨‹ä¸­æºæ–‡ä»¶å¤„ç†æ–¹é¢çš„å·®å¼‚ï¼Œå¹¶æä¾›äº†æ”¹è¿›å»ºè®®ï¼Œä»¥ç¡®ä¿æ–°æ¶æ„èƒ½å¤Ÿå®Œæ•´åœ°ä¿å­˜é¡¹ç›®ç´ æçš„æºæ–‡ä»¶ã€‚

## æ—§æ¶æ„çš„æºæ–‡ä»¶ä¿å­˜æœºåˆ¶

æ—§æ¶æ„é€šè¿‡ `MediaManager.ts` å®ç°äº†å®Œæ•´çš„æºæ–‡ä»¶ä¿å­˜æœºåˆ¶ï¼š

### 1. æ–‡ä»¶ä¿å­˜æµç¨‹

é€šè¿‡ [`saveMediaToProject`](frontend/src/utils/MediaManager.ts:39) æ–¹æ³•å°†åŸå§‹æ–‡ä»¶ä¿å­˜åˆ°é¡¹ç›®ç›®å½•ï¼š

```typescript
async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string> {
  // è·å–é¡¹ç›®ç›®å½•
  const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
  const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
  
  // ç¡®ä¿mediaç›®å½•å­˜åœ¨
  const mediaHandle = await this.ensureDirectoryExists(projectHandle, this.MEDIA_FOLDER)
  
  // æ ¹æ®åª’ä½“ç±»å‹ç¡®å®šå­ç›®å½•
  let subFolder: string
  switch (mediaType) {
    case 'video': subFolder = this.VIDEOS_FOLDER; break
    case 'image': subFolder = this.IMAGES_FOLDER; break
    case 'audio': subFolder = this.AUDIO_FOLDER; break
  }
  
  // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼ˆé¿å…å†²çªï¼‰
  const timestamp = Date.now()
  const randomSuffix = Math.random().toString(36).substring(2, 8)
  const fileExtension = this.getFileExtension(file.name)
  const uniqueFileName = `${timestamp}_${randomSuffix}${fileExtension}`
  
  // ä¿å­˜æ–‡ä»¶
  const fileHandle = await subHandle.getFileHandle(uniqueFileName, { create: true })
  const writable = await fileHandle.createWritable()
  await writable.write(file)
  await writable.close()
  
  // è¿”å›ç›¸å¯¹è·¯å¾„
  return `${this.MEDIA_FOLDER}/${subFolder}/${uniqueFileName}`
}
```

### 2. å…ƒæ•°æ®ç®¡ç†

é€šè¿‡ [`generateMediaMetadata`](frontend/src/utils/MediaManager.ts:102) ç”Ÿæˆåª’ä½“å…ƒæ•°æ®ï¼š

```typescript
async generateMediaMetadata(
  file: File,
  clip: Raw<MP4Clip> | Raw<ImgClip> | Raw<AudioClip>,
  mediaType: MediaType,
): Promise<MediaMetadata> {
  // è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œ
  const checksum = await this.calculateChecksum(file)
  
  // ç­‰å¾…clipå‡†å¤‡å®Œæˆ
  const meta = await clip.ready
  
  // æ„å»ºå…ƒæ•°æ®
  const metadata: MediaMetadata = {
    id: Date.now().toString() + Math.random().toString(36).substring(2, 11),
    originalFileName: file.name,
    fileSize: file.size,
    mimeType: file.type,
    checksum,
    clipType,
    importedAt: new Date().toISOString(),
  }
  
  // æ ¹æ®åª’ä½“ç±»å‹æ·»åŠ ç‰¹å®šå…ƒæ•°æ®
  if (mediaType === 'video' || mediaType === 'audio') {
    metadata.duration = meta.duration
  }
  
  if (mediaType === 'video' || mediaType === 'image') {
    metadata.width = meta.width
    metadata.height = meta.height
  }
  
  return metadata
}
```

### 3. åª’ä½“å¼•ç”¨æœºåˆ¶

åœ¨é¡¹ç›®é…ç½®ä¸­ä¿å­˜ `localMediaReferences`ï¼Œè®°å½•åª’ä½“æ–‡ä»¶çš„å¼•ç”¨ä¿¡æ¯ï¼š

```typescript
// é¡¹ç›®é…ç½®ä¸­çš„åª’ä½“å¼•ç”¨
localMediaReferences: {
  [mediaId: string]: LocalMediaReference
}

// LocalMediaReference ç»“æ„
interface LocalMediaReference {
  originalFileName: string    // åŸå§‹æ–‡ä»¶å
  storedPath: string         // å­˜å‚¨è·¯å¾„
  type: MediaType            // åª’ä½“ç±»å‹
  fileSize: number           // æ–‡ä»¶å¤§å°
  checksum: string           // æ–‡ä»¶æ ¡éªŒå’Œ
  status?: 'ready' | 'error' // çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
  errorType?: MediaErrorType // é”™è¯¯ç±»å‹ï¼ˆå¯é€‰ï¼‰
  errorMessage?: string      // é”™è¯¯ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
  errorTimestamp?: string    // é”™è¯¯æ—¶é—´æˆ³ï¼ˆå¯é€‰ï¼‰
}
```

### 4. æ–‡ä»¶å®Œæ•´æ€§éªŒè¯

é€šè¿‡ [`verifyMediaIntegrity`](frontend/src/utils/MediaManager.ts:228) éªŒè¯æ–‡ä»¶å®Œæ•´æ€§ï¼š

```typescript
async verifyMediaIntegrity(
  projectId: string,
  storedPath: string,
  expectedChecksum: string,
): Promise<boolean> {
  try {
    const file = await this.loadMediaFromProject(projectId, storedPath)
    const actualChecksum = await this.calculateChecksum(file)
    return actualChecksum === expectedChecksum
  } catch (error) {
    console.error('éªŒè¯åª’ä½“æ–‡ä»¶å®Œæ•´æ€§å¤±è´¥:', error)
    return false
  }
}
```
## æ—§æ¶æ„åª’ä½“ä¿å­˜è§¦å‘æµç¨‹

æ—§æ¶æ„çš„åª’ä½“ä¿å­˜æœºåˆ¶é€šè¿‡å®Œæ•´çš„è°ƒç”¨é“¾è·¯å®ç°ï¼Œä»ç”¨æˆ·å¯¼å…¥åª’ä½“æ–‡ä»¶åˆ°å®é™…ä¿å­˜æºæ–‡ä»¶çš„æ•´ä¸ªæµç¨‹å¦‚ä¸‹ï¼š

### 1. ç”¨æˆ·è§¦å‘åª’ä½“å¯¼å…¥

ç”¨æˆ·é€šè¿‡ä»¥ä¸‹æ–¹å¼å¯¼å…¥åª’ä½“æ–‡ä»¶ï¼š
- æ‹–æ‹½æ–‡ä»¶åˆ° MediaLibrary ç»„ä»¶
- é€šè¿‡æ–‡ä»¶é€‰æ‹©å™¨é€‰æ‹©åª’ä½“æ–‡ä»¶

### 2. MediaLibrary.vue ç»„ä»¶å¤„ç†

åœ¨ [`MediaLibrary.vue`](frontend/src/components/MediaLibrary.vue) ç»„ä»¶ä¸­ï¼Œæœ‰ä¸‰ä¸ªä¸»è¦çš„åª’ä½“å¤„ç†å‡½æ•°ï¼š

#### 2.1 è§†é¢‘æ–‡ä»¶å¤„ç†
```typescript
// MediaLibrary.vue ç¬¬908è¡Œ
const addVideoItem = async (file: File) => {
  try {
    // å¤„ç†è§†é¢‘æ–‡ä»¶
    const mediaItem = await mediaManager.importMediaFiles([file], 'video')
    // ... å…¶ä»–å¤„ç†é€»è¾‘
  } catch (error) {
    console.error('æ·»åŠ è§†é¢‘æ–‡ä»¶å¤±è´¥:', error)
  }
}
```

#### 2.2 å›¾ç‰‡æ–‡ä»¶å¤„ç†
```typescript
// MediaLibrary.vue ç¬¬1021è¡Œ
const addImageItem = async (file: File) => {
  try {
    // å¤„ç†å›¾ç‰‡æ–‡ä»¶
    const mediaItem = await mediaManager.importMediaFiles([file], 'image')
    // ... å…¶ä»–å¤„ç†é€»è¾‘
  } catch (error) {
    console.error('æ·»åŠ å›¾ç‰‡æ–‡ä»¶å¤±è´¥:', error)
  }
}
```

#### 2.3 éŸ³é¢‘æ–‡ä»¶å¤„ç†
```typescript
// MediaLibrary.vue ç¬¬1166è¡Œ
const addAudioItem = async (file: File) => {
  try {
    // å¤„ç†éŸ³é¢‘æ–‡ä»¶
    const mediaItem = await mediaManager.importMediaFiles([file], 'audio')
    // ... å…¶ä»–å¤„ç†é€»è¾‘
  } catch (error) {
    console.error('æ·»åŠ éŸ³é¢‘æ–‡ä»¶å¤±è´¥:', error)
  }
}
```

### 3. MediaManager.importMediaFiles æ–¹æ³•

åœ¨ [`MediaManager.ts`](frontend/src/utils/MediaManager.ts:349) ä¸­ï¼Œ`importMediaFiles` æ–¹æ³•è´Ÿè´£å¤„ç†åª’ä½“æ–‡ä»¶çš„å¯¼å…¥ï¼š

```typescript
async importMediaFiles(files: File[], mediaType: MediaType): Promise<MediaItem[]> {
  const mediaItems: MediaItem[] = []
  
  for (const file of files) {
    try {
      // 1. åˆ›å»º WebAV Clip å¯¹è±¡
      const clip = await this.createClipFromFile(file, mediaType)
      
      // 2. ç”Ÿæˆåª’ä½“å…ƒæ•°æ®
      const metadata = await this.generateMediaMetadata(file, clip, mediaType)
      
      // 3. ä¿å­˜åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½• - å…³é”®æ­¥éª¤
      const storedPath = await this.saveMediaToProject(file, this.currentProjectId, mediaType)
      
      // 4. åˆ›å»ºåª’ä½“é¡¹ç›®
      const mediaItem: MediaItem = {
        id: metadata.id,
        name: metadata.originalFileName,
        file,
        url: URL.createObjectURL(file),
        mediaType,
        webav: clip,
        metadata,
        storedPath,
        status: 'ready'
      }
      
      mediaItems.push(mediaItem)
    } catch (error) {
      console.error(`å¯¼å…¥åª’ä½“æ–‡ä»¶å¤±è´¥: ${file.name}`, error)
      // åˆ›å»ºé”™è¯¯çŠ¶æ€çš„åª’ä½“é¡¹ç›®
      const errorItem: MediaItem = {
        id: Date.now().toString() + Math.random().toString(36).substring(2, 11),
        name: file.name,
        file,
        url: URL.createObjectURL(file),
        mediaType,
        status: 'error',
        errorMessage: error instanceof Error ? error.message : String(error)
      }
      mediaItems.push(errorItem)
    }
  }
  
  return mediaItems
}
```

### 4. saveMediaToProject æ–¹æ³•æ‰§è¡Œ

åœ¨ [`MediaManager.ts`](frontend/src/utils/MediaManager.ts:39) ä¸­ï¼Œ`saveMediaToProject` æ–¹æ³•æ‰§è¡Œå®é™…çš„æ–‡ä»¶ä¿å­˜æ“ä½œï¼š

```typescript
async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string> {
  // 1. è·å–é¡¹ç›®ç›®å½•
  const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
  const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
  
  // 2. ç¡®ä¿mediaç›®å½•å­˜åœ¨
  const mediaHandle = await this.ensureDirectoryExists(projectHandle, this.MEDIA_FOLDER)
  
  // 3. æ ¹æ®åª’ä½“ç±»å‹ç¡®å®šå­ç›®å½•
  let subFolder: string
  switch (mediaType) {
    case 'video': subFolder = this.VIDEOS_FOLDER; break
    case 'image': subFolder = this.IMAGES_FOLDER; break
    case 'audio': subFolder = this.AUDIO_FOLDER; break
  }
  
  // 4. ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼ˆé¿å…å†²çªï¼‰
  const timestamp = Date.now()
  const randomSuffix = Math.random().toString(36).substring(2, 8)
  const fileExtension = this.getFileExtension(file.name)
  const uniqueFileName = `${timestamp}_${randomSuffix}${fileExtension}`
  
  // 5. ä¿å­˜æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•
  const fileHandle = await subHandle.getFileHandle(uniqueFileName, { create: true })
  const writable = await fileHandle.createWritable()
  await writable.write(file)
  await writable.close()
  
  // 6. è¿”å›ç›¸å¯¹è·¯å¾„
  return `${this.MEDIA_FOLDER}/${subFolder}/${uniqueFileName}`
}
```

### 5. å®Œæ•´è§¦å‘æµç¨‹æ€»ç»“

æ—§æ¶æ„åª’ä½“ä¿å­˜çš„å®Œæ•´è§¦å‘æµç¨‹å¦‚ä¸‹ï¼š

1. **ç”¨æˆ·æ“ä½œ**ï¼šç”¨æˆ·é€šè¿‡æ‹–æ‹½æˆ–æ–‡ä»¶é€‰æ‹©å™¨å¯¼å…¥åª’ä½“æ–‡ä»¶
2. **ç»„ä»¶å“åº”**ï¼šMediaLibrary.vue ç»„ä»¶æ•è·æ–‡ä»¶è¾“å…¥äº‹ä»¶
3. **ç±»å‹åˆ¤æ–­**ï¼šæ ¹æ®æ–‡ä»¶ç±»å‹è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°ï¼ˆaddVideoItemã€addImageItemã€addAudioItemï¼‰
4. **åª’ä½“å¯¼å…¥**ï¼šè°ƒç”¨ MediaManager.importMediaFiles æ–¹æ³•å¤„ç†æ–‡ä»¶å¯¼å…¥
5. **æ–‡ä»¶ä¿å­˜**ï¼šåœ¨ importMediaFiles æ–¹æ³•ä¸­è°ƒç”¨ saveMediaToProject ä¿å­˜æºæ–‡ä»¶
6. **å…ƒæ•°æ®ç®¡ç†**ï¼šç”Ÿæˆå¹¶ä¿å­˜åª’ä½“å…ƒæ•°æ®æ–‡ä»¶
7. **å¼•ç”¨æ›´æ–°**ï¼šæ›´æ–°é¡¹ç›®é…ç½®ä¸­çš„åª’ä½“å¼•ç”¨æ˜ å°„

è¿™ä¸ªæµç¨‹ç¡®ä¿äº†æ¯æ¬¡ç”¨æˆ·å¯¼å…¥åª’ä½“æ–‡ä»¶æ—¶ï¼Œæºæ–‡ä»¶éƒ½ä¼šè¢«å®Œæ•´åœ°ä¿å­˜åˆ°é¡¹ç›®ç›®å½•ä¸­ï¼Œå¹¶å»ºç«‹ç›¸åº”çš„å¼•ç”¨å…³ç³»ï¼Œä¸ºé¡¹ç›®çš„å®Œæ•´æ€§å’Œå¯ç§»æ¤æ€§æä¾›äº†ä¿éšœã€‚

## æ–°æ¶æ„çš„æºæ–‡ä»¶ä¿å­˜ç°çŠ¶

æ–°æ¶æ„åœ¨ `UnifiedProjectModule.ts` å’Œ `unifiedProjectManager` ä¸­çš„å®ç°å­˜åœ¨æ˜æ˜¾ä¸è¶³ï¼š

### 1. ç¼ºå°‘æºæ–‡ä»¶ä¿å­˜

é¡¹ç›®ä¿å­˜åªä¿å­˜äº†é…ç½®ä¿¡æ¯ï¼Œæ²¡æœ‰å®é™…ä¿å­˜æºæ–‡ä»¶ï¼š

```typescript
// åœ¨ UnifiedProjectModule.ts çš„ saveCurrentProject æ–¹æ³•ä¸­
const updatedProject: UnifiedProjectConfig = {
  // ... å…¶ä»–é…ç½®
  
  // åª’ä½“æ•°æ® - ä¸ºç©ºå¯¹è±¡
  media: {},
}
```

### 2. åª’ä½“æ•°æ®å¤„ç†ä¸å½“

è™½ç„¶å¤„ç†äº†æ—¶é—´è½´é¡¹ç›®ä¸­çš„åª’ä½“æ•°æ®ï¼Œä½†åªæ˜¯å»é™¤äº†è¿è¡Œæ—¶å¯¹è±¡ï¼š

```typescript
// mediaItems åŒ…å« webav è¿è¡Œæ—¶å¯¹è±¡ï¼Œéœ€è¦æ¸…ç†
mediaItems: (mediaModule?.mediaItems.value || []).map(item => {
  // åˆ›å»ºåª’ä½“é¡¹ç›®çš„å¯æŒä¹…åŒ–å‰¯æœ¬ï¼Œå»æ‰è¿è¡Œæ—¶çš„ webav å¯¹è±¡
  const { webav, ...persistableItem } = item
  return persistableItem
}),
```

### 3. ç¼ºå°‘åª’ä½“å¼•ç”¨ç®¡ç†

æ²¡æœ‰å»ºç«‹åª’ä½“å¼•ç”¨æœºåˆ¶ï¼Œæ— æ³•è¿½è¸ªåª’ä½“æ–‡ä»¶çš„å­˜å‚¨ä½ç½®ï¼š

- ç¼ºå°‘åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•çš„ä¿å­˜é€»è¾‘
- ç¼ºå°‘æ–‡ä»¶å®Œæ•´æ€§éªŒè¯æœºåˆ¶
- ç¼ºå°‘åª’ä½“å…ƒæ•°æ®ç®¡ç†

## å·®å¼‚å¯¹æ¯”

| æ–¹é¢ | æ—§æ¶æ„ | æ–°æ¶æ„ |
|------|--------|--------|
| æºæ–‡ä»¶ä¿å­˜ | å®Œæ•´å®ç°ï¼Œä¿å­˜åˆ°é¡¹ç›®ç›®å½• | æœªå®ç° |
| åª’ä½“å¼•ç”¨ç®¡ç† | é€šè¿‡ `localMediaReferences` ç®¡ç† | ç¼ºå¤± |
| æ–‡ä»¶å®Œæ•´æ€§éªŒè¯ | SHA-256æ ¡éªŒå’ŒéªŒè¯ | ç¼ºå¤± |
| å…ƒæ•°æ®ç®¡ç† | ä¿å­˜ `.meta` æ–‡ä»¶ | ç¼ºå¤± |
| ç›®å½•ç»“æ„ | æŒ‰åª’ä½“ç±»å‹åˆ†ç±»å­˜å‚¨ | è™½ç„¶åˆ›å»ºç›®å½•ä½†æœªä½¿ç”¨ |
| é”™è¯¯å¤„ç† | å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ | åŸºç¡€é”™è¯¯å¤„ç† |

## æ”¹è¿›å»ºè®®

ä¸ºäº†å®Œå–„æ–°æ¶æ„çš„æºæ–‡ä»¶ä¿å­˜åŠŸèƒ½ï¼Œå»ºè®®é‡‡å–ä»¥ä¸‹æªæ–½ï¼š

### 1. å®ç°ç»Ÿä¸€çš„åª’ä½“ç®¡ç†å™¨

åˆ›å»º `UnifiedMediaManager` ç±»ï¼Œå‚è€ƒæ—§æ¶æ„çš„ `MediaManager`ï¼š

```typescript
// å»ºè®®åœ¨ frontend/src/unified/utils/UnifiedMediaManager.ts ä¸­å®ç°
export class UnifiedMediaManager {
  private static instance: UnifiedMediaManager
  
  // ä¿å­˜åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•
  async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string>
  
  // ç”Ÿæˆåª’ä½“å…ƒæ•°æ®
  async generateMediaMetadata(file: File, clip: any, mediaType: MediaType): Promise<UnifiedMediaMetadata>
  
  // ä¿å­˜åª’ä½“å…ƒæ•°æ®æ–‡ä»¶
  async saveMediaMetadata(projectId: string, storedPath: string, metadata: UnifiedMediaMetadata): Promise<void>
  
  // è®¡ç®—æ–‡ä»¶æ ¡éªŒå’Œ
  async calculateChecksum(file: File): Promise<string>
  
  // éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
  async verifyMediaIntegrity(projectId: string, storedPath: string, expectedChecksum: string): Promise<boolean>
  
  // ä»é¡¹ç›®ç›®å½•åŠ è½½åª’ä½“æ–‡ä»¶
  async loadMediaFromProject(projectId: string, storedPath: string): Promise<File>
}
```

### 2. æ‰©å±•é¡¹ç›®é…ç½®ç»“æ„

åœ¨ `UnifiedProjectConfig` ä¸­æ·»åŠ åª’ä½“å¼•ç”¨å­—æ®µï¼š

```typescript
// åœ¨ frontend/src/unified/project/types.ts ä¸­æ‰©å±•
export interface UnifiedProjectConfig {
  // ç°æœ‰å­—æ®µ...
  
  // åª’ä½“å¼•ç”¨æ˜ å°„
  mediaReferences: {
    [mediaId: string]: UnifiedMediaReference
  }
}

export interface UnifiedMediaReference {
  id: string                    // åª’ä½“ID
  originalFileName: string      // åŸå§‹æ–‡ä»¶å
  storedPath: string           // å­˜å‚¨è·¯å¾„
  mediaType: MediaType         // åª’ä½“ç±»å‹
  fileSize: number             // æ–‡ä»¶å¤§å°
  mimeType: string             // MIMEç±»å‹
  checksum: string             // æ–‡ä»¶æ ¡éªŒå’Œ
  metadata?: UnifiedMediaMetadata // åª’ä½“å…ƒæ•°æ®
  status?: 'ready' | 'error'   // çŠ¶æ€
  errorType?: string           // é”™è¯¯ç±»å‹
  errorMessage?: string        // é”™è¯¯ä¿¡æ¯
  errorTimestamp?: string      // é”™è¯¯æ—¶é—´æˆ³
}
```

### 3. ä¿®æ”¹é¡¹ç›®ä¿å­˜æµç¨‹

åœ¨ä¿å­˜é¡¹ç›®æ—¶ï¼ŒåŒæ—¶ä¿å­˜æ‰€æœ‰åª’ä½“æ–‡ä»¶ï¼š

```typescript
// ä¿®æ”¹ UnifiedProjectModule.ts ä¸­çš„ saveCurrentProject æ–¹æ³•
async function saveCurrentProject(): Promise<void> {
  try {
    isSaving.value = true
    console.log(`ğŸ’¾ ä¿å­˜é¡¹ç›®: ${configModule.projectName.value}`)
    configModule.projectUpdatedAt.value = new Date().toISOString()
    
    // 1. ä¿å­˜æ‰€æœ‰åª’ä½“æ–‡ä»¶
    const mediaReferences: Record<string, UnifiedMediaReference> = {}
    for (const mediaItem of mediaModule?.mediaItems.value || []) {
      if (mediaItem.file) {
        // ä¿å­˜åª’ä½“æ–‡ä»¶åˆ°é¡¹ç›®ç›®å½•
        const storedPath = await unifiedMediaManager.saveMediaToProject(
          mediaItem.file,
          configModule.projectId.value,
          mediaItem.mediaType
        )
        
        // ç”Ÿæˆå…ƒæ•°æ®
        const metadata = await unifiedMediaManager.generateMediaMetadata(
          mediaItem.file,
          mediaItem.webav,
          mediaItem.mediaType
        )
        
        // ä¿å­˜å…ƒæ•°æ®æ–‡ä»¶
        await unifiedMediaManager.saveMediaMetadata(
          configModule.projectId.value,
          storedPath,
          metadata
        )
        
        // åˆ›å»ºåª’ä½“å¼•ç”¨
        mediaReferences[mediaItem.id] = {
          id: mediaItem.id,
          originalFileName: mediaItem.name,
          storedPath,
          mediaType: mediaItem.mediaType,
          fileSize: mediaItem.file.size,
          mimeType: mediaItem.file.type,
          checksum: metadata.checksum,
          metadata,
          status: 'ready'
        }
      }
    }
    
    // 2. æ„å»ºæ›´æ–°çš„é¡¹ç›®é…ç½®
    const updatedProject: UnifiedProjectConfig = {
      // ... å…¶ä»–é…ç½®
      
      // åª’ä½“å¼•ç”¨æ˜ å°„
      mediaReferences,
    }
    
    // 3. è°ƒç”¨å®é™…çš„ä¿å­˜é€»è¾‘
    await unifiedProjectManager.saveProject(updatedProject)
    
    console.log(`âœ… é¡¹ç›®ä¿å­˜æˆåŠŸ: ${configModule.projectName.value}`)
  } catch (error) {
    console.error('ä¿å­˜é¡¹ç›®å¤±è´¥:', error)
    throw error
  } finally {
    isSaving.value = false
  }
}
```

### 4. å®ç°åª’ä½“åŠ è½½æœºåˆ¶

åœ¨é¡¹ç›®åŠ è½½æ—¶ï¼Œæ ¹æ®åª’ä½“å¼•ç”¨é‡å»ºåª’ä½“å¯¹è±¡ï¼š

```typescript
// ä¿®æ”¹ UnifiedProjectManager.ts ä¸­çš„ loadProjectContent æ–¹æ³•
async loadProjectContent(
  projectId: string,
  options: UnifiedLoadProjectOptions = {},
): Promise<UnifiedProjectLoadResult | null> {
  const { loadMedia = true, loadTimeline = true, onProgress } = options
  
  try {
    // 1. åŠ è½½é¡¹ç›®é…ç½®
    const projectConfig = await this.loadProjectJson(projectHandle)
    
    // 2. åŠ è½½åª’ä½“æ–‡ä»¶
    let mediaItems: UnifiedMediaItemData[] = []
    if (loadMedia && projectConfig.mediaReferences) {
      onProgress?.('åŠ è½½åª’ä½“æ–‡ä»¶...', 30)
      
      const mediaEntries = Object.entries(projectConfig.mediaReferences)
      for (const [mediaId, reference] of mediaEntries) {
        try {
          // åŠ è½½åª’ä½“æ–‡ä»¶
          const file = await unifiedMediaManager.loadMediaFromProject(
            projectId,
            reference.storedPath
          )
          
          // éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
          const isValid = await unifiedMediaManager.verifyMediaIntegrity(
            projectId,
            reference.storedPath,
            reference.checksum
          )
          
          if (!isValid) {
            throw new Error(`æ–‡ä»¶å®Œæ•´æ€§éªŒè¯å¤±è´¥: ${reference.originalFileName}`)
          }
          
          // é‡å»ºWebAV Clipå¯¹è±¡
          const clip = await this.rebuildWebAVClip(file, reference.mediaType)
          
          // åˆ›å»ºåª’ä½“é¡¹ç›®
          const mediaItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            file,
            url: URL.createObjectURL(file),
            mediaType: reference.mediaType,
            webav: clip,
            status: 'ready',
            // ... å…¶ä»–å­—æ®µ
          }
          
          mediaItems.push(mediaItem)
        } catch (error) {
          console.error(`åŠ è½½åª’ä½“å¤±è´¥: ${reference.originalFileName}`, error)
          // åˆ›å»ºé”™è¯¯çŠ¶æ€çš„åª’ä½“é¡¹ç›®
          const errorItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            mediaType: reference.mediaType,
            status: 'error',
            errorMessage: error instanceof Error ? error.message : String(error),
          }
          mediaItems.push(errorItem)
        }
      }
    }
    
    // 3. è¿”å›åŠ è½½ç»“æœ
    return {
      projectConfig,
      mediaItems,
      // ... å…¶ä»–å­—æ®µ
    }
  } catch (error) {
    console.error(`åŠ è½½é¡¹ç›®å†…å®¹å¤±è´¥: ${projectId}`, error)
    throw error
  }
}
```

## æ€»ç»“

æ—§æ¶æ„åœ¨æºæ–‡ä»¶ä¿å­˜æ–¹é¢æœ‰ç€å®Œæ•´ä¸”æˆç†Ÿçš„å®ç°ï¼ŒåŒ…æ‹¬æ–‡ä»¶ä¿å­˜ã€å…ƒæ•°æ®ç®¡ç†ã€å¼•ç”¨æœºåˆ¶å’Œå®Œæ•´æ€§éªŒè¯ç­‰å…³é”®åŠŸèƒ½ã€‚æ–°æ¶æ„ç›®å‰åªå®ç°äº†é¡¹ç›®é…ç½®çš„ä¿å­˜ï¼Œç¼ºå°‘å¯¹æºæ–‡ä»¶çš„å®é™…ä¿å­˜å’Œç®¡ç†ã€‚

é€šè¿‡å®æ–½ä¸Šè¿°æ”¹è¿›å»ºè®®ï¼Œæ–°æ¶æ„å°†èƒ½å¤Ÿï¼š
1. å®Œæ•´ä¿å­˜é¡¹ç›®ç´ æçš„æºæ–‡ä»¶
2. å»ºç«‹åª’ä½“å¼•ç”¨æœºåˆ¶ï¼Œç¡®ä¿é¡¹ç›®å¯ç§»æ¤æ€§
3. éªŒè¯æ–‡ä»¶å®Œæ•´æ€§ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
4. æä¾›å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶

è¿™äº›æ”¹è¿›å°†ä½¿æ–°æ¶æ„å…·å¤‡ä¸æ—§æ¶æ„ç›¸å½“çš„æºæ–‡ä»¶ä¿å­˜èƒ½åŠ›ï¼Œç¡®ä¿é¡¹ç›®çš„å®Œæ•´æ€§å’Œå¯ç§»æ¤æ€§ã€‚