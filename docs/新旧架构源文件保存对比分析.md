# 新旧架构源文件保存对比分析

## 概述

本文档详细分析了旧架构和新架构在项目保存流程中源文件处理方面的差异，并提供了改进建议，以确保新架构能够完整地保存项目素材的源文件。

## 旧架构的源文件保存机制

旧架构通过 `MediaManager.ts` 实现了完整的源文件保存机制：

### 1. 文件保存流程

通过 [`saveMediaToProject`](frontend/src/utils/MediaManager.ts:39) 方法将原始文件保存到项目目录：

```typescript
async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string> {
  // 获取项目目录
  const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
  const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
  
  // 确保media目录存在
  const mediaHandle = await this.ensureDirectoryExists(projectHandle, this.MEDIA_FOLDER)
  
  // 根据媒体类型确定子目录
  let subFolder: string
  switch (mediaType) {
    case 'video': subFolder = this.VIDEOS_FOLDER; break
    case 'image': subFolder = this.IMAGES_FOLDER; break
    case 'audio': subFolder = this.AUDIO_FOLDER; break
  }
  
  // 生成唯一文件名（避免冲突）
  const timestamp = Date.now()
  const randomSuffix = Math.random().toString(36).substring(2, 8)
  const fileExtension = this.getFileExtension(file.name)
  const uniqueFileName = `${timestamp}_${randomSuffix}${fileExtension}`
  
  // 保存文件
  const fileHandle = await subHandle.getFileHandle(uniqueFileName, { create: true })
  const writable = await fileHandle.createWritable()
  await writable.write(file)
  await writable.close()
  
  // 返回相对路径
  return `${this.MEDIA_FOLDER}/${subFolder}/${uniqueFileName}`
}
```

### 2. 元数据管理

通过 [`generateMediaMetadata`](frontend/src/utils/MediaManager.ts:102) 生成媒体元数据：

```typescript
async generateMediaMetadata(
  file: File,
  clip: Raw<MP4Clip> | Raw<ImgClip> | Raw<AudioClip>,
  mediaType: MediaType,
): Promise<MediaMetadata> {
  // 计算文件校验和
  const checksum = await this.calculateChecksum(file)
  
  // 等待clip准备完成
  const meta = await clip.ready
  
  // 构建元数据
  const metadata: MediaMetadata = {
    id: Date.now().toString() + Math.random().toString(36).substring(2, 11),
    originalFileName: file.name,
    fileSize: file.size,
    mimeType: file.type,
    checksum,
    clipType,
    importedAt: new Date().toISOString(),
  }
  
  // 根据媒体类型添加特定元数据
  if (mediaType === 'video' || mediaType === 'audio') {
    metadata.duration = meta.duration
  }
  
  if (mediaType === 'video' || mediaType === 'image') {
    metadata.width = meta.width
    metadata.height = meta.height
  }
  
  return metadata
}
```

### 3. 媒体引用机制

在项目配置中保存 `localMediaReferences`，记录媒体文件的引用信息：

```typescript
// 项目配置中的媒体引用
localMediaReferences: {
  [mediaId: string]: LocalMediaReference
}

// LocalMediaReference 结构
interface LocalMediaReference {
  originalFileName: string    // 原始文件名
  storedPath: string         // 存储路径
  type: MediaType            // 媒体类型
  fileSize: number           // 文件大小
  checksum: string           // 文件校验和
  status?: 'ready' | 'error' // 状态（可选）
  errorType?: MediaErrorType // 错误类型（可选）
  errorMessage?: string      // 错误信息（可选）
  errorTimestamp?: string    // 错误时间戳（可选）
}
```

### 4. 文件完整性验证

通过 [`verifyMediaIntegrity`](frontend/src/utils/MediaManager.ts:228) 验证文件完整性：

```typescript
async verifyMediaIntegrity(
  projectId: string,
  storedPath: string,
  expectedChecksum: string,
): Promise<boolean> {
  try {
    const file = await this.loadMediaFromProject(projectId, storedPath)
    const actualChecksum = await this.calculateChecksum(file)
    return actualChecksum === expectedChecksum
  } catch (error) {
    console.error('验证媒体文件完整性失败:', error)
    return false
  }
}
```
## 旧架构媒体保存触发流程

旧架构的媒体保存机制通过完整的调用链路实现，从用户导入媒体文件到实际保存源文件的整个流程如下：

### 1. 用户触发媒体导入

用户通过以下方式导入媒体文件：
- 拖拽文件到 MediaLibrary 组件
- 通过文件选择器选择媒体文件

### 2. MediaLibrary.vue 组件处理

在 [`MediaLibrary.vue`](frontend/src/components/MediaLibrary.vue) 组件中，有三个主要的媒体处理函数：

#### 2.1 视频文件处理
```typescript
// MediaLibrary.vue 第908行
const addVideoItem = async (file: File) => {
  try {
    // 处理视频文件
    const mediaItem = await mediaManager.importMediaFiles([file], 'video')
    // ... 其他处理逻辑
  } catch (error) {
    console.error('添加视频文件失败:', error)
  }
}
```

#### 2.2 图片文件处理
```typescript
// MediaLibrary.vue 第1021行
const addImageItem = async (file: File) => {
  try {
    // 处理图片文件
    const mediaItem = await mediaManager.importMediaFiles([file], 'image')
    // ... 其他处理逻辑
  } catch (error) {
    console.error('添加图片文件失败:', error)
  }
}
```

#### 2.3 音频文件处理
```typescript
// MediaLibrary.vue 第1166行
const addAudioItem = async (file: File) => {
  try {
    // 处理音频文件
    const mediaItem = await mediaManager.importMediaFiles([file], 'audio')
    // ... 其他处理逻辑
  } catch (error) {
    console.error('添加音频文件失败:', error)
  }
}
```

### 3. MediaManager.importMediaFiles 方法

在 [`MediaManager.ts`](frontend/src/utils/MediaManager.ts:349) 中，`importMediaFiles` 方法负责处理媒体文件的导入：

```typescript
async importMediaFiles(files: File[], mediaType: MediaType): Promise<MediaItem[]> {
  const mediaItems: MediaItem[] = []
  
  for (const file of files) {
    try {
      // 1. 创建 WebAV Clip 对象
      const clip = await this.createClipFromFile(file, mediaType)
      
      // 2. 生成媒体元数据
      const metadata = await this.generateMediaMetadata(file, clip, mediaType)
      
      // 3. 保存媒体文件到项目目录 - 关键步骤
      const storedPath = await this.saveMediaToProject(file, this.currentProjectId, mediaType)
      
      // 4. 创建媒体项目
      const mediaItem: MediaItem = {
        id: metadata.id,
        name: metadata.originalFileName,
        file,
        url: URL.createObjectURL(file),
        mediaType,
        webav: clip,
        metadata,
        storedPath,
        status: 'ready'
      }
      
      mediaItems.push(mediaItem)
    } catch (error) {
      console.error(`导入媒体文件失败: ${file.name}`, error)
      // 创建错误状态的媒体项目
      const errorItem: MediaItem = {
        id: Date.now().toString() + Math.random().toString(36).substring(2, 11),
        name: file.name,
        file,
        url: URL.createObjectURL(file),
        mediaType,
        status: 'error',
        errorMessage: error instanceof Error ? error.message : String(error)
      }
      mediaItems.push(errorItem)
    }
  }
  
  return mediaItems
}
```

### 4. saveMediaToProject 方法执行

在 [`MediaManager.ts`](frontend/src/utils/MediaManager.ts:39) 中，`saveMediaToProject` 方法执行实际的文件保存操作：

```typescript
async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string> {
  // 1. 获取项目目录
  const projectsHandle = await workspaceHandle.getDirectoryHandle('projects')
  const projectHandle = await projectsHandle.getDirectoryHandle(projectId)
  
  // 2. 确保media目录存在
  const mediaHandle = await this.ensureDirectoryExists(projectHandle, this.MEDIA_FOLDER)
  
  // 3. 根据媒体类型确定子目录
  let subFolder: string
  switch (mediaType) {
    case 'video': subFolder = this.VIDEOS_FOLDER; break
    case 'image': subFolder = this.IMAGES_FOLDER; break
    case 'audio': subFolder = this.AUDIO_FOLDER; break
  }
  
  // 4. 生成唯一文件名（避免冲突）
  const timestamp = Date.now()
  const randomSuffix = Math.random().toString(36).substring(2, 8)
  const fileExtension = this.getFileExtension(file.name)
  const uniqueFileName = `${timestamp}_${randomSuffix}${fileExtension}`
  
  // 5. 保存文件到项目目录
  const fileHandle = await subHandle.getFileHandle(uniqueFileName, { create: true })
  const writable = await fileHandle.createWritable()
  await writable.write(file)
  await writable.close()
  
  // 6. 返回相对路径
  return `${this.MEDIA_FOLDER}/${subFolder}/${uniqueFileName}`
}
```

### 5. 完整触发流程总结

旧架构媒体保存的完整触发流程如下：

1. **用户操作**：用户通过拖拽或文件选择器导入媒体文件
2. **组件响应**：MediaLibrary.vue 组件捕获文件输入事件
3. **类型判断**：根据文件类型调用相应的处理函数（addVideoItem、addImageItem、addAudioItem）
4. **媒体导入**：调用 MediaManager.importMediaFiles 方法处理文件导入
5. **文件保存**：在 importMediaFiles 方法中调用 saveMediaToProject 保存源文件
6. **元数据管理**：生成并保存媒体元数据文件
7. **引用更新**：更新项目配置中的媒体引用映射

这个流程确保了每次用户导入媒体文件时，源文件都会被完整地保存到项目目录中，并建立相应的引用关系，为项目的完整性和可移植性提供了保障。

## 新架构的源文件保存现状

新架构在 `UnifiedProjectModule.ts` 和 `unifiedProjectManager` 中的实现存在明显不足：

### 1. 缺少源文件保存

项目保存只保存了配置信息，没有实际保存源文件：

```typescript
// 在 UnifiedProjectModule.ts 的 saveCurrentProject 方法中
const updatedProject: UnifiedProjectConfig = {
  // ... 其他配置
  
  // 媒体数据 - 为空对象
  media: {},
}
```

### 2. 媒体数据处理不当

虽然处理了时间轴项目中的媒体数据，但只是去除了运行时对象：

```typescript
// mediaItems 包含 webav 运行时对象，需要清理
mediaItems: (mediaModule?.mediaItems.value || []).map(item => {
  // 创建媒体项目的可持久化副本，去掉运行时的 webav 对象
  const { webav, ...persistableItem } = item
  return persistableItem
}),
```

### 3. 缺少媒体引用管理

没有建立媒体引用机制，无法追踪媒体文件的存储位置：

- 缺少媒体文件到项目目录的保存逻辑
- 缺少文件完整性验证机制
- 缺少媒体元数据管理

## 差异对比

| 方面 | 旧架构 | 新架构 |
|------|--------|--------|
| 源文件保存 | 完整实现，保存到项目目录 | 未实现 |
| 媒体引用管理 | 通过 `localMediaReferences` 管理 | 缺失 |
| 文件完整性验证 | SHA-256校验和验证 | 缺失 |
| 元数据管理 | 保存 `.meta` 文件 | 缺失 |
| 目录结构 | 按媒体类型分类存储 | 虽然创建目录但未使用 |
| 错误处理 | 完善的错误处理机制 | 基础错误处理 |

## 改进建议

为了完善新架构的源文件保存功能，建议采取以下措施：

### 1. 实现统一的媒体管理器

创建 `UnifiedMediaManager` 类，参考旧架构的 `MediaManager`：

```typescript
// 建议在 frontend/src/unified/utils/UnifiedMediaManager.ts 中实现
export class UnifiedMediaManager {
  private static instance: UnifiedMediaManager
  
  // 保存媒体文件到项目目录
  async saveMediaToProject(file: File, projectId: string, mediaType: MediaType): Promise<string>
  
  // 生成媒体元数据
  async generateMediaMetadata(file: File, clip: any, mediaType: MediaType): Promise<UnifiedMediaMetadata>
  
  // 保存媒体元数据文件
  async saveMediaMetadata(projectId: string, storedPath: string, metadata: UnifiedMediaMetadata): Promise<void>
  
  // 计算文件校验和
  async calculateChecksum(file: File): Promise<string>
  
  // 验证文件完整性
  async verifyMediaIntegrity(projectId: string, storedPath: string, expectedChecksum: string): Promise<boolean>
  
  // 从项目目录加载媒体文件
  async loadMediaFromProject(projectId: string, storedPath: string): Promise<File>
}
```

### 2. 扩展项目配置结构

在 `UnifiedProjectConfig` 中添加媒体引用字段：

```typescript
// 在 frontend/src/unified/project/types.ts 中扩展
export interface UnifiedProjectConfig {
  // 现有字段...
  
  // 媒体引用映射
  mediaReferences: {
    [mediaId: string]: UnifiedMediaReference
  }
}

export interface UnifiedMediaReference {
  id: string                    // 媒体ID
  originalFileName: string      // 原始文件名
  storedPath: string           // 存储路径
  mediaType: MediaType         // 媒体类型
  fileSize: number             // 文件大小
  mimeType: string             // MIME类型
  checksum: string             // 文件校验和
  metadata?: UnifiedMediaMetadata // 媒体元数据
  status?: 'ready' | 'error'   // 状态
  errorType?: string           // 错误类型
  errorMessage?: string        // 错误信息
  errorTimestamp?: string      // 错误时间戳
}
```

### 3. 修改项目保存流程

在保存项目时，同时保存所有媒体文件：

```typescript
// 修改 UnifiedProjectModule.ts 中的 saveCurrentProject 方法
async function saveCurrentProject(): Promise<void> {
  try {
    isSaving.value = true
    console.log(`💾 保存项目: ${configModule.projectName.value}`)
    configModule.projectUpdatedAt.value = new Date().toISOString()
    
    // 1. 保存所有媒体文件
    const mediaReferences: Record<string, UnifiedMediaReference> = {}
    for (const mediaItem of mediaModule?.mediaItems.value || []) {
      if (mediaItem.file) {
        // 保存媒体文件到项目目录
        const storedPath = await unifiedMediaManager.saveMediaToProject(
          mediaItem.file,
          configModule.projectId.value,
          mediaItem.mediaType
        )
        
        // 生成元数据
        const metadata = await unifiedMediaManager.generateMediaMetadata(
          mediaItem.file,
          mediaItem.webav,
          mediaItem.mediaType
        )
        
        // 保存元数据文件
        await unifiedMediaManager.saveMediaMetadata(
          configModule.projectId.value,
          storedPath,
          metadata
        )
        
        // 创建媒体引用
        mediaReferences[mediaItem.id] = {
          id: mediaItem.id,
          originalFileName: mediaItem.name,
          storedPath,
          mediaType: mediaItem.mediaType,
          fileSize: mediaItem.file.size,
          mimeType: mediaItem.file.type,
          checksum: metadata.checksum,
          metadata,
          status: 'ready'
        }
      }
    }
    
    // 2. 构建更新的项目配置
    const updatedProject: UnifiedProjectConfig = {
      // ... 其他配置
      
      // 媒体引用映射
      mediaReferences,
    }
    
    // 3. 调用实际的保存逻辑
    await unifiedProjectManager.saveProject(updatedProject)
    
    console.log(`✅ 项目保存成功: ${configModule.projectName.value}`)
  } catch (error) {
    console.error('保存项目失败:', error)
    throw error
  } finally {
    isSaving.value = false
  }
}
```

### 4. 实现媒体加载机制

在项目加载时，根据媒体引用重建媒体对象：

```typescript
// 修改 UnifiedProjectManager.ts 中的 loadProjectContent 方法
async loadProjectContent(
  projectId: string,
  options: UnifiedLoadProjectOptions = {},
): Promise<UnifiedProjectLoadResult | null> {
  const { loadMedia = true, loadTimeline = true, onProgress } = options
  
  try {
    // 1. 加载项目配置
    const projectConfig = await this.loadProjectJson(projectHandle)
    
    // 2. 加载媒体文件
    let mediaItems: UnifiedMediaItemData[] = []
    if (loadMedia && projectConfig.mediaReferences) {
      onProgress?.('加载媒体文件...', 30)
      
      const mediaEntries = Object.entries(projectConfig.mediaReferences)
      for (const [mediaId, reference] of mediaEntries) {
        try {
          // 加载媒体文件
          const file = await unifiedMediaManager.loadMediaFromProject(
            projectId,
            reference.storedPath
          )
          
          // 验证文件完整性
          const isValid = await unifiedMediaManager.verifyMediaIntegrity(
            projectId,
            reference.storedPath,
            reference.checksum
          )
          
          if (!isValid) {
            throw new Error(`文件完整性验证失败: ${reference.originalFileName}`)
          }
          
          // 重建WebAV Clip对象
          const clip = await this.rebuildWebAVClip(file, reference.mediaType)
          
          // 创建媒体项目
          const mediaItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            file,
            url: URL.createObjectURL(file),
            mediaType: reference.mediaType,
            webav: clip,
            status: 'ready',
            // ... 其他字段
          }
          
          mediaItems.push(mediaItem)
        } catch (error) {
          console.error(`加载媒体失败: ${reference.originalFileName}`, error)
          // 创建错误状态的媒体项目
          const errorItem: UnifiedMediaItemData = {
            id: mediaId,
            name: reference.originalFileName,
            mediaType: reference.mediaType,
            status: 'error',
            errorMessage: error instanceof Error ? error.message : String(error),
          }
          mediaItems.push(errorItem)
        }
      }
    }
    
    // 3. 返回加载结果
    return {
      projectConfig,
      mediaItems,
      // ... 其他字段
    }
  } catch (error) {
    console.error(`加载项目内容失败: ${projectId}`, error)
    throw error
  }
}
```

## 总结

旧架构在源文件保存方面有着完整且成熟的实现，包括文件保存、元数据管理、引用机制和完整性验证等关键功能。新架构目前只实现了项目配置的保存，缺少对源文件的实际保存和管理。

通过实施上述改进建议，新架构将能够：
1. 完整保存项目素材的源文件
2. 建立媒体引用机制，确保项目可移植性
3. 验证文件完整性，确保数据一致性
4. 提供完善的错误处理机制

这些改进将使新架构具备与旧架构相当的源文件保存能力，确保项目的完整性和可移植性。