# 🏗️ 前端架构重构方案

> 基于媒体类型统一设计的全面架构重构

## 📊 项目背景

### 🎯 现有架构优势
1. **模块化设计优秀**：采用了清晰的模块化架构，每个模块职责明确
2. **状态管理合理**：使用Pinia + 模块化Store，状态管理清晰
3. **WebAV集成深度**：与WebAV库深度集成，渲染性能优秀
4. **组件层次清晰**：UI组件层次结构合理，职责分离良好

### ⚠️ 核心架构问题

#### 1. 媒体类型系统分裂
```typescript
// 当前问题：两套并行的类型系统
LocalMediaItem vs AsyncProcessingMediaItem
LocalTimelineItem vs AsyncProcessingTimelineItem
```

#### 2. 状态管理复杂化
```typescript
// 当前Store结构过于复杂
const mediaModule = createMediaModule()        // 本地媒体
const asyncProcessingItems = ref<AsyncProcessingMediaItem[]>([])  // 异步媒体
```

#### 3. 组件重复和分化
```typescript
// UI组件也被迫分化
TimelineVideoClip vs TimelineAsyncProcessingClip
```

## 🚀 统一架构重构方案

### 1. 核心设计理念

#### 🎯 统一媒体实体模型
```typescript
/**
 * 统一媒体实体 - 架构核心
 * 所有媒体相关的数据都统一到这个模型中
 */
export interface UnifiedMediaEntity {
  // ==================== 核心标识 ====================
  id: string
  name: string
  createdAt: string
  
  // ==================== 统一状态管理 ====================
  status: UnifiedMediaStatus
  mediaType: MediaType | 'unknown'
  
  // ==================== 数据源抽象 ====================
  source: MediaSource
  
  // ==================== 渲染对象（状态相关） ====================
  renderObjects?: {
    webavClip?: Raw<MP4Clip> | Raw<ImgClip> | Raw<AudioClip>
    sprite?: Raw<CustomSprite>
  }
  
  // ==================== 元数据（状态相关） ====================
  metadata?: {
    duration?: number
    thumbnailUrl?: string
    resolution?: { width: number; height: number }
    fileSize?: number
  }
  
  // ==================== 处理上下文（可选） ====================
  processingContext?: {
    type: ProcessingType
    progress: number
    config: ProcessingConfig
    error?: ProcessingError
    timeline?: ProcessingTimeline
  }
}

// 统一状态枚举
type UnifiedMediaStatus = 
  | 'initializing'   // 初始化
  | 'loading'        // 加载中（本地文件读取/远程下载）
  | 'processing'     // 处理中（WebAV解析/格式转换）
  | 'ready'          // 就绪
  | 'error'          // 错误
  | 'archived'       // 已归档

// 数据源抽象
type MediaSource = 
  | LocalFileSource 
  | RemoteSource 
  | GeneratedSource  // AI生成、文本渲染等
  | ImportedSource   // 从其他项目导入
```

#### 🏗️ 分层架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    表现层 (Presentation Layer)                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐   │
│  │ UI Components│  │    Views    │  │    Composables     │   │
│  └─────────────┘  └─────────────┘  └─────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                  业务逻辑层 (Business Logic Layer)             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐   │
│  │Media Service│  │Timeline Svc │  │   Render Service   │   │
│  └─────────────┘  └─────────────┘  └─────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                  数据访问层 (Data Access Layer)               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐   │
│  │Unified Store│  │Media Repo   │  │  Project Repo      │   │
│  └─────────────┘  └─────────────┘  └─────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                 基础设施层 (Infrastructure Layer)             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐   │
│  │WebAV Engine │  │File System  │  │  Storage Engine    │   │
│  └─────────────┘  └─────────────┘  └─────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2. 统一Store架构

#### 🎯 核心Store重构
```typescript
/**
 * 统一媒体Store - 替代现有的分离式Store
 */
export function createUnifiedMediaStore() {
  // ==================== 统一状态 ====================
  const mediaEntities = ref<UnifiedMediaEntity[]>([])
  const timelineItems = ref<UnifiedTimelineItem[]>([])
  
  // ==================== 计算属性 - 视图分离 ====================
  const readyMediaItems = computed(() => 
    mediaEntities.value.filter(entity => entity.status === 'ready')
  )
  
  const processingMediaItems = computed(() =>
    mediaEntities.value.filter(entity => 
      ['loading', 'processing'].includes(entity.status)
    )
  )
  
  const errorMediaItems = computed(() =>
    mediaEntities.value.filter(entity => entity.status === 'error')
  )
  
  // ==================== 统一操作接口 ====================
  
  /**
   * 添加媒体实体 - 统一入口
   */
  async function addMediaEntity(
    source: MediaSource,
    options: AddMediaOptions = {}
  ): Promise<string> {
    const entity: UnifiedMediaEntity = {
      id: generateId(),
      name: extractNameFromSource(source),
      createdAt: new Date().toISOString(),
      status: 'initializing',
      mediaType: 'unknown',
      source,
    }
    
    mediaEntities.value.push(entity)
    
    // 启动异步处理流水线
    processMediaEntity(entity.id)
    
    return entity.id
  }
  
  /**
   * 媒体处理流水线 - 状态驱动
   */
  async function processMediaEntity(entityId: string): Promise<void> {
    const entity = getMediaEntity(entityId)
    if (!entity) return
    
    try {
      // 状态机驱动的处理流程
      switch (entity.status) {
        case 'initializing':
          await initializeEntity(entity)
          break
        case 'loading':
          await loadEntityData(entity)
          break
        case 'processing':
          await processEntityWithWebAV(entity)
          break
      }
    } catch (error) {
      handleEntityError(entity, error)
    }
  }
  
  /**
   * 统一的WebAV处理
   */
  async function processEntityWithWebAV(entity: UnifiedMediaEntity): Promise<void> {
    entity.status = 'processing'
    
    const processor = getProcessorForSource(entity.source)
    const result = await processor.process(entity)
    
    entity.renderObjects = result.renderObjects
    entity.metadata = result.metadata
    entity.mediaType = result.mediaType
    entity.status = 'ready'
  }
}
```

#### 🔄 服务层抽象
```typescript
/**
 * 媒体服务层 - 业务逻辑封装
 */
export class MediaService {
  constructor(
    private store: UnifiedMediaStore,
    private webavEngine: WebAVEngine,
    private fileSystem: FileSystemService
  ) {}
  
  /**
   * 导入本地文件
   */
  async importLocalFiles(files: File[]): Promise<string[]> {
    const entityIds: string[] = []
    
    for (const file of files) {
      const source: LocalFileSource = {
        type: 'local',
        file,
        url: URL.createObjectURL(file)
      }
      
      const entityId = await this.store.addMediaEntity(source)
      entityIds.push(entityId)
    }
    
    return entityIds
  }
  
  /**
   * 远程下载
   */
  async downloadRemoteMedia(
    url: string, 
    config: RemoteDownloadConfig
  ): Promise<string> {
    const source: RemoteSource = {
      type: 'remote',
      url,
      config
    }
    
    return await this.store.addMediaEntity(source)
  }
  
  /**
   * 生成文本媒体
   */
  async generateTextMedia(
    text: string,
    style: TextStyleConfig
  ): Promise<string> {
    const source: GeneratedSource = {
      type: 'generated',
      generator: 'text',
      config: { text, style }
    }
    
    return await this.store.addMediaEntity(source)
  }
}
```

### 3. 组件架构统一

#### 🎯 统一媒体组件
```vue
<!-- UnifiedMediaItem.vue - 替代所有分离的媒体组件 -->
<template>
  <div class="unified-media-item" :class="statusClass">
    <!-- 缩略图区域 -->
    <div class="media-thumbnail">
      <img v-if="entity.metadata?.thumbnailUrl"
           :src="entity.metadata.thumbnailUrl" />
      <div v-else class="placeholder-thumbnail">
        <component :is="getMediaTypeIcon(entity.mediaType)" />
      </div>

      <!-- 状态覆盖层 -->
      <div v-if="showStatusOverlay" class="status-overlay">
        <component :is="getStatusComponent(entity.status)"
                   :entity="entity" />
      </div>
    </div>

    <!-- 信息区域 -->
    <div class="media-info">
      <h3>{{ entity.name }}</h3>
      <p class="media-status">{{ getStatusText(entity.status) }}</p>

      <!-- 元数据显示 -->
      <div v-if="entity.metadata" class="metadata">
        <span v-if="entity.metadata.duration">
          {{ formatDuration(entity.metadata.duration) }}
        </span>
        <span v-if="entity.metadata.fileSize">
          {{ formatFileSize(entity.metadata.fileSize) }}
        </span>
      </div>

      <!-- 处理进度 -->
      <div v-if="entity.processingContext" class="processing-info">
        <div class="progress-bar">
          <div class="progress-fill"
               :style="{ width: entity.processingContext.progress + '%' }">
          </div>
        </div>
        <span class="progress-text">
          {{ entity.processingContext.progress }}%
        </span>
      </div>
    </div>

    <!-- 操作按钮 -->
    <div class="media-actions">
      <component :is="getActionComponent(entity.status)"
                 :entity="entity"
                 @action="handleAction" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { UnifiedMediaEntity } from '../types'

interface Props {
  entity: UnifiedMediaEntity
}

const props = defineProps<Props>()

const statusClass = computed(() => `status-${props.entity.status}`)
const showStatusOverlay = computed(() =>
  ['loading', 'processing', 'error'].includes(props.entity.status)
)

// 状态驱动的组件选择
function getStatusComponent(status: UnifiedMediaStatus) {
  const components = {
    loading: 'LoadingIndicator',
    processing: 'ProcessingIndicator',
    error: 'ErrorIndicator',
    ready: null
  }
  return components[status]
}

function getActionComponent(status: UnifiedMediaStatus) {
  const components = {
    loading: 'CancelButton',
    processing: 'CancelButton',
    error: 'RetryButton',
    ready: 'MediaActions'
  }
  return components[status]
}
</script>
```

#### 🔄 统一时间轴组件
```vue
<!-- UnifiedTimelineClip.vue -->
<template>
  <div class="unified-timeline-clip"
       :class="[`media-${item.mediaType}`, `status-${item.status}`]">

    <!-- 基础时间轴项目渲染 -->
    <TimelineBaseClip
      :timeline-item="item"
      :track="track"
      @select="$emit('select', $event)"
      @update-position="$emit('update-position', $event)"
      @remove="$emit('remove', $event)">

      <template #content>
        <!-- 状态驱动的内容渲染 -->
        <component :is="getContentComponent(item)"
                   :item="item"
                   :media-entity="mediaEntity" />
      </template>

      <template #overlay v-if="showStatusOverlay">
        <component :is="getOverlayComponent(item.status)"
                   :item="item" />
      </template>
    </TimelineBaseClip>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { UnifiedTimelineItem, UnifiedMediaEntity } from '../types'

interface Props {
  item: UnifiedTimelineItem
  track?: Track
}

const props = defineProps<Props>()

const mediaEntity = computed(() =>
  getMediaEntity(props.item.mediaEntityId)
)

// 内容组件选择 - 基于媒体类型和状态
function getContentComponent(item: UnifiedTimelineItem) {
  if (item.status !== 'ready') {
    return 'PlaceholderContent'
  }

  const components = {
    video: 'VideoClipContent',
    image: 'ImageClipContent',
    audio: 'AudioClipContent',
    text: 'TextClipContent'
  }

  return components[item.mediaType] || 'UnknownClipContent'
}
</script>
```

### 4. 数据流架构优化

#### 🎯 统一数据流管理
```typescript
/**
 * 统一数据流管理
 */
export class UnifiedDataFlow {
  constructor(
    private mediaService: MediaService,
    private timelineService: TimelineService,
    private renderService: RenderService
  ) {}

  /**
   * 媒体导入流程 - 统一处理
   */
  async importMedia(source: MediaSource): Promise<void> {
    // 1. 创建媒体实体
    const entityId = await this.mediaService.addMediaEntity(source)

    // 2. 监听状态变化
    this.mediaService.watchEntityStatus(entityId, (status) => {
      if (status === 'ready') {
        this.notifyMediaReady(entityId)
      } else if (status === 'error') {
        this.handleMediaError(entityId)
      }
    })
  }

  /**
   * 时间轴操作流程 - 统一处理
   */
  async addToTimeline(
    entityId: string,
    trackId: string,
    position: number
  ): Promise<void> {
    // 1. 验证媒体实体状态
    const entity = await this.mediaService.getEntity(entityId)
    if (entity.status !== 'ready') {
      throw new Error('媒体未就绪，无法添加到时间轴')
    }

    // 2. 创建时间轴项目
    const timelineItem = await this.timelineService.createTimelineItem({
      mediaEntityId: entityId,
      trackId,
      position,
      duration: entity.metadata?.duration || 0
    })

    // 3. 创建渲染对象
    await this.renderService.createSprite(timelineItem.id, entity)
  }
}
```

### 5. WebAV集成优化

#### 🎯 统一WebAV适配器
```typescript
/**
 * WebAV统一适配器
 */
export class UnifiedWebAVAdapter {
  private clipCache = new Map<string, Raw<any>>()
  private spriteCache = new Map<string, Raw<any>>()

  /**
   * 统一Clip创建
   */
  async createClip(entity: UnifiedMediaEntity): Promise<Raw<any>> {
    const cacheKey = `${entity.id}-${entity.source.type}`

    if (this.clipCache.has(cacheKey)) {
      return this.cloneClip(this.clipCache.get(cacheKey)!)
    }

    let clip: Raw<any>

    switch (entity.source.type) {
      case 'local':
        clip = await this.createClipFromFile(entity.source.file, entity.mediaType)
        break
      case 'remote':
        clip = await this.createClipFromUrl(entity.source.url, entity.mediaType)
        break
      case 'generated':
        clip = await this.createClipFromGenerated(entity.source.config, entity.mediaType)
        break
      default:
        throw new Error(`不支持的数据源类型: ${entity.source.type}`)
    }

    this.clipCache.set(cacheKey, clip)
    return this.cloneClip(clip)
  }

  /**
   * 统一Sprite创建
   */
  async createSprite(
    timelineItem: UnifiedTimelineItem,
    entity: UnifiedMediaEntity
  ): Promise<Raw<any>> {
    const clip = await this.createClip(entity)

    const spriteFactory = this.getSpriteFactory(entity.mediaType)
    const sprite = await spriteFactory.create(clip)

    // 应用时间轴配置
    this.applyTimelineConfig(sprite, timelineItem)

    return sprite
  }

  private getSpriteFactory(mediaType: MediaType) {
    const factories = {
      video: VideoSpriteFactory,
      image: ImageSpriteFactory,
      audio: AudioSpriteFactory,
      text: TextSpriteFactory
    }

    return new factories[mediaType]()
  }
}
```

## 🔄 迁移策略

### Phase 1: 基础设施准备 (2-3周)
1. **创建统一类型定义**
   - 实现 `UnifiedMediaEntity` 和相关接口
   - 定义统一的状态枚举和数据源类型
   - 创建类型转换适配器

2. **建立服务层抽象**
   - 创建 `MediaService`, `TimelineService`, `RenderService`
   - 实现基础的依赖注入机制
   - 编写服务层单元测试

3. **构建新的Store结构**
   - 实现 `UnifiedMediaStore`
   - 创建向后兼容的计算属性
   - 设计状态迁移策略

### Phase 2: 核心功能迁移 (3-4周)
1. **迁移媒体导入功能**
   - 重构文件导入流程
   - 实现远程下载统一处理
   - 添加文本生成支持

2. **重构WebAV集成**
   - 实现统一WebAV适配器
   - 优化Clip和Sprite创建逻辑
   - 改进缓存和内存管理

3. **统一状态管理**
   - 实现状态驱动的处理流程
   - 添加统一的错误处理
   - 优化状态转换和事件通知

### Phase 3: 组件层重构 (2-3周)
1. **替换媒体组件**
   - 实现 `UnifiedMediaItem` 组件
   - 创建状态驱动的子组件
   - 更新媒体库视图

2. **统一时间轴组件**
   - 实现 `UnifiedTimelineClip` 组件
   - 重构时间轴渲染逻辑
   - 优化拖放和交互体验

3. **更新属性面板**
   - 基于统一模型重构属性面板
   - 实现动态属性编辑器
   - 优化关键帧编辑体验

### Phase 4: 优化和清理 (1-2周)
1. **移除遗留代码**
   - 清理旧的类型定义
   - 移除冗余组件
   - 优化导入和依赖

2. **性能优化**
   - 实现更高效的渲染策略
   - 优化状态更新和响应式
   - 改进内存管理

3. **测试和调试**
   - 编写集成测试
   - 进行性能基准测试
   - 修复边缘情况和兼容性问题

## 🎯 预期收益

### 1. 架构简化
- 减少50%的类型定义复杂度
- 统一的数据流和状态管理
- 更清晰的组件层次结构

### 2. 开发效率提升
- 新功能开发时间减少30%
- 统一的开发模式和最佳实践
- 更好的代码复用性

### 3. 维护性改善
- 统一的错误处理和状态管理
- 更容易的功能扩展
- 更好的测试覆盖率

### 4. 用户体验优化
- 一致的UI交互体验
- 更流畅的状态转换
- 更好的错误提示和恢复

## 📋 实施建议

1. **优先级排序**：先实施核心的统一媒体实体模型，再逐步迁移UI组件
2. **向后兼容**：在迁移过程中保持现有功能的正常运行
3. **渐进式重构**：分模块、分功能逐步迁移，避免大爆炸式重构
4. **充分测试**：每个阶段都要有完整的测试覆盖
5. **文档同步**：及时更新架构文档和开发指南

## ⚠️ 风险评估与应对

### 1. 技术风险
| 风险项 | 影响程度 | 概率 | 应对策略 |
|--------|----------|------|----------|
| WebAV兼容性问题 | 高 | 中 | 充分测试，保留回退方案 |
| 性能回归 | 中 | 低 | 性能基准测试，持续监控 |
| 状态管理复杂化 | 中 | 中 | 详细设计，分步验证 |

### 2. 项目风险
| 风险项 | 影响程度 | 概率 | 应对策略 |
|--------|----------|------|----------|
| 开发周期延长 | 中 | 中 | 分阶段交付，并行开发 |
| 团队学习成本 | 低 | 高 | 培训计划，文档支持 |
| 功能回归 | 高 | 低 | 完整测试覆盖，用户验收 |

### 3. 应对措施
1. **技术预研**：关键技术点提前验证
2. **原型开发**：核心功能先做原型验证
3. **分支开发**：使用feature分支，降低主线风险
4. **回退计划**：每个阶段都有明确的回退策略

## 🔧 技术实现细节

### 1. 状态机设计
```typescript
/**
 * 媒体实体状态机
 */
export class MediaEntityStateMachine {
  private transitions: Record<UnifiedMediaStatus, UnifiedMediaStatus[]> = {
    initializing: ['loading', 'error'],
    loading: ['processing', 'error'],
    processing: ['ready', 'error'],
    ready: ['archived', 'error'],
    error: ['loading', 'archived'],
    archived: ['loading']
  }

  canTransition(from: UnifiedMediaStatus, to: UnifiedMediaStatus): boolean {
    return this.transitions[from]?.includes(to) ?? false
  }

  async transition(
    entity: UnifiedMediaEntity,
    to: UnifiedMediaStatus
  ): Promise<void> {
    if (!this.canTransition(entity.status, to)) {
      throw new Error(`无效的状态转换: ${entity.status} -> ${to}`)
    }

    const oldStatus = entity.status
    entity.status = to

    // 触发状态变化事件
    this.emitStatusChange(entity, oldStatus, to)
  }
}
```

### 2. 依赖注入容器
```typescript
/**
 * 简单的依赖注入容器
 */
export class DIContainer {
  private services = new Map<string, any>()
  private factories = new Map<string, () => any>()

  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory)
  }

  get<T>(name: string): T {
    if (!this.services.has(name)) {
      const factory = this.factories.get(name)
      if (!factory) {
        throw new Error(`服务未注册: ${name}`)
      }
      this.services.set(name, factory())
    }
    return this.services.get(name)
  }
}

// 服务注册
const container = new DIContainer()
container.register('mediaService', () => new MediaService(
  container.get('unifiedStore'),
  container.get('webavEngine'),
  container.get('fileSystem')
))
```

### 3. 事件系统设计
```typescript
/**
 * 统一事件系统
 */
export class EventBus {
  private listeners = new Map<string, Function[]>()

  on(event: string, listener: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, [])
    }
    this.listeners.get(event)!.push(listener)
  }

  emit(event: string, ...args: any[]): void {
    const listeners = this.listeners.get(event) || []
    listeners.forEach(listener => listener(...args))
  }

  off(event: string, listener: Function): void {
    const listeners = this.listeners.get(event) || []
    const index = listeners.indexOf(listener)
    if (index > -1) {
      listeners.splice(index, 1)
    }
  }
}

// 事件定义
export const MediaEvents = {
  ENTITY_STATUS_CHANGED: 'entity:status:changed',
  ENTITY_ADDED: 'entity:added',
  ENTITY_REMOVED: 'entity:removed',
  TIMELINE_ITEM_ADDED: 'timeline:item:added',
  TIMELINE_ITEM_UPDATED: 'timeline:item:updated'
} as const
```

## 📊 性能优化策略

### 1. 渲染优化
- **虚拟滚动**：时间轴和媒体库使用虚拟滚动
- **懒加载**：缩略图和预览按需生成
- **缓存策略**：WebAV对象智能缓存和复用

### 2. 状态管理优化
- **计算属性缓存**：合理使用computed避免重复计算
- **批量更新**：状态变更批量处理，减少响应式触发
- **内存管理**：及时清理不需要的对象引用

### 3. 网络优化
- **请求合并**：批量处理远程资源请求
- **断点续传**：大文件下载支持断点续传
- **缓存策略**：合理的HTTP缓存和本地存储

## 📈 监控和度量

### 1. 性能指标
- **首屏加载时间**：< 2秒
- **媒体导入时间**：< 5秒（100MB文件）
- **时间轴渲染帧率**：> 30fps
- **内存使用**：< 500MB（正常使用）

### 2. 业务指标
- **功能完整性**：100%功能正常
- **错误率**：< 1%
- **用户满意度**：> 90%

### 3. 监控工具
- **性能监控**：使用Performance API
- **错误监控**：集成错误收集系统
- **用户行为**：关键操作埋点统计

## 🎯 总结

这个重构方案基于媒体类型统一设计思想，将整个前端架构提升到一个新的层次：

1. **解决当前问题**：消除类型系统分裂，简化状态管理
2. **提升开发效率**：统一的开发模式，更好的代码复用
3. **改善用户体验**：一致的交互体验，更流畅的状态转换
4. **奠定未来基础**：为新功能扩展提供坚实的架构基础

通过分阶段的渐进式重构，既能保证项目的稳定性，又能实现架构的全面升级。
