# ğŸ—ï¸ å‰ç«¯æ¶æ„é‡æ„æ–¹æ¡ˆ

> åŸºäºåª’ä½“ç±»å‹ç»Ÿä¸€è®¾è®¡çš„å…¨é¢æ¶æ„é‡æ„

## ğŸ“Š é¡¹ç›®èƒŒæ™¯

### ğŸ¯ ç°æœ‰æ¶æ„ä¼˜åŠ¿
1. **æ¨¡å—åŒ–è®¾è®¡ä¼˜ç§€**ï¼šé‡‡ç”¨äº†æ¸…æ™°çš„æ¨¡å—åŒ–æ¶æ„ï¼Œæ¯ä¸ªæ¨¡å—èŒè´£æ˜ç¡®
2. **çŠ¶æ€ç®¡ç†åˆç†**ï¼šä½¿ç”¨Pinia + æ¨¡å—åŒ–Storeï¼ŒçŠ¶æ€ç®¡ç†æ¸…æ™°
3. **WebAVé›†æˆæ·±åº¦**ï¼šä¸WebAVåº“æ·±åº¦é›†æˆï¼Œæ¸²æŸ“æ€§èƒ½ä¼˜ç§€
4. **ç»„ä»¶å±‚æ¬¡æ¸…æ™°**ï¼šUIç»„ä»¶å±‚æ¬¡ç»“æ„åˆç†ï¼ŒèŒè´£åˆ†ç¦»è‰¯å¥½

### âš ï¸ æ ¸å¿ƒæ¶æ„é—®é¢˜

#### 1. åª’ä½“ç±»å‹ç³»ç»Ÿåˆ†è£‚
```typescript
// å½“å‰é—®é¢˜ï¼šä¸¤å¥—å¹¶è¡Œçš„ç±»å‹ç³»ç»Ÿ
LocalMediaItem vs AsyncProcessingMediaItem
LocalTimelineItem vs AsyncProcessingTimelineItem
```

#### 2. çŠ¶æ€ç®¡ç†å¤æ‚åŒ–
```typescript
// å½“å‰Storeç»“æ„è¿‡äºå¤æ‚
const mediaModule = createMediaModule()        // æœ¬åœ°åª’ä½“
const asyncProcessingItems = ref<AsyncProcessingMediaItem[]>([])  // å¼‚æ­¥åª’ä½“
```

#### 3. ç»„ä»¶é‡å¤å’Œåˆ†åŒ–
```typescript
// UIç»„ä»¶ä¹Ÿè¢«è¿«åˆ†åŒ–
TimelineVideoClip vs TimelineAsyncProcessingClip
```

## ğŸš€ ç»Ÿä¸€æ¶æ„é‡æ„æ–¹æ¡ˆ

### 1. æ ¸å¿ƒè®¾è®¡ç†å¿µ

#### ğŸ¯ ç»Ÿä¸€åª’ä½“å®ä½“æ¨¡å‹
```typescript
/**
 * ç»Ÿä¸€åª’ä½“å®ä½“ - æ¶æ„æ ¸å¿ƒ
 * æ‰€æœ‰åª’ä½“ç›¸å…³çš„æ•°æ®éƒ½ç»Ÿä¸€åˆ°è¿™ä¸ªæ¨¡å‹ä¸­
 */
export interface UnifiedMediaEntity {
  // ==================== æ ¸å¿ƒæ ‡è¯† ====================
  id: string
  name: string
  createdAt: string
  
  // ==================== ç»Ÿä¸€çŠ¶æ€ç®¡ç† ====================
  status: UnifiedMediaStatus
  mediaType: MediaType | 'unknown'
  
  // ==================== æ•°æ®æºæŠ½è±¡ ====================
  source: MediaSource
  
  // ==================== æ¸²æŸ“å¯¹è±¡ï¼ˆçŠ¶æ€ç›¸å…³ï¼‰ ====================
  renderObjects?: {
    webavClip?: Raw<MP4Clip> | Raw<ImgClip> | Raw<AudioClip>
    sprite?: Raw<CustomSprite>
  }
  
  // ==================== å…ƒæ•°æ®ï¼ˆçŠ¶æ€ç›¸å…³ï¼‰ ====================
  metadata?: {
    duration?: number
    thumbnailUrl?: string
    resolution?: { width: number; height: number }
    fileSize?: number
  }
  
  // ==================== å¤„ç†ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰ ====================
  processingContext?: {
    type: ProcessingType
    progress: number
    config: ProcessingConfig
    error?: ProcessingError
    timeline?: ProcessingTimeline
  }
}

// ç»Ÿä¸€çŠ¶æ€æšä¸¾
type UnifiedMediaStatus = 
  | 'initializing'   // åˆå§‹åŒ–
  | 'loading'        // åŠ è½½ä¸­ï¼ˆæœ¬åœ°æ–‡ä»¶è¯»å–/è¿œç¨‹ä¸‹è½½ï¼‰
  | 'processing'     // å¤„ç†ä¸­ï¼ˆWebAVè§£æ/æ ¼å¼è½¬æ¢ï¼‰
  | 'ready'          // å°±ç»ª
  | 'error'          // é”™è¯¯
  | 'archived'       // å·²å½’æ¡£

// æ•°æ®æºæŠ½è±¡
type MediaSource = 
  | LocalFileSource 
  | RemoteSource 
  | GeneratedSource  // AIç”Ÿæˆã€æ–‡æœ¬æ¸²æŸ“ç­‰
  | ImportedSource   // ä»å…¶ä»–é¡¹ç›®å¯¼å…¥
```

#### ğŸ—ï¸ åˆ†å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¡¨ç°å±‚ (Presentation Layer)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ UI Componentsâ”‚  â”‚    Views    â”‚  â”‚    Composables     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚Media Serviceâ”‚  â”‚Timeline Svc â”‚  â”‚   Render Service   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ•°æ®è®¿é—®å±‚ (Data Access Layer)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚Unified Storeâ”‚  â”‚Media Repo   â”‚  â”‚  Project Repo      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚WebAV Engine â”‚  â”‚File System  â”‚  â”‚  Storage Engine    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. ç»Ÿä¸€Storeæ¶æ„

#### ğŸ¯ æ ¸å¿ƒStoreé‡æ„
```typescript
/**
 * ç»Ÿä¸€åª’ä½“Store - æ›¿ä»£ç°æœ‰çš„åˆ†ç¦»å¼Store
 */
export function createUnifiedMediaStore() {
  // ==================== ç»Ÿä¸€çŠ¶æ€ ====================
  const mediaEntities = ref<UnifiedMediaEntity[]>([])
  const timelineItems = ref<UnifiedTimelineItem[]>([])
  
  // ==================== è®¡ç®—å±æ€§ - è§†å›¾åˆ†ç¦» ====================
  const readyMediaItems = computed(() => 
    mediaEntities.value.filter(entity => entity.status === 'ready')
  )
  
  const processingMediaItems = computed(() =>
    mediaEntities.value.filter(entity => 
      ['loading', 'processing'].includes(entity.status)
    )
  )
  
  const errorMediaItems = computed(() =>
    mediaEntities.value.filter(entity => entity.status === 'error')
  )
  
  // ==================== ç»Ÿä¸€æ“ä½œæ¥å£ ====================
  
  /**
   * æ·»åŠ åª’ä½“å®ä½“ - ç»Ÿä¸€å…¥å£
   */
  async function addMediaEntity(
    source: MediaSource,
    options: AddMediaOptions = {}
  ): Promise<string> {
    const entity: UnifiedMediaEntity = {
      id: generateId(),
      name: extractNameFromSource(source),
      createdAt: new Date().toISOString(),
      status: 'initializing',
      mediaType: 'unknown',
      source,
    }
    
    mediaEntities.value.push(entity)
    
    // å¯åŠ¨å¼‚æ­¥å¤„ç†æµæ°´çº¿
    processMediaEntity(entity.id)
    
    return entity.id
  }
  
  /**
   * åª’ä½“å¤„ç†æµæ°´çº¿ - çŠ¶æ€é©±åŠ¨
   */
  async function processMediaEntity(entityId: string): Promise<void> {
    const entity = getMediaEntity(entityId)
    if (!entity) return
    
    try {
      // çŠ¶æ€æœºé©±åŠ¨çš„å¤„ç†æµç¨‹
      switch (entity.status) {
        case 'initializing':
          await initializeEntity(entity)
          break
        case 'loading':
          await loadEntityData(entity)
          break
        case 'processing':
          await processEntityWithWebAV(entity)
          break
      }
    } catch (error) {
      handleEntityError(entity, error)
    }
  }
  
  /**
   * ç»Ÿä¸€çš„WebAVå¤„ç†
   */
  async function processEntityWithWebAV(entity: UnifiedMediaEntity): Promise<void> {
    entity.status = 'processing'
    
    const processor = getProcessorForSource(entity.source)
    const result = await processor.process(entity)
    
    entity.renderObjects = result.renderObjects
    entity.metadata = result.metadata
    entity.mediaType = result.mediaType
    entity.status = 'ready'
  }
}
```

#### ğŸ”„ æœåŠ¡å±‚æŠ½è±¡
```typescript
/**
 * åª’ä½“æœåŠ¡å±‚ - ä¸šåŠ¡é€»è¾‘å°è£…
 */
export class MediaService {
  constructor(
    private store: UnifiedMediaStore,
    private webavEngine: WebAVEngine,
    private fileSystem: FileSystemService
  ) {}
  
  /**
   * å¯¼å…¥æœ¬åœ°æ–‡ä»¶
   */
  async importLocalFiles(files: File[]): Promise<string[]> {
    const entityIds: string[] = []
    
    for (const file of files) {
      const source: LocalFileSource = {
        type: 'local',
        file,
        url: URL.createObjectURL(file)
      }
      
      const entityId = await this.store.addMediaEntity(source)
      entityIds.push(entityId)
    }
    
    return entityIds
  }
  
  /**
   * è¿œç¨‹ä¸‹è½½
   */
  async downloadRemoteMedia(
    url: string, 
    config: RemoteDownloadConfig
  ): Promise<string> {
    const source: RemoteSource = {
      type: 'remote',
      url,
      config
    }
    
    return await this.store.addMediaEntity(source)
  }
  
  /**
   * ç”Ÿæˆæ–‡æœ¬åª’ä½“
   */
  async generateTextMedia(
    text: string,
    style: TextStyleConfig
  ): Promise<string> {
    const source: GeneratedSource = {
      type: 'generated',
      generator: 'text',
      config: { text, style }
    }
    
    return await this.store.addMediaEntity(source)
  }
}
```

### 3. ç»„ä»¶æ¶æ„ç»Ÿä¸€

#### ğŸ¯ ç»Ÿä¸€åª’ä½“ç»„ä»¶
```vue
<!-- UnifiedMediaItem.vue - æ›¿ä»£æ‰€æœ‰åˆ†ç¦»çš„åª’ä½“ç»„ä»¶ -->
<template>
  <div class="unified-media-item" :class="statusClass">
    <!-- ç¼©ç•¥å›¾åŒºåŸŸ -->
    <div class="media-thumbnail">
      <img v-if="entity.metadata?.thumbnailUrl"
           :src="entity.metadata.thumbnailUrl" />
      <div v-else class="placeholder-thumbnail">
        <component :is="getMediaTypeIcon(entity.mediaType)" />
      </div>

      <!-- çŠ¶æ€è¦†ç›–å±‚ -->
      <div v-if="showStatusOverlay" class="status-overlay">
        <component :is="getStatusComponent(entity.status)"
                   :entity="entity" />
      </div>
    </div>

    <!-- ä¿¡æ¯åŒºåŸŸ -->
    <div class="media-info">
      <h3>{{ entity.name }}</h3>
      <p class="media-status">{{ getStatusText(entity.status) }}</p>

      <!-- å…ƒæ•°æ®æ˜¾ç¤º -->
      <div v-if="entity.metadata" class="metadata">
        <span v-if="entity.metadata.duration">
          {{ formatDuration(entity.metadata.duration) }}
        </span>
        <span v-if="entity.metadata.fileSize">
          {{ formatFileSize(entity.metadata.fileSize) }}
        </span>
      </div>

      <!-- å¤„ç†è¿›åº¦ -->
      <div v-if="entity.processingContext" class="processing-info">
        <div class="progress-bar">
          <div class="progress-fill"
               :style="{ width: entity.processingContext.progress + '%' }">
          </div>
        </div>
        <span class="progress-text">
          {{ entity.processingContext.progress }}%
        </span>
      </div>
    </div>

    <!-- æ“ä½œæŒ‰é’® -->
    <div class="media-actions">
      <component :is="getActionComponent(entity.status)"
                 :entity="entity"
                 @action="handleAction" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { UnifiedMediaEntity } from '../types'

interface Props {
  entity: UnifiedMediaEntity
}

const props = defineProps<Props>()

const statusClass = computed(() => `status-${props.entity.status}`)
const showStatusOverlay = computed(() =>
  ['loading', 'processing', 'error'].includes(props.entity.status)
)

// çŠ¶æ€é©±åŠ¨çš„ç»„ä»¶é€‰æ‹©
function getStatusComponent(status: UnifiedMediaStatus) {
  const components = {
    loading: 'LoadingIndicator',
    processing: 'ProcessingIndicator',
    error: 'ErrorIndicator',
    ready: null
  }
  return components[status]
}

function getActionComponent(status: UnifiedMediaStatus) {
  const components = {
    loading: 'CancelButton',
    processing: 'CancelButton',
    error: 'RetryButton',
    ready: 'MediaActions'
  }
  return components[status]
}
</script>
```

#### ğŸ”„ ç»Ÿä¸€æ—¶é—´è½´ç»„ä»¶
```vue
<!-- UnifiedTimelineClip.vue -->
<template>
  <div class="unified-timeline-clip"
       :class="[`media-${item.mediaType}`, `status-${item.status}`]">

    <!-- åŸºç¡€æ—¶é—´è½´é¡¹ç›®æ¸²æŸ“ -->
    <TimelineBaseClip
      :timeline-item="item"
      :track="track"
      @select="$emit('select', $event)"
      @update-position="$emit('update-position', $event)"
      @remove="$emit('remove', $event)">

      <template #content>
        <!-- çŠ¶æ€é©±åŠ¨çš„å†…å®¹æ¸²æŸ“ -->
        <component :is="getContentComponent(item)"
                   :item="item"
                   :media-entity="mediaEntity" />
      </template>

      <template #overlay v-if="showStatusOverlay">
        <component :is="getOverlayComponent(item.status)"
                   :item="item" />
      </template>
    </TimelineBaseClip>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { UnifiedTimelineItem, UnifiedMediaEntity } from '../types'

interface Props {
  item: UnifiedTimelineItem
  track?: Track
}

const props = defineProps<Props>()

const mediaEntity = computed(() =>
  getMediaEntity(props.item.mediaEntityId)
)

// å†…å®¹ç»„ä»¶é€‰æ‹© - åŸºäºåª’ä½“ç±»å‹å’ŒçŠ¶æ€
function getContentComponent(item: UnifiedTimelineItem) {
  if (item.status !== 'ready') {
    return 'PlaceholderContent'
  }

  const components = {
    video: 'VideoClipContent',
    image: 'ImageClipContent',
    audio: 'AudioClipContent',
    text: 'TextClipContent'
  }

  return components[item.mediaType] || 'UnknownClipContent'
}
</script>
```

### 4. æ•°æ®æµæ¶æ„ä¼˜åŒ–

#### ğŸ¯ ç»Ÿä¸€æ•°æ®æµç®¡ç†
```typescript
/**
 * ç»Ÿä¸€æ•°æ®æµç®¡ç†
 */
export class UnifiedDataFlow {
  constructor(
    private mediaService: MediaService,
    private timelineService: TimelineService,
    private renderService: RenderService
  ) {}

  /**
   * åª’ä½“å¯¼å…¥æµç¨‹ - ç»Ÿä¸€å¤„ç†
   */
  async importMedia(source: MediaSource): Promise<void> {
    // 1. åˆ›å»ºåª’ä½“å®ä½“
    const entityId = await this.mediaService.addMediaEntity(source)

    // 2. ç›‘å¬çŠ¶æ€å˜åŒ–
    this.mediaService.watchEntityStatus(entityId, (status) => {
      if (status === 'ready') {
        this.notifyMediaReady(entityId)
      } else if (status === 'error') {
        this.handleMediaError(entityId)
      }
    })
  }

  /**
   * æ—¶é—´è½´æ“ä½œæµç¨‹ - ç»Ÿä¸€å¤„ç†
   */
  async addToTimeline(
    entityId: string,
    trackId: string,
    position: number
  ): Promise<void> {
    // 1. éªŒè¯åª’ä½“å®ä½“çŠ¶æ€
    const entity = await this.mediaService.getEntity(entityId)
    if (entity.status !== 'ready') {
      throw new Error('åª’ä½“æœªå°±ç»ªï¼Œæ— æ³•æ·»åŠ åˆ°æ—¶é—´è½´')
    }

    // 2. åˆ›å»ºæ—¶é—´è½´é¡¹ç›®
    const timelineItem = await this.timelineService.createTimelineItem({
      mediaEntityId: entityId,
      trackId,
      position,
      duration: entity.metadata?.duration || 0
    })

    // 3. åˆ›å»ºæ¸²æŸ“å¯¹è±¡
    await this.renderService.createSprite(timelineItem.id, entity)
  }
}
```

### 5. WebAVé›†æˆä¼˜åŒ–

#### ğŸ¯ ç»Ÿä¸€WebAVé€‚é…å™¨
```typescript
/**
 * WebAVç»Ÿä¸€é€‚é…å™¨
 */
export class UnifiedWebAVAdapter {
  private clipCache = new Map<string, Raw<any>>()
  private spriteCache = new Map<string, Raw<any>>()

  /**
   * ç»Ÿä¸€Clipåˆ›å»º
   */
  async createClip(entity: UnifiedMediaEntity): Promise<Raw<any>> {
    const cacheKey = `${entity.id}-${entity.source.type}`

    if (this.clipCache.has(cacheKey)) {
      return this.cloneClip(this.clipCache.get(cacheKey)!)
    }

    let clip: Raw<any>

    switch (entity.source.type) {
      case 'local':
        clip = await this.createClipFromFile(entity.source.file, entity.mediaType)
        break
      case 'remote':
        clip = await this.createClipFromUrl(entity.source.url, entity.mediaType)
        break
      case 'generated':
        clip = await this.createClipFromGenerated(entity.source.config, entity.mediaType)
        break
      default:
        throw new Error(`ä¸æ”¯æŒçš„æ•°æ®æºç±»å‹: ${entity.source.type}`)
    }

    this.clipCache.set(cacheKey, clip)
    return this.cloneClip(clip)
  }

  /**
   * ç»Ÿä¸€Spriteåˆ›å»º
   */
  async createSprite(
    timelineItem: UnifiedTimelineItem,
    entity: UnifiedMediaEntity
  ): Promise<Raw<any>> {
    const clip = await this.createClip(entity)

    const spriteFactory = this.getSpriteFactory(entity.mediaType)
    const sprite = await spriteFactory.create(clip)

    // åº”ç”¨æ—¶é—´è½´é…ç½®
    this.applyTimelineConfig(sprite, timelineItem)

    return sprite
  }

  private getSpriteFactory(mediaType: MediaType) {
    const factories = {
      video: VideoSpriteFactory,
      image: ImageSpriteFactory,
      audio: AudioSpriteFactory,
      text: TextSpriteFactory
    }

    return new factories[mediaType]()
  }
}
```

## ğŸ”„ è¿ç§»ç­–ç•¥

### Phase 1: åŸºç¡€è®¾æ–½å‡†å¤‡ (2-3å‘¨)
1. **åˆ›å»ºç»Ÿä¸€ç±»å‹å®šä¹‰**
   - å®ç° `UnifiedMediaEntity` å’Œç›¸å…³æ¥å£
   - å®šä¹‰ç»Ÿä¸€çš„çŠ¶æ€æšä¸¾å’Œæ•°æ®æºç±»å‹
   - åˆ›å»ºç±»å‹è½¬æ¢é€‚é…å™¨

2. **å»ºç«‹æœåŠ¡å±‚æŠ½è±¡**
   - åˆ›å»º `MediaService`, `TimelineService`, `RenderService`
   - å®ç°åŸºç¡€çš„ä¾èµ–æ³¨å…¥æœºåˆ¶
   - ç¼–å†™æœåŠ¡å±‚å•å…ƒæµ‹è¯•

3. **æ„å»ºæ–°çš„Storeç»“æ„**
   - å®ç° `UnifiedMediaStore`
   - åˆ›å»ºå‘åå…¼å®¹çš„è®¡ç®—å±æ€§
   - è®¾è®¡çŠ¶æ€è¿ç§»ç­–ç•¥

### Phase 2: æ ¸å¿ƒåŠŸèƒ½è¿ç§» (3-4å‘¨)
1. **è¿ç§»åª’ä½“å¯¼å…¥åŠŸèƒ½**
   - é‡æ„æ–‡ä»¶å¯¼å…¥æµç¨‹
   - å®ç°è¿œç¨‹ä¸‹è½½ç»Ÿä¸€å¤„ç†
   - æ·»åŠ æ–‡æœ¬ç”Ÿæˆæ”¯æŒ

2. **é‡æ„WebAVé›†æˆ**
   - å®ç°ç»Ÿä¸€WebAVé€‚é…å™¨
   - ä¼˜åŒ–Clipå’ŒSpriteåˆ›å»ºé€»è¾‘
   - æ”¹è¿›ç¼“å­˜å’Œå†…å­˜ç®¡ç†

3. **ç»Ÿä¸€çŠ¶æ€ç®¡ç†**
   - å®ç°çŠ¶æ€é©±åŠ¨çš„å¤„ç†æµç¨‹
   - æ·»åŠ ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
   - ä¼˜åŒ–çŠ¶æ€è½¬æ¢å’Œäº‹ä»¶é€šçŸ¥

### Phase 3: ç»„ä»¶å±‚é‡æ„ (2-3å‘¨)
1. **æ›¿æ¢åª’ä½“ç»„ä»¶**
   - å®ç° `UnifiedMediaItem` ç»„ä»¶
   - åˆ›å»ºçŠ¶æ€é©±åŠ¨çš„å­ç»„ä»¶
   - æ›´æ–°åª’ä½“åº“è§†å›¾

2. **ç»Ÿä¸€æ—¶é—´è½´ç»„ä»¶**
   - å®ç° `UnifiedTimelineClip` ç»„ä»¶
   - é‡æ„æ—¶é—´è½´æ¸²æŸ“é€»è¾‘
   - ä¼˜åŒ–æ‹–æ”¾å’Œäº¤äº’ä½“éªŒ

3. **æ›´æ–°å±æ€§é¢æ¿**
   - åŸºäºç»Ÿä¸€æ¨¡å‹é‡æ„å±æ€§é¢æ¿
   - å®ç°åŠ¨æ€å±æ€§ç¼–è¾‘å™¨
   - ä¼˜åŒ–å…³é”®å¸§ç¼–è¾‘ä½“éªŒ

### Phase 4: ä¼˜åŒ–å’Œæ¸…ç† (1-2å‘¨)
1. **ç§»é™¤é—ç•™ä»£ç **
   - æ¸…ç†æ—§çš„ç±»å‹å®šä¹‰
   - ç§»é™¤å†—ä½™ç»„ä»¶
   - ä¼˜åŒ–å¯¼å…¥å’Œä¾èµ–

2. **æ€§èƒ½ä¼˜åŒ–**
   - å®ç°æ›´é«˜æ•ˆçš„æ¸²æŸ“ç­–ç•¥
   - ä¼˜åŒ–çŠ¶æ€æ›´æ–°å’Œå“åº”å¼
   - æ”¹è¿›å†…å­˜ç®¡ç†

3. **æµ‹è¯•å’Œè°ƒè¯•**
   - ç¼–å†™é›†æˆæµ‹è¯•
   - è¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
   - ä¿®å¤è¾¹ç¼˜æƒ…å†µå’Œå…¼å®¹æ€§é—®é¢˜

## ğŸ¯ é¢„æœŸæ”¶ç›Š

### 1. æ¶æ„ç®€åŒ–
- å‡å°‘50%çš„ç±»å‹å®šä¹‰å¤æ‚åº¦
- ç»Ÿä¸€çš„æ•°æ®æµå’ŒçŠ¶æ€ç®¡ç†
- æ›´æ¸…æ™°çš„ç»„ä»¶å±‚æ¬¡ç»“æ„

### 2. å¼€å‘æ•ˆç‡æå‡
- æ–°åŠŸèƒ½å¼€å‘æ—¶é—´å‡å°‘30%
- ç»Ÿä¸€çš„å¼€å‘æ¨¡å¼å’Œæœ€ä½³å®è·µ
- æ›´å¥½çš„ä»£ç å¤ç”¨æ€§

### 3. ç»´æŠ¤æ€§æ”¹å–„
- ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€ç®¡ç†
- æ›´å®¹æ˜“çš„åŠŸèƒ½æ‰©å±•
- æ›´å¥½çš„æµ‹è¯•è¦†ç›–ç‡

### 4. ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- ä¸€è‡´çš„UIäº¤äº’ä½“éªŒ
- æ›´æµç•…çš„çŠ¶æ€è½¬æ¢
- æ›´å¥½çš„é”™è¯¯æç¤ºå’Œæ¢å¤

## ğŸ“‹ å®æ–½å»ºè®®

1. **ä¼˜å…ˆçº§æ’åº**ï¼šå…ˆå®æ–½æ ¸å¿ƒçš„ç»Ÿä¸€åª’ä½“å®ä½“æ¨¡å‹ï¼Œå†é€æ­¥è¿ç§»UIç»„ä»¶
2. **å‘åå…¼å®¹**ï¼šåœ¨è¿ç§»è¿‡ç¨‹ä¸­ä¿æŒç°æœ‰åŠŸèƒ½çš„æ­£å¸¸è¿è¡Œ
3. **æ¸è¿›å¼é‡æ„**ï¼šåˆ†æ¨¡å—ã€åˆ†åŠŸèƒ½é€æ­¥è¿ç§»ï¼Œé¿å…å¤§çˆ†ç‚¸å¼é‡æ„
4. **å……åˆ†æµ‹è¯•**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½è¦æœ‰å®Œæ•´çš„æµ‹è¯•è¦†ç›–
5. **æ–‡æ¡£åŒæ­¥**ï¼šåŠæ—¶æ›´æ–°æ¶æ„æ–‡æ¡£å’Œå¼€å‘æŒ‡å—

## âš ï¸ é£é™©è¯„ä¼°ä¸åº”å¯¹

### 1. æŠ€æœ¯é£é™©
| é£é™©é¡¹ | å½±å“ç¨‹åº¦ | æ¦‚ç‡ | åº”å¯¹ç­–ç•¥ |
|--------|----------|------|----------|
| WebAVå…¼å®¹æ€§é—®é¢˜ | é«˜ | ä¸­ | å……åˆ†æµ‹è¯•ï¼Œä¿ç•™å›é€€æ–¹æ¡ˆ |
| æ€§èƒ½å›å½’ | ä¸­ | ä½ | æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼ŒæŒç»­ç›‘æ§ |
| çŠ¶æ€ç®¡ç†å¤æ‚åŒ– | ä¸­ | ä¸­ | è¯¦ç»†è®¾è®¡ï¼Œåˆ†æ­¥éªŒè¯ |

### 2. é¡¹ç›®é£é™©
| é£é™©é¡¹ | å½±å“ç¨‹åº¦ | æ¦‚ç‡ | åº”å¯¹ç­–ç•¥ |
|--------|----------|------|----------|
| å¼€å‘å‘¨æœŸå»¶é•¿ | ä¸­ | ä¸­ | åˆ†é˜¶æ®µäº¤ä»˜ï¼Œå¹¶è¡Œå¼€å‘ |
| å›¢é˜Ÿå­¦ä¹ æˆæœ¬ | ä½ | é«˜ | åŸ¹è®­è®¡åˆ’ï¼Œæ–‡æ¡£æ”¯æŒ |
| åŠŸèƒ½å›å½’ | é«˜ | ä½ | å®Œæ•´æµ‹è¯•è¦†ç›–ï¼Œç”¨æˆ·éªŒæ”¶ |

### 3. åº”å¯¹æªæ–½
1. **æŠ€æœ¯é¢„ç ”**ï¼šå…³é”®æŠ€æœ¯ç‚¹æå‰éªŒè¯
2. **åŸå‹å¼€å‘**ï¼šæ ¸å¿ƒåŠŸèƒ½å…ˆåšåŸå‹éªŒè¯
3. **åˆ†æ”¯å¼€å‘**ï¼šä½¿ç”¨featureåˆ†æ”¯ï¼Œé™ä½ä¸»çº¿é£é™©
4. **å›é€€è®¡åˆ’**ï¼šæ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„å›é€€ç­–ç•¥

## ğŸ”§ æŠ€æœ¯å®ç°ç»†èŠ‚

### 1. çŠ¶æ€æœºè®¾è®¡
```typescript
/**
 * åª’ä½“å®ä½“çŠ¶æ€æœº
 */
export class MediaEntityStateMachine {
  private transitions: Record<UnifiedMediaStatus, UnifiedMediaStatus[]> = {
    initializing: ['loading', 'error'],
    loading: ['processing', 'error'],
    processing: ['ready', 'error'],
    ready: ['archived', 'error'],
    error: ['loading', 'archived'],
    archived: ['loading']
  }

  canTransition(from: UnifiedMediaStatus, to: UnifiedMediaStatus): boolean {
    return this.transitions[from]?.includes(to) ?? false
  }

  async transition(
    entity: UnifiedMediaEntity,
    to: UnifiedMediaStatus
  ): Promise<void> {
    if (!this.canTransition(entity.status, to)) {
      throw new Error(`æ— æ•ˆçš„çŠ¶æ€è½¬æ¢: ${entity.status} -> ${to}`)
    }

    const oldStatus = entity.status
    entity.status = to

    // è§¦å‘çŠ¶æ€å˜åŒ–äº‹ä»¶
    this.emitStatusChange(entity, oldStatus, to)
  }
}
```

### 2. ä¾èµ–æ³¨å…¥å®¹å™¨
```typescript
/**
 * ç®€å•çš„ä¾èµ–æ³¨å…¥å®¹å™¨
 */
export class DIContainer {
  private services = new Map<string, any>()
  private factories = new Map<string, () => any>()

  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory)
  }

  get<T>(name: string): T {
    if (!this.services.has(name)) {
      const factory = this.factories.get(name)
      if (!factory) {
        throw new Error(`æœåŠ¡æœªæ³¨å†Œ: ${name}`)
      }
      this.services.set(name, factory())
    }
    return this.services.get(name)
  }
}

// æœåŠ¡æ³¨å†Œ
const container = new DIContainer()
container.register('mediaService', () => new MediaService(
  container.get('unifiedStore'),
  container.get('webavEngine'),
  container.get('fileSystem')
))
```

### 3. äº‹ä»¶ç³»ç»Ÿè®¾è®¡
```typescript
/**
 * ç»Ÿä¸€äº‹ä»¶ç³»ç»Ÿ
 */
export class EventBus {
  private listeners = new Map<string, Function[]>()

  on(event: string, listener: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, [])
    }
    this.listeners.get(event)!.push(listener)
  }

  emit(event: string, ...args: any[]): void {
    const listeners = this.listeners.get(event) || []
    listeners.forEach(listener => listener(...args))
  }

  off(event: string, listener: Function): void {
    const listeners = this.listeners.get(event) || []
    const index = listeners.indexOf(listener)
    if (index > -1) {
      listeners.splice(index, 1)
    }
  }
}

// äº‹ä»¶å®šä¹‰
export const MediaEvents = {
  ENTITY_STATUS_CHANGED: 'entity:status:changed',
  ENTITY_ADDED: 'entity:added',
  ENTITY_REMOVED: 'entity:removed',
  TIMELINE_ITEM_ADDED: 'timeline:item:added',
  TIMELINE_ITEM_UPDATED: 'timeline:item:updated'
} as const
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. æ¸²æŸ“ä¼˜åŒ–
- **è™šæ‹Ÿæ»šåŠ¨**ï¼šæ—¶é—´è½´å’Œåª’ä½“åº“ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
- **æ‡’åŠ è½½**ï¼šç¼©ç•¥å›¾å’Œé¢„è§ˆæŒ‰éœ€ç”Ÿæˆ
- **ç¼“å­˜ç­–ç•¥**ï¼šWebAVå¯¹è±¡æ™ºèƒ½ç¼“å­˜å’Œå¤ç”¨

### 2. çŠ¶æ€ç®¡ç†ä¼˜åŒ–
- **è®¡ç®—å±æ€§ç¼“å­˜**ï¼šåˆç†ä½¿ç”¨computedé¿å…é‡å¤è®¡ç®—
- **æ‰¹é‡æ›´æ–°**ï¼šçŠ¶æ€å˜æ›´æ‰¹é‡å¤„ç†ï¼Œå‡å°‘å“åº”å¼è§¦å‘
- **å†…å­˜ç®¡ç†**ï¼šåŠæ—¶æ¸…ç†ä¸éœ€è¦çš„å¯¹è±¡å¼•ç”¨

### 3. ç½‘ç»œä¼˜åŒ–
- **è¯·æ±‚åˆå¹¶**ï¼šæ‰¹é‡å¤„ç†è¿œç¨‹èµ„æºè¯·æ±‚
- **æ–­ç‚¹ç»­ä¼ **ï¼šå¤§æ–‡ä»¶ä¸‹è½½æ”¯æŒæ–­ç‚¹ç»­ä¼ 
- **ç¼“å­˜ç­–ç•¥**ï¼šåˆç†çš„HTTPç¼“å­˜å’Œæœ¬åœ°å­˜å‚¨

## ğŸ“ˆ ç›‘æ§å’Œåº¦é‡

### 1. æ€§èƒ½æŒ‡æ ‡
- **é¦–å±åŠ è½½æ—¶é—´**ï¼š< 2ç§’
- **åª’ä½“å¯¼å…¥æ—¶é—´**ï¼š< 5ç§’ï¼ˆ100MBæ–‡ä»¶ï¼‰
- **æ—¶é—´è½´æ¸²æŸ“å¸§ç‡**ï¼š> 30fps
- **å†…å­˜ä½¿ç”¨**ï¼š< 500MBï¼ˆæ­£å¸¸ä½¿ç”¨ï¼‰

### 2. ä¸šåŠ¡æŒ‡æ ‡
- **åŠŸèƒ½å®Œæ•´æ€§**ï¼š100%åŠŸèƒ½æ­£å¸¸
- **é”™è¯¯ç‡**ï¼š< 1%
- **ç”¨æˆ·æ»¡æ„åº¦**ï¼š> 90%

### 3. ç›‘æ§å·¥å…·
- **æ€§èƒ½ç›‘æ§**ï¼šä½¿ç”¨Performance API
- **é”™è¯¯ç›‘æ§**ï¼šé›†æˆé”™è¯¯æ”¶é›†ç³»ç»Ÿ
- **ç”¨æˆ·è¡Œä¸º**ï¼šå…³é”®æ“ä½œåŸ‹ç‚¹ç»Ÿè®¡

## ğŸ¯ æ€»ç»“

è¿™ä¸ªé‡æ„æ–¹æ¡ˆåŸºäºåª’ä½“ç±»å‹ç»Ÿä¸€è®¾è®¡æ€æƒ³ï¼Œå°†æ•´ä¸ªå‰ç«¯æ¶æ„æå‡åˆ°ä¸€ä¸ªæ–°çš„å±‚æ¬¡ï¼š

1. **è§£å†³å½“å‰é—®é¢˜**ï¼šæ¶ˆé™¤ç±»å‹ç³»ç»Ÿåˆ†è£‚ï¼Œç®€åŒ–çŠ¶æ€ç®¡ç†
2. **æå‡å¼€å‘æ•ˆç‡**ï¼šç»Ÿä¸€çš„å¼€å‘æ¨¡å¼ï¼Œæ›´å¥½çš„ä»£ç å¤ç”¨
3. **æ”¹å–„ç”¨æˆ·ä½“éªŒ**ï¼šä¸€è‡´çš„äº¤äº’ä½“éªŒï¼Œæ›´æµç•…çš„çŠ¶æ€è½¬æ¢
4. **å¥ å®šæœªæ¥åŸºç¡€**ï¼šä¸ºæ–°åŠŸèƒ½æ‰©å±•æä¾›åšå®çš„æ¶æ„åŸºç¡€

é€šè¿‡åˆ†é˜¶æ®µçš„æ¸è¿›å¼é‡æ„ï¼Œæ—¢èƒ½ä¿è¯é¡¹ç›®çš„ç¨³å®šæ€§ï¼Œåˆèƒ½å®ç°æ¶æ„çš„å…¨é¢å‡çº§ã€‚
