# 媒体类型统一设计方案

## 概述

当前项目中存在 `LocalMediaItem` 和 `AsyncProcessingMediaItem` 两套并行的媒体类型系统，导致架构复杂、代码重复、维护困难。本方案提出统一媒体类型的设计思路，将"本地"和"异步"从**类型区分**改为**状态区分**。

## 当前问题分析

### 1. 概念模型混乱
```typescript
// ❌ 当前设计：两种类型
LocalMediaItem vs AsyncProcessingMediaItem

// 问题：本质上都是"媒体项目"，不应该在类型层面区分
```

### 2. 架构复杂度过高
- 两套并行的类型系统
- 两套状态管理API
- 两套UI渲染逻辑
- 复杂的类型守卫和转换逻辑

### 3. 与WebAV设计冲突
WebAV是同步渲染库，假设所有素材都已准备好，但异步素材违背了这个假设。

## 统一设计方案

### 1. 核心思路

**重新理解"状态"vs"类型"**：
- "本地"和"异步"是**状态**，不是**类型**
- 统一为一种媒体类型，通过状态区分处理方式
- 属性分层：核心属性 + 状态相关属性 + 可选属性

### 2. 统一接口设计

```typescript
/**
 * 统一的媒体项目接口
 */
export interface MediaItem extends BaseMediaItem {
  // ==================== 核心属性（所有状态共有） ====================
  mediaType: MediaType | 'unknown'
  status: MediaStatus // 统一的状态管理
  
  // ==================== 数据源（联合类型） ====================
  source: LocalFileSource | RemoteSource
  
  // ==================== WebAV对象（状态相关） ====================
  clip?: {
    mp4Clip?: Raw<MP4Clip>
    imgClip?: Raw<ImgClip>
    audioClip?: Raw<AudioClip>
  }
  
  // ==================== 元数据（状态相关） ====================
  duration?: number // ready状态才有确切值
  thumbnailUrl?: string
  
  // ==================== 异步处理相关（可选） ====================
  asyncProcessing?: {
    type: AsyncProcessingType
    progress: number // 0-100
    expectedDuration: number
    config: AsyncProcessingConfig
    startedAt?: string
    completedAt?: string
    errorMessage?: string
    isConverting?: boolean
  }
}

// 数据源类型
type LocalFileSource = {
  type: 'local'
  file: File
  url: string
}

type RemoteSource = {
  type: 'remote'
  url: string
  // 其他远程源配置
}

// 统一的状态枚举
type MediaStatus = 
  | 'pending'      // 等待处理
  | 'downloading'  // 下载中
  | 'processing'   // 处理中（WebAV解析）
  | 'ready'        // 就绪
  | 'error'        // 错误
  | 'converting'   // 转换中（异步转本地）
```

### 3. 处理方式统一

#### 状态驱动的处理逻辑
```typescript
class MediaProcessor {
  async processMedia(mediaItem: MediaItem): Promise<void> {
    switch (mediaItem.status) {
      case 'pending':
        if (mediaItem.source.type === 'local') {
          await this.processLocalFile(mediaItem)
        } else {
          await this.startRemoteDownload(mediaItem)
        }
        break
        
      case 'downloading':
        // 只有远程源才会有这个状态
        await this.continueDownload(mediaItem)
        break
        
      case 'processing':
        // 本地和远程都需要WebAV处理
        await this.processWithWebAV(mediaItem)
        break
        
      // ... 其他状态
    }
  }
  
  private async processWithWebAV(mediaItem: MediaItem): Promise<void> {
    // 统一的WebAV处理逻辑，不区分来源
    const file = this.getFileFromSource(mediaItem.source)
    const clip = await this.createClip(file, mediaItem.mediaType)
    
    mediaItem.clip = { [mediaItem.mediaType + 'Clip']: clip }
    mediaItem.status = 'ready'
  }
}
```

#### 简化的类型守卫
```typescript
// ✅ 简化的类型守卫
function isReady(item: MediaItem): boolean {
  return item.status === 'ready'
}

function hasAsyncProcessing(item: MediaItem): boolean {
  return item.asyncProcessing != null
}

function isLocalSource(item: MediaItem): item is MediaItem & { source: LocalFileSource } {
  return item.source.type === 'local'
}

// ❌ 不再需要复杂的类型区分
// isLocalMediaItem vs isAsyncProcessingMediaItem
```

#### 统一的UI渲染
```typescript
// 统一的渲染逻辑
function renderMediaItem(item: MediaItem) {
  // 基础信息渲染
  const baseProps = {
    id: item.id,
    name: item.name,
    mediaType: item.mediaType,
    thumbnailUrl: item.thumbnailUrl
  }
  
  // 状态相关渲染
  switch (item.status) {
    case 'ready':
      return <ReadyMediaItem {...baseProps} duration={item.duration} />
      
    case 'downloading':
    case 'processing':
      const progress = item.asyncProcessing?.progress ?? 0
      return <ProcessingMediaItem {...baseProps} progress={progress} />
      
    case 'error':
      const error = item.asyncProcessing?.errorMessage ?? '未知错误'
      return <ErrorMediaItem {...baseProps} error={error} />
  }
}
```

## 迁移策略

### 阶段1：创建统一接口

```typescript
// 新的统一接口
export interface UnifiedMediaItem { /* 如上设计 */ }

// 兼容性适配器
export function adaptLocalMediaItem(local: LocalMediaItem): UnifiedMediaItem {
  return {
    id: local.id,
    name: local.name,
    mediaType: local.mediaType,
    status: local.status,
    source: {
      type: 'local',
      file: local.file,
      url: local.url
    },
    clip: {
      mp4Clip: local.mp4Clip,
      imgClip: local.imgClip,
      audioClip: local.audioClip
    },
    duration: local.duration,
    thumbnailUrl: local.thumbnailUrl
  }
}

export function adaptAsyncMediaItem(async: AsyncProcessingMediaItem): UnifiedMediaItem {
  return {
    id: async.id,
    name: async.name,
    mediaType: async.mediaType,
    status: async.processingStatus as MediaStatus,
    source: {
      type: 'remote',
      url: '' // 从processingConfig中提取
    },
    asyncProcessing: {
      type: async.processingType,
      progress: async.processingProgress,
      expectedDuration: async.expectedDuration,
      config: async.processingConfig,
      startedAt: async.startedAt,
      completedAt: async.completedAt,
      errorMessage: async.errorMessage,
      isConverting: async.isConverting
    },
    thumbnailUrl: async.thumbnailUrl
  }
}
```

### 阶段2：Store层迁移

```typescript
export function createMediaModule() {
  // 新的统一存储
  const mediaItems = ref<UnifiedMediaItem[]>([])
  
  // 兼容性方法（过渡期使用）
  const legacyLocalItems = computed(() => 
    mediaItems.value
      .filter(item => item.source.type === 'local' && item.status === 'ready')
      .map(adaptToLocalMediaItem)
  )
  
  const legacyAsyncItems = computed(() =>
    mediaItems.value
      .filter(item => item.asyncProcessing != null)
      .map(adaptToAsyncMediaItem)
  )
  
  // 统一的操作方法
  function addMediaItem(item: UnifiedMediaItem) {
    mediaItems.value.push(item)
  }
  
  function updateMediaItem(id: string, updates: Partial<UnifiedMediaItem>) {
    const index = mediaItems.value.findIndex(item => item.id === id)
    if (index !== -1) {
      Object.assign(mediaItems.value[index], updates)
    }
  }
  
  function removeMediaItem(id: string) {
    const index = mediaItems.value.findIndex(item => item.id === id)
    if (index !== -1) {
      mediaItems.value.splice(index, 1)
    }
  }
}
```

### 阶段3：UI组件迁移

```typescript
// 统一的媒体项目组件
<template>
  <div class="media-item" :class="statusClass">
    <div class="media-thumbnail">
      <img v-if="item.thumbnailUrl" :src="item.thumbnailUrl" />
      <div v-else class="placeholder-thumbnail">{{ mediaTypeIcon }}</div>
    </div>
    
    <div class="media-info">
      <h3>{{ item.name }}</h3>
      <p>{{ statusText }}</p>
      
      <!-- 进度条（仅处理中状态显示） -->
      <div v-if="isProcessing" class="progress-bar">
        <div class="progress-fill" :style="{ width: progress + '%' }"></div>
      </div>
      
      <!-- 时长信息（仅ready状态显示） -->
      <p v-if="item.status === 'ready' && item.duration">
        时长: {{ formatDuration(item.duration) }}
      </p>
      
      <!-- 错误信息（仅error状态显示） -->
      <p v-if="item.status === 'error'" class="error-message">
        {{ item.asyncProcessing?.errorMessage || '未知错误' }}
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { UnifiedMediaItem } from '../types'

interface Props {
  item: UnifiedMediaItem
}

const props = defineProps<Props>()

const statusClass = computed(() => `status-${props.item.status}`)
const isProcessing = computed(() => 
  ['downloading', 'processing', 'converting'].includes(props.item.status)
)
const progress = computed(() => props.item.asyncProcessing?.progress ?? 0)
const statusText = computed(() => {
  switch (props.item.status) {
    case 'pending': return '等待处理'
    case 'downloading': return '下载中'
    case 'processing': return '解析中'
    case 'converting': return '转换中'
    case 'ready': return '就绪'
    case 'error': return '错误'
    default: return '未知状态'
  }
})
</script>
```

## 关键优势

### 1. 概念统一
- 只有一种"媒体项目"概念
- 通过状态而非类型区分处理方式
- 符合直觉的设计模型

### 2. 代码简化
- 统一的处理逻辑
- 减少重复代码
- 简化类型守卫

### 3. 架构清晰
- 单一的状态管理
- 统一的UI渲染
- 清晰的数据流

### 4. 扩展性好
- 新增处理类型只需要添加状态
- 不需要创建新的类型系统
- 易于维护和测试

### 5. 与WebAV兼容
- 只有ready状态才创建WebAV对象
- 符合WebAV的设计哲学
- 减少架构冲突

## 实施建议

### 优先级
1. **高优先级**：创建统一接口和适配器
2. **中优先级**：迁移Store层和核心逻辑
3. **低优先级**：重构UI组件和工具函数

### 风险控制
- 保持向后兼容性
- 分阶段迁移，避免大爆炸式重构
- 充分测试每个迁移阶段

### 测试策略
- 单元测试覆盖适配器函数
- 集成测试验证状态转换
- E2E测试确保用户体验不变

## 结论

通过统一媒体类型设计，可以大大简化项目架构，提高代码质量和可维护性。虽然迁移工作量较大，但长期收益显著，建议分阶段实施。
